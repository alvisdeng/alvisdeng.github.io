<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态规划-股票买卖问题</title>
      <link href="2020/12/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E9%97%AE%E9%A2%98/"/>
      <url>2020/12/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><strong>LeetCode 题目:</strong></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/">买卖股票的最佳时机（简单）</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II（简单）</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">买卖股票的最佳时机 III（困难）</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">买卖股票的最佳时机 IV（困难）</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">最佳买卖股票时机含冷冻期（中等）</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费（中等）</a></p><p>这 6 道题目是有共性的，我们就抽出来第 4 道题目，因为这道题是一个最泛化的形式，其他的问题都是这个形式的简化，看下题目</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201225022523576.png" alt="image-20201225022523576" style="zoom:50%;" /></p><p><strong>一. 穷举思路</strong></p><p>在这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> <span class="keyword">in</span> 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> <span class="keyword">in</span> 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 择优(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure><p>比如说这个问题，<strong>每天都有三种「选择」</strong>：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k &gt; 0 的前提下操作。</p><p>很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。<strong>这个问题的「状态」有三个</strong>，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span> <span class="keyword">or</span> <span class="number">1</span>]</span><br><span class="line"><span class="number">0</span> &lt;= i &lt;= n-<span class="number">1</span>, <span class="number">1</span> &lt;= k &lt;= K</span><br><span class="line">n 为天数，大 K 为最多交易数</span><br><span class="line">此问题共 n × K × <span class="number">2</span> 种状态，全部穷举就能搞定。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; n:</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= k &lt;= K:</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> &#123;<span class="number">0</span>, <span class="number">1</span>&#125;:</span><br><span class="line">            dp[i][k][s] = <span class="built_in">max</span>(buy, sell, rest)</span><br></pre></td></tr></table></figure><p>而且我们可以用自然语言描述出每一个状态的含义，比如说 <code>dp[3][2][1]</code> 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 <code>dp[2][3][0]</code> 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？</p><p>我们想求的最终答案是 <code>dp[n - 1][K][0]</code>，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 <code>dp[n - 1][K][1]</code>？因为 <code>[1]</code> 代表手上还持有股票，<code>[0]</code> 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。</p><p><strong>二. 状态转移框架</strong></p><p>现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MOg91qJOV680ranYFeJ%2Fsync%2F298b4971971d6e850923f64ab74792b86aa5c668.png?alt=media" alt="img" style="zoom:50%;" /></p><p>通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">              <span class="built_in">max</span>(   选择 rest  ,             选择 sell      )</span><br><span class="line"></span><br><span class="line">解释：今天我没有持有股票，有两种可能：</span><br><span class="line">要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；</span><br><span class="line">要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。</span><br><span class="line"></span><br><span class="line">dp[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">              <span class="built_in">max</span>(   选择 rest  ,           选择 buy         )</span><br><span class="line"></span><br><span class="line">解释：今天我持有着股票，有两种可能：</span><br><span class="line">要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；</span><br><span class="line">要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。</span><br></pre></td></tr></table></figure><p>这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。</p><p><strong>Note: k 并不是指我们还剩下多少次交易机会, 而是指我们已经进行了多少次交易.</strong></p><p>现在，我们已经完成了动态规划中最困难的一步：状态转移方程。<strong>如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。</strong>不过还差最后一点点，就是定义 base case，即最简单的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dp[-<span class="number">1</span>][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">解释：因为 i 是从 <span class="number">0</span> 开始的，所以 i = -<span class="number">1</span> 意味着还没有开始，这时候的利润当然是 <span class="number">0</span> 。</span><br><span class="line">dp[-<span class="number">1</span>][k][<span class="number">1</span>] = -infinity</span><br><span class="line">解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">解释：因为 k 是从 <span class="number">1</span> 开始的，所以 k = <span class="number">0</span> 意味着我们还未进行交易，这时候利润当然是 <span class="number">0</span> 。</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line">解释：还未交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。</span><br></pre></td></tr></table></figure><p>把上面的状态转移方程总结一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">base case：</span><br><span class="line">dp[-<span class="number">1</span>][k][<span class="number">0</span>] = dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[-<span class="number">1</span>][k][<span class="number">1</span>] = dp[i][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line"></span><br><span class="line">状态转移方程：</span><br><span class="line">dp[i][k][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p><strong>三. 秒杀题目</strong></p><ol><li><p><strong>题目一: k=1</strong></p><p>Link: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/">买卖股票的最佳时机（简单）</a></p><p>直接套状态转移方程，根据 base case，可以做一些化简：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">状态转移方程</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">= <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br><span class="line">解释：k = <span class="number">0</span> 的 base case，所以 dp[i-<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">现在发现 k 都是 <span class="number">1</span>，不会改变，即 k 对状态转移已经没有影响了。</span><br><span class="line">可以进行进一步化简去掉所有 k：</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br></pre></td></tr></table></figure><p>进而我们可以写出代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(prices) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices))]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">len</span>(prices)-<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(prices) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp_i_0 = <span class="number">0</span></span><br><span class="line">        dp_i_1 = -prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            dp_i_0 = <span class="built_in">max</span>(dp_i_0, dp_i_1 + prices[i])</span><br><span class="line">            dp_i_1 = <span class="built_in">max</span>(dp_i_1, -prices[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp_i_0</span><br></pre></td></tr></table></figure></li><li><p><strong>题目二 k = infinity</strong></p><p>Link: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II（简单）</a></p><p>如果 k 为正无穷, 那么就可以认为 <strong>k 和 k-1 是一样的</strong>, 可以这样改写框架:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">状态转移方程:</span><br><span class="line">dp[i][k][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">= <span class="built_in">max</span>(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k][<span class="number">0</span>] - prices[i])</span><br><span class="line">    </span><br><span class="line">我们发现数组中的 k 已经不会改变了, 也就说不需要记录 k 这个状态了.</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i])</span><br></pre></td></tr></table></figure><p>因此解题代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(prices) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        dp_i_0 = <span class="number">0</span></span><br><span class="line">        dp_i_1 = -prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)):</span><br><span class="line">            dp_i_0 = <span class="built_in">max</span>(dp_i_0, dp_i_1+prices[i])</span><br><span class="line">            dp_i_1 = <span class="built_in">max</span>(dp_i_1, dp_i_0-prices[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp_i_0</span><br></pre></td></tr></table></figure></li><li><p><strong>题目三: k=2</strong></p><p>Link: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">买卖股票的最佳时机 III（困难）</a></p><p>k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。</p><p>这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始的状态转移方程，没有可化简的地方</span><br><span class="line">dp[i][k][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>注意, 由于这里的 k 不可消除, 我们需要对其进行穷举! 代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        K = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(prices) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp = [[[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(K+<span class="number">1</span>)]  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices))]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,K+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    dp[i][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                    dp[i][k][<span class="number">1</span>] = -prices[i]</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                dp[i][k][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">                dp[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">len</span>(prices)-<span class="number">1</span>][K][<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li><li><p><strong>题目四 k = any integer</strong></p><p>Link: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">买卖股票的最佳时机 IV（困难）</a></p><p>有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？</p><p>一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。</p><p>因此我们的代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, k, prices</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">maxProfit_inf</span>(<span class="params">prices</span>):</span></span><br><span class="line">            dp_i_0 = <span class="number">0</span></span><br><span class="line">            dp_i_1 = -prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)):</span><br><span class="line">                dp_i_0 = <span class="built_in">max</span>(dp_i_0, dp_i_1+prices[i])</span><br><span class="line">                dp_i_1 = <span class="built_in">max</span>(dp_i_1, dp_i_0-prices[i])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> dp_i_0</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(prices) == <span class="number">0</span> <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> k &gt;= <span class="built_in">len</span>(prices)/<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> maxProfit_inf(prices)</span><br><span class="line">        </span><br><span class="line">        dp = [[[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>)]  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices))]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    dp[i][m][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                    dp[i][m][<span class="number">1</span>] = -prices[i]</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                dp[i][m][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][m][<span class="number">0</span>], dp[i-<span class="number">1</span>][m][<span class="number">1</span>] + prices[i])</span><br><span class="line">                dp[i][m][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][m][<span class="number">1</span>], dp[i-<span class="number">1</span>][m-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">len</span>(prices)-<span class="number">1</span>][k][<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li><li><p><strong>题目五 k = inf with cooldown</strong></p><p>Link: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">最佳买卖股票时机含冷冻期（中等）</a></p><p>还是跟之前一样, 如果 k = inf 那么 k-1 和 k 就没有差别. 但是因为我们加入了冷却期, 所以这个时候我们的状态转移的 i 的关系就变了.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">状态转移方程:</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">2</span>][<span class="number">0</span>]-prices[i])</span><br></pre></td></tr></table></figure><p>那么我们的代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(prices) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices))]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = -prices[i]</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">1</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(<span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line">                dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br><span class="line">            </span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">2</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">len</span>(prices)-<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li><li><p><strong>题目六 k = inf with fee</strong></p><p>Link: <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费（中等）</a></p><p>我们现在需要付手续费, 那么我的状态转移方程又会发生改变.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i] - fee)</span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>那么我们代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices, fee</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :type fee: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(prices) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices))]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                dp[i][<span class="number">1</span>] = -prices[i]</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i] - fee)</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">len</span>(prices)-<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>隐马尔可夫模型(HMM)</title>
      <link href="2020/11/22/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B-HMM/"/>
      <url>2020/11/22/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B-HMM/</url>
      
        <content type="html"><![CDATA[<p>HMM 是可以用于标注问题的统计数学模型, 描述由隐藏的<strong>马尔科夫链</strong>随机生成观测序列的过程, 属于<strong>生成模型</strong>. HMM模型在语音识别、自然语言处理、生物信息、模式识别等领域有广泛的应用.</p><p>使用HMM模型来解决的问题一般有两个特征:</p><ol><li>问题是基于序列的, 比如时间序列、状态序列.</li><li>问题中有两类数据, 一类序列数据是可以观测到的, 即<strong>观测序列</strong>; 而另一类数据是不能观察到的, 即<strong>隐藏状态序列</strong>, 简称<strong>状态序列</strong>.</li></ol><p>如果问题有了这两个特征, 那么这个问题一般可以使用HMM模型尝试解决, 这样的问题在生活中是很多的. 例如, 说一句话, 发出的声音是观测序列, 想表达的意思是隐藏状态序列.</p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>隐马尔科夫模型是关于时序的概率模型, 描述由一个隐藏的<strong>马尔科夫链</strong>随机生成不可观测的状态随机序列, 再由各个状态生成一个观测而产生观测随机序列的过程. 隐藏的马尔科夫链随机生成的状态的序列, 称为<strong>状态序列 (state sequence)</strong>; 每个状态生成一个观测, 而由此产生的观测的随机序列, 称为<strong>观测序列 (observation sequence)</strong>.</p><p>隐马尔可夫模型由初始概率分布 ($\pi$), 状态转移概率分布 (A) 以及观测概率分布 (B) 确定. 隐马尔可夫模型的形式定义如下:</p><div class="table-container"><table><thead><tr><th>数学表达</th><th>解释</th></tr></thead><tbody><tr><td>$Q=\{q_1,q_2,…,q_N\}$</td><td>所有可能的<strong>状态集合</strong>, 状态总数为 $N$</td></tr><tr><td>$V=\{v_1,v_2,…,v_M\}$</td><td>所有可能的<strong>观测集合</strong>, 观测总数为 $M$</td></tr><tr><td>$I=(i_1,i_2,…,i_T)$</td><td>长度为 $T$ 的<strong>状态序列</strong></td></tr><tr><td>$O=(o_1,o_2,…,o_T)$</td><td>长度为 $T$ 的<strong>观测序列</strong></td></tr><tr><td>$A=[a_{ij}]_{N\times N}$</td><td><strong>状态转移概率矩阵</strong> (Transition  Probability Matrix)</td></tr><tr><td>$B=[b_j(k)]_{N\times M}$</td><td><strong>发射概率矩阵</strong> (Emission Probability Matrix)</td></tr><tr><td>$\pi=(\pi_i)$</td><td><strong>初始状态概率向量</strong></td></tr></tbody></table></div><p>隐马尔可夫模型由 $\pi,A,B$ 共同决定. 其中 $\pi,A$ 决定状态序列, $B$ 决定观测序列. 因此马尔可夫模型 $\lambda$ 可以用三元符号表示, 即</p><script type="math/tex; mode=display">\lambda=(\pi,A,B)</script><p>HMM 模型有两个假设:</p><ul><li><p><strong>齐次马尔科夫假设</strong></p><p>将马尔科夫假设作用于状态序列, 假设当前状态 $i_t$ 仅仅依赖于前一个状态 $i_{t-1}$, 连续多个状态构成隐马尔科夫链, 数学表达式为:</p><script type="math/tex; mode=display">P(i_t|i_{t-1},o_{t-1},i_{t-2},o_{t-2},i_{t-3},...,i_2,o_2,i_1,o_1)=P(i_t|i_{t-1})</script></li><li><p><strong>输出独立性假设</strong></p><p>任意时刻的观测 $o_t$ 只依赖于该时刻的状态 $i_t$, 与其他时刻的状态或观测独立无关, 数学表达式为:</p><script type="math/tex; mode=display">P(o_t|o_1,...,o_t,...,o_T,i_1,...,i_t,...,i_T)=P(o_t|i_t)</script></li></ul><p><strong>再看一个 HMM 的例子:</strong></p><p>假定你是一个在2799年研究地球暖化历史的气象学家, 你找不到在 2007 年夏天任何关于巴尔的摩, 马里兰州的天气的记录资料, 但是你发现了 Jason Eisner 的日记, 其中列出了在这个夏天的每一天他吃冰淇淋的数量. 我们的目的是利用这些关于冰淇淋的数量来估计每一天的气温. 为了简单起见, 我们假定每一天的天气只有两种状态: 冷或热 (C or H). 这样一来, Eisner 的问题可以描述如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个观察序列 O, 每一个观察是一个整数, 它对应于在某一给定的日子所吃冰淇淋的数量, 引起 Jason Eisner 吃冰淇淋的天气的状态序列是隐藏的, 这个隐藏的状态序列用 Q 表示, 它的值为 H 或 C.</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201120010009781.png" alt="image-20201120010009781" style="zoom:50%;" /></p><p>天气对应状态, 状态的集合是:</p><script type="math/tex; mode=display">Q=\{HOT,COLD\},N=2</script><p>所吃冰淇淋的数量对应观测, 观测的集合是:</p><script type="math/tex; mode=display">V=\{1,2,3\},M=2</script><p>初始概率分布为:</p><script type="math/tex; mode=display">\pi=(0.8,0.2)^T</script><p>状态转移概率分布为:</p><script type="math/tex; mode=display">A=\left[\begin{matrix}0.7,0.3\\0.4,0.6\end{matrix}\right]</script><p>发射概率分布为:</p><script type="math/tex; mode=display">B=\left[\begin{matrix}0.2,0.4,0.4\\0.5,0.4,0.1\end{matrix}\right]</script><h3 id="2-Inference-Problems"><a href="#2-Inference-Problems" class="headerlink" title="2. Inference Problems"></a>2. Inference Problems</h3><p>HMM 主要被用于解决以下几个问题:</p><ol><li><p><strong>Filtering Problem - Infering the present</strong></p><p>已知模型参数和一个观测序列 $O$, 求最后时刻各个隐含状态的概率分布, 即 $P(i_t|o_{1:t})$.</p><p><u>代表模型: Kalman Filter (卡尔曼滤波器)</u></p></li><li><p><strong>Smoothing Problem - Infering the past</strong></p><p>已知模型参数和一个观测序列 $O$, 求中间某时刻各个隐含状态的概率分布, 即 $P(i_t|o_{1:T}),t&lt;T$. </p></li><li><p><strong>Prediction Problem - Infering the future</strong></p><p>已知模型参数和一个观测序列 $O$, 求未来某时刻各个隐含状态的概率分布, 即 $P(i_t|o_{1:T}),t&gt;T$.</p></li><li><p><strong>Learning Problem</strong></p><p>已知观测序列 $O=(o_1,o_2,…,o_T)$, 估计模型 $\lambda=(A,B,\pi)$ 参数, 使得在该模型下观测序列概率 $P(O|\lambda)$ 最大, 即用极大似然估计的方法估计参数.</p></li><li><p><strong>Likelihood Problem</strong></p><p>给定模型参数和一个观测序列 $O$, 求观测序列出现的概率, 即 $P(o_{1:T})$.</p></li><li><p><strong>Decoding Problem</strong></p><p>已知模型参数和一个观测序列 $O$, 求对给定观测序列条件概率 $P(I|O)$ 最大的状态序列 $I$. </p></li></ol><h4 id="2-1-Filtering-Problem"><a href="#2-1-Filtering-Problem" class="headerlink" title="2.1 Filtering Problem"></a>2.1 Filtering Problem</h4><p>我们的目的是求 $P(i_t|o_{1:t})$, 很明显有:</p><script type="math/tex; mode=display">P(i_t|o_{1:t})=\frac{P(i_t,o_{1:t})}{P(o_{1:t})}</script><p>且有:</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}P(i_t|o_{1:t})=&P(i_t|o_t,o_{1:t-1})\\=&\alpha P(i_t,o_t|o_{1:t-1})\\=&\alpha\sum_{i_{t-1}}P(i_{t-1},i_t,o_t|o_{1:t-1})\\=&\alpha\sum_{i_{t-1}}P(i_{t-1}|o_{1:t-1})P(i_t|i_{t-1})P(o_t|i_t)\\=&\alpha P(o_t|i_t)\sum_{i_{t-1}}P(i_t|i_{t-1})P(i_{t-1}|o_{1:t-1})\end{aligned}\end{equation}</script><p>因此我们可以得到:</p><script type="math/tex; mode=display">P(i_t,o_{1:t})=P(o_t|i_t)\sum_{i_{t-1}}P(i_t|i_{t-1})P(i_{t-1},o_{1:t-1})</script><p>因此我们可以先想办法求得, $P(i_t,o_{1:t})$, 也就是 un-nomarlized filtered posterior distribution. 我们可以利用 Forward Algorithm 来求解该项.</p><p>我们记, $\alpha_t(i)=P(o_1,…,o_t,i_t=q_i|\lambda)$, 这个公式表示的是在之前所有的观测变量的前提下求出当前时刻的隐含状态的概率, 图示如下:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201122022424140.png" alt="image-20201122022424140" style="zoom:50%;" /></p><p>因此我们的思路就是递推求得前向概率 $\alpha_t(i)$, 最后求得 $P(O|\lambda)$.</p><p>其中, 不难得到:</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}P(O|\lambda)=&P(o_{1:T})\\=&\sum_{i=1}^N\frac{P(i_T=q_i,o_{1:T})}{P(i_T=q_i|o_{1:T})}\\=&\sum_{i=1}^NP(i_T=q_i,o_{1:T})\\=&\sum_{i=1}^N\alpha_T(i)&\end{aligned}\end{equation}</script><blockquote><p>  <strong>Forward Algorithm</strong></p><p>  输入: $\lambda=(\pi,A,B)$, 观测序列 $O$</p><p>  输出: 观测序列概率 $P(O|\lambda)$</p><p>  (1) 初值</p><script type="math/tex; mode=display">  \alpha_1(i)=\pi_ib_i(o_1),\quad i=1,2,...,N</script><p>  (2) 递推    对 $t=1,2,…,T-1$</p><script type="math/tex; mode=display">  \alpha_{t+1}(i)=[\sum_{j=1}^N\alpha_t(j)a_{ji}]b_i(o_{t+1}),\quad i=1,2,...,N</script><p>  (3) 终止</p><script type="math/tex; mode=display">  P(O|\lambda)=\sum_{i=1}^N\alpha_T(i)</script></blockquote><p>我们可以用一个图来进行表示:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201122030918321.png" alt="image-20201122030918321" style="zoom:50%;" /></p><h4 id="2-2-Smoothing-Problem"><a href="#2-2-Smoothing-Problem" class="headerlink" title="2.2 Smoothing Problem"></a>2.2 Smoothing Problem</h4><p>为了解决 Smoothing Problem, 我们要引入另外一种算法: Backward Algorithm.</p><p>我们首先定义一个后向概率:</p><script type="math/tex; mode=display">\beta_t(i)=P(o_{t+1},o_{t+2},...,o_T|i_t=q_i,\lambda)</script><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201122035338327.png" alt="image-20201122035338327" style="zoom:50%;" /></p><p>因此, 我们有 $\beta_1(i)=P(o_{2:T}|i_1=q_i,\lambda)$. 那么我们可以推导:</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}P(O|\lambda)=&P(o_{1:T}|\lambda)\\=&\sum_{i=1}^NP(o_{1:T},i_1=q_i|\lambda)\\=&\sum_{i=1}^NP(o_{1:T}|i_1=q_i,\lambda)P(i_1=q_i|\lambda)\\=&\sum_{i=1}^NP(o_1|o_{2:T},i_1=q_i,\lambda)P(o_{2:T},i_1=q_i|\lambda)\pi_i\\=&\sum_{i=1}^NP(o_1|i_1=q_i,\lambda)\beta_1(i)\pi_i\\=&\sum_{i=1}^Nb_i(o_1)\pi_i\beta_1(i)\end{aligned}\end{equation}</script><p>因此, 我们有算法</p><blockquote><p>  <strong>Backward Algorithm</strong></p><p>  输入: $\lambda=(\pi,A,B)$, 观测序列 $O$</p><p>  输出: 观测序列概率 $P(O|\lambda)$</p><p>  (1) 初值</p><script type="math/tex; mode=display">  \beta_T(i)=1,\quad i=1,2,...,N</script><p>  (2) 递推</p><p>  对 $t=T-1,T-2,…,1$</p><script type="math/tex; mode=display">  \beta_t(i)=\sum_{j=1}^Na_{ij}b_j(o_{t+1})\beta_{t+1}(j),\quad i=1,2,...,N</script><p>  (3) 终止</p><script type="math/tex; mode=display">  P(O|\lambda)=\sum_{i=1}^Nb_i(o_1)\pi_i\beta_1(i)</script></blockquote><p>因此, 针对 smoothing problem, 即 $P(i_t|o_{1:T}),t&lt;T$, 我们可以推导:</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}P(i_t,o_{1:T})=&P(i_t,o_{1:t})P(o_{t+1:T}|i_t,o_{1:t})\\=&P(i_t,o_{1:t})P(o_{t+1:T}|i_t)\\=&\alpha_t(i)\beta_t(i)\end{aligned}\end{equation}</script><p>进而</p><script type="math/tex; mode=display">P(i_t|o_{1:T})=\frac{\alpha_t(i)\beta_t(i)}{\sum_{j=1}^N\alpha_t(j)\beta_t(j)}</script><p>我们还可以进一步延展: 给定模型 $\lambda$ 和观测序列 $O$, 我们要求在时刻 $t$ 处于状态 $q_i$ 且在时刻 $t+1$ 处于状态 $q_j$ 的概率, 即 $P(i_t=q_i,i_{t+1}=q_j|o_{1:T})$, 我们可以推导得到:</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}P(i_t=q_i,i_{t+1}=q_j|o_{1:T})=\frac{\alpha_t(i)a_{ij}b_j(o_{t+1})\beta_{t+1}(j)}{\sum_{i=1}^N\sum_{j=1}^N\alpha_t(i)a_{ij}b_j(o_{t+1})\beta_{t+1}(j)}\end{aligned}\end{equation}</script><h4 id="2-3-Prediction-Problem"><a href="#2-3-Prediction-Problem" class="headerlink" title="2.3 Prediction Problem"></a>2.3 Prediction Problem</h4><p>我们这里只给出 one-step ahed predictive distribution:</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}P(o_{t+1}|o_{1:t})=&\sum_{i_t,i_{t+1}}P(i_t,i_{t+1},o_{t+1}|o_{1:t}) \\=&\sum_{i_t,i_{t+1}}P(o_{t+1}|i_{t},i_{t+1},o_{1:t})P(i_{t+1}|i_{t},o_{1:t})P(i_t|o_{1:t}) \\=&\sum_{i_t,i_{t+1}}P(o_{t+1}|i_{t+1})P(i_{t+1}|i_t)P(i_t|o_{1:t})\end{aligned}\end{equation}</script><h4 id="2-4-Learning-Problem"><a href="#2-4-Learning-Problem" class="headerlink" title="2.4 Learning Problem"></a>2.4 Learning Problem</h4><p>因为目前我还没有系统的学习过 EM 算法, 所以在这里先给出监督学习方法, 即用极大似然估计来估计隐马尔可夫的参数, 具体方法如下:</p><ol><li><p>初始状态概率 $\pi_i$</p><script type="math/tex; mode=display">\hat{\pi}_i=P(i_1=q_i)=\frac{N_{i_1=q_i}+1}{\sum_{j=1}^N(N_{i_1=q_j}+1)}</script></li><li><p>转移状态概率分布 $a_{ij}$</p><script type="math/tex; mode=display">\hat{a}_{ij}=P(i_t=q_j|i_{t-1}=q_i)=\frac{N_{i_t=q_j,i_{t-1}=q_i}+1}{\sum_{p=1}^N(N_{i_t=q_p,i_{t-1}=q_i}+1)}</script></li><li><p>发射概率分布 $b_j(k)$</p><script type="math/tex; mode=display">\hat{b}_j(k)=P(o_t=v_k|i_t=q_j)=\frac{N_{o_t=v_k,i_t=q_j}+1}{\sum_{p=1}^M(N_{o_t=v_p,i_t=q_j}+1)}</script></li></ol><h4 id="2-5-Likelihood-Problem"><a href="#2-5-Likelihood-Problem" class="headerlink" title="2.5 Likelihood Problem"></a>2.5 Likelihood Problem</h4><p>我们在之前的推导中已经给出了公式:</p><script type="math/tex; mode=display">P(O|\lambda)= \sum_{i=1}^N\alpha_T(i)\\P(O|\lambda) = \sum_{i=1}^Nb_i(o_1)\pi_i\beta_1(i)\\P(O|\lambda) = \sum_{i=1}^N\sum_{j=1}^N\alpha_t(i)a_{ij}b_j(o_{t+1})\beta_{t+1}(j), \quad t=1,2,...,T-1</script><h4 id="2-6-Decoding-Problem"><a href="#2-6-Decoding-Problem" class="headerlink" title="2.6 Decoding Problem"></a>2.6 Decoding Problem</h4><p>HMM 的解码算法有两种: <strong>近似算法 (Approximation Algorithm)</strong>和<strong>维特比算法 (Viterbi Algorithm)</strong>.</p><h5 id="2-6-1-Approximation-Algorithm"><a href="#2-6-1-Approximation-Algorithm" class="headerlink" title="2.6.1 Approximation Algorithm"></a>2.6.1 Approximation Algorithm</h5><p>近似算法其实是采取了我们在 Smoothing Problem 中所介绍的公式, 即 $P(i_t|o_{1:T}),t&lt;T$.</p><p>其想法是: 在每个时刻 $t$ 选择在该时刻最有可能出现的状态 $i_t^{*}$, 从而得到一个状态序列 $I^<em>=(i_1^{\</em>},i_2^{*},…,i_T^{*})$, 并将其作为预测的结果.</p><p>给定隐马尔可夫模型 $\lambda$ 和观测序列 $O$, 在时刻 $t$ 处于状态 $q_i$ 的概率 $\gamma_t(i)$ 是:</p><script type="math/tex; mode=display">\gamma_t(i)=P(i_t|o_{1:T})=\frac{\alpha_t(i)\beta_t(i)}{\sum_{j=1}^N\alpha_t(j)\beta_t(j)}</script><p>根据最小化贝叶斯风险准则, 在每一时刻最可能的状态 $i_t^*$ 是:</p><script type="math/tex; mode=display">i_t^*=\mathop{\arg\max}\limits_{1\le i\le N}[\gamma_t(i)],\quad t=1,2,...,T</script><p>备注: 这也是我在项目 <a href="https://github.com/alvisdeng/NLP-NER-Recognizer-with-HMMs">https://github.com/alvisdeng/NLP-NER-Recognizer-with-HMMs</a> 中使用的方法. 有很多math tricks 比如说在 log space 来进行计算, 具体可以参见 description.pdf 中的说明.</p><h5 id="2-6-2-Viterbi-Algorithm"><a href="#2-6-2-Viterbi-Algorithm" class="headerlink" title="2.6.2 Viterbi Algorithm"></a>2.6.2 Viterbi Algorithm</h5><p>[To be done] </p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Supervised Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贝叶斯统计之美</title>
      <link href="2020/11/19/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BB%9F%E8%AE%A1%E4%B9%8B%E7%BE%8E/"/>
      <url>2020/11/19/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BB%9F%E8%AE%A1%E4%B9%8B%E7%BE%8E/</url>
      
        <content type="html"><![CDATA[<p>贝叶斯估计, 最大似然估计(MLE), 最大后验概率估计(MAP) 这几个概念在机器学习和深度学习中经常碰到, 读文章的时候还感觉挺明白, 但独立思考时经常会傻傻分不清楚, 因此希望通过本文对其进行总结.</p><h3 id="1-Fundamentals"><a href="#1-Fundamentals" class="headerlink" title="1. Fundamentals"></a>1. Fundamentals</h3><p><strong>1.1 概率与统计</strong></p><p>下面的一段话引自LarrB Wasserman的《All of Statistics》, 对概率和统计推断的研究内容进行了描述:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The basic problem that we study in in probability is:</span><br><span class="line">Given a data generating process, what are the properties of the outcomes?</span><br><span class="line"></span><br><span class="line">The basic problem of statistical inference is the inverse of probability:</span><br><span class="line">Given the outcomes, what can we say about the process that generated the data?</span><br></pre></td></tr></table></figure><p><strong>1.2 描述和推断统计</strong></p><p><u>描述统计是对数据的一种概括:</u> </p><p>描述统计是罗列所有数据, 然后选择一些特征量 (例如均值、方差、中位数、四分中位数等) 对总体数据进行描述.</p><p><u>推断统计是一种对数据的推测:</u></p><p>推断统计无法获取所有数据, 只能得到部分数据, 然后根据得到的数据推测总体数据的情况.</p><p><strong>1.3 联合和边缘概率</strong></p><p>假设有随机变量 $A$ 和 $B$, 此时 $P(A=a,B=b)$ 用于表示 $A=a$ 且 $B=b$ 同时发生的概率. 这类包含多个条件且<strong>所有条件同时成立</strong>的概率称为<strong>联合概率</strong>. 请注意, 联合概率并不是其中某个条件成立的概率, 而是所有条件同时成立的概率. 与之对应地, $P(A=a)$ 或 $P(B=b)$ 这类<strong>仅与单个随机变量有关</strong>的概率称为<strong>边缘概率</strong>.</p><p><strong>1.4 条件概率</strong></p><p>条件概率表示在条件 $B=b$ 成立的情况下, $A=a$ 的概率，记作 $P(A=a|B=b)$, 或者说条件概率是指事件$A=a$ 在另外一个事件 $B=b$ 已经发生条件下的发生概率. 为了简洁表示, 后面省略a, b.</p><p>联合概率, 边缘概率, 条件概率的关系如下:</p><script type="math/tex; mode=display">P(A|B)=\frac{P(A,B)}{P(B)}</script><p>转换为乘法形式:</p><script type="math/tex; mode=display">P(A,B)=P(B)\times P(A|B)=P(A)\times P(B|A)</script><p><strong>1.5 全概率公式</strong></p><p>如果事件 $A_1,A_2,A_3,…,A_n$ 构成一个完备事件组, 即这些事件两两互斥, 其和为全集, 则有:</p><script type="math/tex; mode=display">P(B)=P(B|A_1)P(A_1)+P(B|A_2)P(A_2)+...+P(B|A_n)P(A_n)=\sum_{i=1}^nP(B|A_i)P(A_i)</script><p>上面的公式称为全概率公式, 全概率公式是对复杂事件AA的概率求解问题转化为了在不同情况下发生的简单事件的概率的求和问题.</p><p><strong>1.6 贝叶斯公式</strong></p><p>由条件概率的乘法形式可得:</p><script type="math/tex; mode=display">P(A|B)=\frac{P(B|A)}{P(B)}P(A)</script><p>上面的式子称为贝叶斯公式, 也叫做贝叶斯定理或贝叶斯法则. 在贝叶斯定理中, 每个名词都有约定俗成的名称:</p><ul><li>$P(A|B)$ 是已知 $B$ 发生后 $A$ 的<strong>条件概率</strong>, 也由于得自 $B$ 的取值而被称为 $A$ 的后验概率, 表示==事件 $B$ 发生后, 事件 $A$ 发生的置信度.==</li><li>$P(A)$ 是 $A$ 的<strong>先验概率</strong>或边缘概率, 表示==事件 $A$ 发生的置信度.==</li><li>$P(B|A)$ 是已知 $A$ 发生后 $B$ 的条件概率, 也由于得自 $A$ 的取值而被称作 $B$ 的后验概率, 也被称作<strong>似然函数.</strong></li><li>$P(B)$ 是 $B$ 的先验概率或边缘概率, 称为<strong>标准化常量.</strong></li><li>$\frac{P(B|A)}{P(B)}$ 称为标准似然比, 表示==事件 $B$ 为事件 $A$ 发生提供的支持程度.==</li></ul><p>因此贝叶斯公式可表示为: 后验概率=似然函数*先验概率/标准化常量=标准似然比*先验概率. 根据标准似然比的大小, 可分为下面三种情况:</p><ul><li>如果标准似然比 $&gt;1$, 则先验概率 $P(A)$ 得到增强, 事件 $B$ 的发生会增大事件 $A$ 发生的可能性;</li><li>如果标准似然比 $=1$. 则先验概率 $P(A)$ 保持不变, 事件 $B$ 的发生不影响事件 $A$ 发生的可能性;</li><li>如果标准似然比 $&lt;1$, 则先验概率 $P(A)$ 得到削弱, 事件 $B$ 的发生会降低事件 $A$ 发生的可能性.</li></ul><p>由全概率公式, 贝叶斯法则可得:</p><script type="math/tex; mode=display">P(A_i|B)=\frac{P(B|A_i)P(A_i)}{P(B)}=\frac{P(B|A_i)P(A_i)}{\sum_{j=1}^nP(B|A_j)P(A_j)}</script><p><strong>1.7 似然与概率</strong></p><p>在英文中, 似然（likelihood）和概率（probability）是同义词, 都指事件发生的可能性. 但在统计中, 似然与概率是不同的东西. </p><ul><li>概率是已知参数, 对结果可能性的预测. </li><li>似然是已知结果, 对参数是某个值的可能性预测.</li></ul><p>对于函数 $P(x|\theta)$, 从不同的观测角度来看可以分为以下两种情况:</p><ul><li>如果 $\theta$ 已知且保持不变, $x$ 是变量, 则称 $P(x|\theta)$ 为概率函数, 表示不同 $x$ 出现的概率.</li><li>如果 $x$ 已知且保持不变, $\theta$ 是变量, 则称 $P(x|\theta)$ 为似然函数, 表示不同 $\theta$ 下, $x$ 出现的概率, 也记作 $L(\theta|x)$ 或 $L(x;\theta)$.</li></ul><p><strong>注：</strong>注意似然函数的不同写法.</p><p><strong>1.8 频率学派和贝叶斯学派</strong></p><p><strong>注：</strong>频率学派与贝叶斯学派只是解决问题的角度不同.</p><p>频率学派与贝叶斯学派探讨「不确定性」这件事时的出发点与立足点不同. </p><ul><li><p><strong>频率主义学派 (Frequentist)</strong></p><p>频率学派从「自然」角度出发, 试图直接为「事件」本身建模, 即事件 $A$ 在独立重复试验中发生的频率趋于极限 $p$, 那么这个极限就是该事件的概率.</p><p>频率学派的代表是最大似然估计 (MLE).</p></li><li><p><strong>贝叶斯学派 (Bayesian)</strong></p><p>贝叶斯学派并不从试图刻画「事件」本身, 而从「观察者」角度出发. 贝叶斯学派并不试图说「事件本身是随机的」, 或者「世界的本体带有某种随机性」, 这套理论根本不言说关于「世界本体」的东西, 而只是从「观察者知识不完备」这一出发点开始, 构造一套在贝叶斯概率论的框架下可以对不确定知识做出推断的方法.</p><p>贝叶斯学派的代表是最大后验概率估计 (MAP).</p></li></ul><h3 id="2-MLE-amp-MAP"><a href="#2-MLE-amp-MAP" class="headerlink" title="2. MLE &amp; MAP"></a>2. MLE &amp; MAP</h3><p>以抛硬币为例, 假设我们有一枚硬币, 现在要估计其正面朝上的概率 $\theta$. 为了对 $\theta$ 进行估计, 我们进行了10次实验 (独立同分布, i.i.d.), 这组实验记为 $X=x_1,x_2,…,x_{10}$, 其中正面朝上的次数为6次, 反面朝上的次数为4次, 结果为$(1,0,1,1,0,0,0,1,1,1)$.</p><h4 id="2-1-MLE"><a href="#2-1-MLE" class="headerlink" title="2.1 MLE"></a>2.1 MLE</h4><p>最大似然估计, 英文为 Maximum Likelihood Estimation, 简写为MLE, 也叫极大似然估计, 是用来估计概率模型参数的一种方法. <strong>最大似然估计的思想是使得观测数据（样本）发生概率最大的参数就是最好的参数.</strong></p><p>对一个独立同分布的样本集来说, 总体的似然就是每个样本似然的乘积. 针对抛硬币的问题, 似然函数可写作:</p><script type="math/tex; mode=display">L(X,\theta)=\prod_{i=0}^nP(x_i|\theta)=\theta^6(1-\theta)^4</script><p>根据最大似然估计, 使 $L(X;\theta)$ 取得最大值的 $\theta$ 即为估计结果, 令 $L(X;\theta)’=0$ 可得 $\hat{\theta}=0.6$. 似然函数图如下:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201119021011171.png" alt="image-20201119021011171" style="zoom:50%;" /></p><p>由于总体的似然就是每个样本似然的乘积, 为了求解方便 (防止下溢), 我们通常会将似然函数转成对数似然函数, 然后再求解. 可以转成对数似然函数的主要原因是对数函数并不影响函数的凹凸性. 因此上式可变为:</p><script type="math/tex; mode=display">\ln L(X;\theta)=\ln\prod_{i=0}^nP(x_i|\theta)=\sum_{i=0}^n\ln P(x_i|\theta)=6\ln(\theta)+4\ln(1-\theta)</script><p>令 $(\ln L(X;\theta))’=0$, 可得 $\hat{\theta}=0.6$.</p><h4 id="2-2-MAP"><a href="#2-2-MAP" class="headerlink" title="2.2 MAP"></a>2.2 MAP</h4><p>最大后验概率估计, 英文为 Maximum A Posteriori Estimation, 简写为MAP. 回到抛硬币的问题, 最大似然估计认为使似然函数 $P(X|θ)$ 最大的参数 $θ$ 即为最好的 $θ$, 此时最大似然估计是将 $θ$ 看作固定的值, 只是其值未知. </p><p>最大后验概率分布认为 $θ$ 是一个随机变量, 即 $θ$ 具有某种概率分布, 称为先验分布, 求解时除了要考虑似然函数 $P(X|θ)$ 之外, 还要考虑 $θ$ 的先验分布 $P(θ)$, 因此其认为使 $P(X|θ)P(θ)$ 取最大值的 $θ$ 就是最好的 $θ$. 此时要最大化的函数变为 $P(X|θ)P(θ)$, 由于 $X$ 的后验分布 $P(X)$ 是固定的, 因此最大化函数可变为 $\frac{P(X|\theta)P(\theta)}{P(X)}$, 根据贝叶斯法则, 要最大化的函数 $\frac{P(X|\theta)P(\theta)}{P(X)}=P(\theta|X)$, 因此要最大化的函数是 $P(\theta|X)$, 而 $P(\theta|X)$ 是 $\theta$ 的后验概率. </p><p>最大后验概率估计可以看作是正则化的最大似然估计, 当然机器学习或深度学习中的正则项通常是加法, 而在最大后验概率估计中采用的是乘法, $P(\theta)$ 是正则项. 在最大似然估计中，由于认为 $θ$ 是固定的, 因为 $P(\theta)=1$.</p><p>最大后验概率估计的公式表示:</p><script type="math/tex; mode=display">\mathop{\arg\max}\limits_{\theta}P(\theta|X)=\mathop{\arg\max}\limits_{\theta}\frac{P(X|\theta)P(\theta)}{P(X)}\varpropto\mathop{\arg\max}\limits_{\theta}P(X|\theta)P(\theta)</script><p>在抛硬币的例子中, 通常认为 $θ=0.5$ 的可能性最大, 因此我们用均值为 $0.5$, 方差为 $0.1$ 的高斯分布来描述 $θ$ 的先验分布, 当然也可以使用其它的分布来描述 $θ$ 的先验分布. $θ$ 的先验分布为:</p><script type="math/tex; mode=display">\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(\theta-\mu)^2}{2\sigma^2}}=\frac{1}{10\sqrt{2\pi}}e^{-50(\theta-0.5)^2}</script><p>先验分布的函数图如下:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201119023627839.png" alt="image-20201119023627839" style="zoom: 33%;" /></p><p>在最大似然估计中，已知似然函数为 $P(X|θ)$, 因此:</p><script type="math/tex; mode=display">P(X|\theta)P(\theta)=\theta^6(1-\theta)^4\frac{1}{10\sqrt{2\pi}}e^{-50(\theta-0.5)^2}</script><p>转换为对数函数求导后可以得到: $\hat{\theta}=0.529$.</p><p>$P(X|\theta)P(\theta)$ 的函数图像如下, 基本符合 $\theta$ 的估计值 $\hat{\theta}$:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201119023953922.png" alt="image-20201119023953922" style="zoom: 33%;" /></p><p>如果我们用均值为 $0.6$, 方差为 $0.1$ 的高斯分布来描述 $\theta$ 的先验分布, 则 $\hat{\theta}=0.6$. 由此可见, 在最大后验概率估计中, $\theta$ 的估计值与 $\theta$ 的先验分布有很大的关系. 这也说明一个合理的先验概率假设是非常重要的, 如果先验分布假设错误, 则会导致估计的参数值偏离实际的参数值.</p><h4 id="2-3-Bayesian-Estimation"><a href="#2-3-Bayesian-Estimation" class="headerlink" title="2.3 Bayesian Estimation"></a>2.3 Bayesian Estimation</h4><p>贝叶斯估计是最大后验估计的进一步扩展, 贝叶斯估计同样假定 $\theta$ 是一个随机变量, 但贝叶斯估计并不是直接估计出 $θ$ 的某个特定值, 而是估计 $θ$ 的分布, 这是贝叶斯估计与最大后验概率估计不同的地方. 在贝叶斯估计中, 先验分布 $P(X)$ 是不可忽略的. 回到抛硬币的例子中, 在已知 $X$ 的情况下, 描述 $θ$ 的分布即描述 $P(θ|X)$, $P(θ|X)$ 是一种后验分布. </p><p><strong>如果后验分布的范围较窄, 则估计值的准确度相对较高. 反之, 如果后验分布的范围较广, 则估计值的准确度就较低.</strong></p><p>贝叶斯公式:</p><script type="math/tex; mode=display">P(\theta|X)=\frac{P(X|\theta)P(\theta)}{P(X)}</script><p>在连续型随机变量中, 由于 $P(X)=\int_{\theta}P(X|\theta)P(\theta)d\theta$, 因此贝叶斯公式变为:</p><script type="math/tex; mode=display">P(\theta|X)=\frac{P(X|\theta)P(\theta)}{\int_{\theta}P(X|\theta)P(\theta)d\theta}</script><p>从上面的公式中可以看出, 贝叶斯估计的求解非常复杂, 因此选择合适的先验分布就非常重要. 对于这个抛硬币的例子来说, 如果使用共轭先验分布, 就可以更好的解决这个问题. 二项分布参数的共轭先验是Beta分布, 由于 $θ$ 的似然函数服从二项分布, 因此在贝叶斯估计中, 假设 $\theta$ 的先验分布服从 $P(\theta)∼Beta(\alpha,\beta)$, Beta分布的概率密度公式为:</p><script type="math/tex; mode=display">f(x;\alpha,\beta)=\frac{1}{B(\alpha,\beta)}x^{\alpha-1}(1-x)^{\beta-1}</script><p>因此, 贝叶斯公式可写作:</p><script type="math/tex; mode=display">\begin{aligned} P(\theta|X)&=\frac {P(X|\theta)P(\theta)} {\int_{\Theta}P(X|\theta)P(\theta)d\theta} \\ &=\frac {\theta^6(1-\theta)^4 \frac {\theta^{\alpha-1}(1-\theta)^{\beta-1}} {B(\alpha,\beta)} } {\int_{\Theta}\theta^6(1-\theta)^4 \frac {\theta^{\alpha-1}(1-\theta)^{\beta-1}} {B(\alpha,\beta)}d\theta} \\&=\frac {\theta^{\alpha+6-1}(1-\theta)^{\beta+4-1}} {\int_{\Theta}\theta^{\alpha+6-1}(1-\theta)^{\beta+4-1}d\theta} \\ &=\frac {\theta^{\alpha+6-1}(1-\theta)^{\beta+4-1}} {B(\alpha+6-1,\beta+4-1)} \\ &=Beta(\theta|\alpha+6-1,\beta+4-1) \\&=Beta(\theta|\alpha+6,\beta+4)\end{aligned}</script><p>从上面的公式可以看出, $P(\theta|X) \sim Beta(\theta|\alpha+6,\beta+4)$. 其中 $B$ 函数, 也称 $Beta$ 函数, 是一个标准化常量, 用来使整个概率的积分为1. $Beta(θ|α+6,β+4)$ 就是贝叶斯估计的结果.</p><p>如果使用贝叶斯估计得到的 $θ$ 分布存在一个有限均值, 则可以用后验分布的期望作为 $θ$ 的估计值. 假设$α=3,β=3$, 在这种情况下, 先验分布会在 $0.5$ 处取得最大值, 则 $P(θ|X)∼Beta(θ|9,7)$, 曲线如下图:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201119030742066.png" alt="image-20201119030742066" style="zoom: 25%;" /></p><p>从上图可以看出, 在 $α=3,β=3$ 的情况下，$θ$ 的估计值应该在0.6附近. 根据Beta分布的数学期望公式 $E(\theta)=\frac{\alpha}{\alpha+\beta}$ 可得:</p><script type="math/tex; mode=display">\hat{\theta}=\int_{\Theta} \theta P(\theta|X)d\theta=E(\theta)=\frac {\alpha} {\alpha+\beta}=\frac {9} {9+7}=0.5625</script><p>贝叶斯估计的求解步骤：</p><ul><li>确定参数的似然函数</li><li>确定参数的先验分布，应是后验分布的共轭先验</li><li>确定参数的后验分布函数</li><li>根据贝叶斯公式求解参数的后验分布</li></ul><h3 id="3-Discriminative-amp-Generative-Model"><a href="#3-Discriminative-amp-Generative-Model" class="headerlink" title="3. Discriminative &amp; Generative Model"></a>3. Discriminative &amp; Generative Model</h3><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201119181844294.png" alt="image-20201119181844294" style="zoom: 33%;" /></p><p>我们先给出最直观的理解:</p><ul><li><p><strong>判别式模型</strong></p><p>要确定一个图片是猫还是狗, 用判别模型的方法就是根据数据集 $X$ 训练模, 然后把新的图片输入到模型中, 模型给出这个图片是每个类别的概率.</p></li><li><p><strong>生成式模型</strong></p><p>生成式模型是对原始数据集X和其标签 $Y$ 建模, 生成其<strong>联合概率</strong>. 然后将新的图片放入是否是猫的模型中, 看概率是多少. 然后将新的图片放入是否是狗的模型中, 看概率是多少.</p></li></ul><p><strong>数据要求: </strong>生成模型需要的数据量比较大, 能够较好地估计概率密度; 而判别模型对数据样本量的要求没有那么多.</p><h4 id="3-1-Discriminative-Model"><a href="#3-1-Discriminative-Model" class="headerlink" title="3.1 Discriminative Model"></a>3.1 Discriminative Model</h4><p>对于判别式模型来说求得 $P(Y|X)$, 对未见示例 $X$, 根据 $P(Y|X)$ 可以求得标记 $Y$, 即可以直接判别出来, 如上图的左边所示, 实际是就是直接得到了判别边界. </p><p>典型的判别模型包括: k近邻法、感知机、决策树、逻辑斯蒂回归模型、最大熵模型、支持向量机、boosting方法和条件随机场等. 判别模型利用正负例和分类标签, 关注在判别模型的边缘分布. </p><p><strong>判别方法的特点:</strong></p><ul><li>判别方法寻找不同类别之间的最优分类面, <strong>反映的是异类数据之间的差异</strong>.</li><li>判别方法利用了训练数据的类别标识信息, 直接学习的是条件概率 $P(Y|X)$, 直接面对预测, 往往学习的准确率更高.</li><li>由于直接学习条件概率 $P(Y|X)$, 可以对数据进行各种程度上的抽象, 定义特征并使用特征, 因此可以简化学习问题.</li><li>缺点是不能反映训练数据本身的特性.</li></ul><h4 id="3-2-Generative-Model"><a href="#3-2-Generative-Model" class="headerlink" title="3.2 Generative Model"></a>3.2 Generative Model</h4><p>生成式模型求得 $P(Y,X)$, 对于未见示例 $X$, 你要求出 $X$ 与不同标记之间的联合概率分布, 然后大的获胜, 如上图右边所示, 并没有什么边界存在, 对于未见示例 (红三角), 求两个联合概率分布 (有两个类), 比较一下, 取那个大的.</p><p>这样的方法之所以成为生成方法, 是因为<strong>模型表示了给定输入X产生输出Y的生成关系</strong>. 用于随机生成的观察值建模, 特别是在给定某些隐藏参数情况下. 典型的生成模型有: 朴素贝叶斯法、马尔科夫模型、高斯混合模型. 这种方法一般建立在统计学和Bayes理论的基础之上.</p><p><strong>生成方法的特点:</strong></p><ul><li>从统计的角度表示数据的分布情况, 能够<strong>反映同类数据本身的相似度.</strong></li><li>生成方法还原出联合概率分布, 而判别方法不能.</li><li>生成方法的学习收敛速度更快, 即当样本容量增加的时候, 学到的模型可以更快地收敛于真实模型.</li><li>当存在隐变量时, 我们仍可以用生成方法学习, 此时判别方法不能用.</li></ul><h4 id="3-3-Comparison"><a href="#3-3-Comparison" class="headerlink" title="3.3 Comparison"></a>3.3 Comparison</h4><p>假设有四个samples:</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">sample 1</th><th style="text-align:center">sample 2</th><th style="text-align:center">sample 3</th><th style="text-align:center">sample 4</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">y</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table></div><p>判别式模型的世界是这样的: $\sum P(y|x)=1$</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">y=0</th><th style="text-align:center">y=1</th></tr></thead><tbody><tr><td style="text-align:center">x=0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">x=1</td><td style="text-align:center">1/2</td><td style="text-align:center">1/2</td></tr></tbody></table></div><p>生成式模型的世界是这样的: $\sum P(x,y)=1$</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">y=0</th><th style="text-align:center">y=1</th></tr></thead><tbody><tr><td style="text-align:center">x=0</td><td style="text-align:center">1/2</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">x=1</td><td style="text-align:center">1/4</td><td style="text-align:center">1/4</td></tr></tbody></table></div><p><strong>注:</strong></p><p>生成模型对联合概率分布建模, 判别模型对条件概率分布建模. 生成模型有更高的泛化能力和普适性, 也就意味着更高的计算复杂度, 他能帮助发现数据中新的特性. 判别模型相对来说直男一点, 你让他干点啥, 他就只干点啥. <strong>就信息量来讲, 很明显上图生成模型的信息量是高于下图判别模型的信息量的.</strong></p><h3 id="4-Bayes-Decision-Theory"><a href="#4-Bayes-Decision-Theory" class="headerlink" title="4. Bayes Decision Theory"></a>4. Bayes Decision Theory</h3><p>对于分类任务来说, 在所有相关概率都已知的理想情形下, 贝叶斯决策论考虑如何基于这些概率和误判损失来选择最优的类别标记. </p><p>假设有 $N$ 种可能的类别标记, 即 $\mathcal{Y}=\{c_1,c_2,…,c_N\}$, $\lambda_{ij}$ 是将一个真实标记为 $c_j$ 的样本误分类为 $c_i$ 所产生的损失, 基于后验概率 $P(c_i|x)$ 可获得将样本 $x$ 分类为 $c_i$ 所产生的<strong>期望损失 (expected loss)</strong>, 即所有损失的平均值</p><script type="math/tex; mode=display">R(c_i|x)=\sum_{j=1}^N\lambda_{ij}P(c_j|x)</script><p>上面这个式子是针对单个样本 $x$ 的, 而下面这个式子是针对整个数据集 $D$ 所有样本的期望, 即</p><script type="math/tex; mode=display">R(h)=\mathbb{E}_x[R(h(x)|x)]=\mathop{\sum}\limits_{x\in D}R(h(x)|x)P(x)</script><p>其中 $P(x)$ 为样本 $x$ 出现的概率, 且满足 $\sum_{x\in D}P(x)=1$; $h(x)$ 为<strong>判定标准</strong> $h:\mathcal{X}→\mathcal{Y}$ 对样本 $x$ 预测的类别标记; 则 $R(h)$ 表示判定标准 $h$ 的总体风险. 显然如果对每个样本 $x$, 我们能最小化期望损失, 那么总体风险也将最小化. 这就产生了<strong>贝叶斯判定准则 (Bayes Decision Rule)</strong>:</p><script type="math/tex; mode=display">h^*(x)=\arg\min R(c|x),c\in\mathcal{Y}</script><p>具体来说, 如目标是最小化分类错误率, 则误判损失 $\lambda_{ij}$ 可写为</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201011230726459.png" alt="image-20201011230726459" style="zoom: 67%;" /></p><p>此时单个样本的期望损失为</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201011230938247.png" alt="image-20201011230938247" style="zoom: 33%;" /></p><p>于是, 最小化分类错误率的贝叶斯最优分类器为</p><script type="math/tex; mode=display">h^*(x)=\arg\max P(c|x),c\in\mathcal{Y}</script><p>然而在现实任务中, 我们很难直接获得<strong>后验概率 $P(c|x)$.</strong> 从这个角度来看, 机器学习所要实现的是基于有限的训练样本集尽可能准确地估计后验概率 $P(c|x)$. 大体来说, 主要有两种策略:</p><ul><li><p><strong>判别式模型 (Discriminative Models)</strong></p><p>给定 $x$, 可通过直接建模 $P(c|x)$ 来预测 $c$.</p></li><li><p><strong>生成式模型 (Generative Models)</strong></p><p>先对联合概率分布 $P(x,c)$ 建模, 然后再由此获得 $P(c|x)$. 数学表达式即是</p><script type="math/tex; mode=display">P(c|x)=\frac{P(x,c)}{P(x)}</script><p>基于贝叶斯定理, $P(c|x)$ 可写为</p><script type="math/tex; mode=display">P(c|x)=\frac{P(x|c)P(c)}{P(x)}</script><p>其中, $P(c)$ 是类先验概率 (Prior), $P(x|c)$ 是样本 $x$ 相对于类标记 $c$ 的类条件概率 (class-conditional probability), 或称为似然 (likelihood). <strong>$P(x)$ 是用于归一化的证据因子, 对于给定样本 $x$, 证据因子 $P(x)$ 与类别标记无关.</strong> 因此, 估计 $P(c|x)$ 的问题就转换为如何基于训练数据 $D$ 来估计先验概率 $P(c)$ 和似然 $P(x|c)$.</p><blockquote><p>  对于似然 $P(x|c)$, 我们很难直接按频率去估计. 因为, 假设样本有 $d$ 个属性都是二值的, 则样本空间将有 $2^d$ 种可能的取值, 而在现实中, 这个值往往远大于训练样本数 $m$, 也就是说, 很多样本取值在训练集中根本没有出现. 因此直接使用频率来估计 $P(x|c)$ 是不可行的, 因为<strong>未被观测到与出现概率为零</strong>通常是不同的.</p></blockquote></li></ul><h3 id="5-Naive-Bayes"><a href="#5-Naive-Bayes" class="headerlink" title="5. Naive Bayes"></a>5. Naive Bayes</h3><p>基于贝叶斯公式来估计后验概率 $P(c|x)$ 的主要困难在于: 似然概率 $P(x|c)$ 是==所有属性上的联合概率==, 难以从有限的训练样本中直接估计而得.</p><p><strong>因此, 为了避开这个障碍, 朴素贝叶斯分类器 (Naive Bayes Classifier) 采用了属性条件独立性假设 (attribute conditional independence assumption): 对已知类别, 假设所有属性相互独立. 换句话说, 假设每个属性独立地对分类结果产生影响.</strong></p><blockquote><p>  我们知道, 此假设通常是不成立的, 不过这并不影响我们使用它, 因为它带来的计算简化效果远远超过了打破假设的理论损失.</p><p>  因此, 尽管有这些相当乐观的假设, 但朴素的贝叶斯分类器通常胜过更复杂的选择. 尽管各个类别的密度估计可能存在偏差, 但这种偏差可能不会对后验概率造成太大的损失, 尤其是在决策区域附近.</p></blockquote><p>基于此假设, 贝叶斯公式可以重写为</p><script type="math/tex; mode=display">P(c|x)=\frac{P(x|c)P(c)}{P(x)}=\frac{P(c)}{P(x)}\prod_{i=1}^dP(x_i|c)</script><p>由于对于同一样本而言 $P(x)$ 是相同的, 因此最优化贝叶斯分类器可以写为</p><script type="math/tex; mode=display">h_{ab}(x)=\arg\max P(c)\prod_{i=1}^dP(x_i|c),c\in\mathcal{Y}</script><p>这就是大名鼎鼎的朴素贝叶斯分类器的表达式. 很显然, 朴素贝叶斯分类器的训练过程分过两个大步骤:</p><ol><li><p>基于训练集 $D$ 来估计类先验概率 $P(c)$</p><script type="math/tex; mode=display">P(c)=\frac{|D_c|}{D}</script></li><li><p>并为每个属性估计条件概率 $P(x_i|c)$</p><ul><li><p>对于离散属性我们可以按以下方式计算</p><script type="math/tex; mode=display">P(x_i|c)=\frac{|D_{c,x_i}|}{|D_c|}</script></li><li><p>对于连续属性我们可以考虑概率密度函数, 假定 $p(x_i|c)\sim\mathcal{N}(\mu_{c,i},\sigma_{c,i}^2)$, 则有</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201012175502306.png" alt="image-20201012175502306"></p></li></ul></li></ol><p><strong>我们用下面这个数据集来训练一个分类器, 并对测试例进行分类</strong></p><p>训练集:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201012175931217.png" alt="image-20201012175931217"></p><p>测试例:</p><div class="table-container"><table><thead><tr><th>编号</th><th style="text-align:center">色泽</th><th style="text-align:center">根蒂</th><th style="text-align:center">敲声</th><th style="text-align:center">纹理</th><th style="text-align:center">脐部</th><th style="text-align:center">触感</th><th style="text-align:center">密度</th><th style="text-align:center">含糖率</th><th style="text-align:center">好瓜</th></tr></thead><tbody><tr><td>测 1</td><td style="text-align:center">青绿</td><td style="text-align:center">蜷缩</td><td style="text-align:center">浊响</td><td style="text-align:center">清晰</td><td style="text-align:center">凹陷</td><td style="text-align:center">硬滑</td><td style="text-align:center">0.697</td><td style="text-align:center">0.460</td><td style="text-align:center">?</td></tr></tbody></table></div><p><strong>Step 1: 估计类先验概率 $P(c)$, 显然有</strong></p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201012194712945.png" alt="image-20201012194712945" style="zoom:67%;" /></p><p><strong>Step 2: 为每个属性估计条件概率</strong> $P(x_i|c)$</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201012200231262.png" alt="image-20201012200231262" style="zoom:67%;" /></p><p><strong>Step 3: 计算结果</strong></p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201012200431486.png" alt="image-20201012200431486" style="zoom:67%;" /></p><p>因此, 朴素贝叶斯分类器将测试样本判别为好瓜.</p><p>但需要注意, 有些时候我们可能会出现条件概率为零的情况. 打个比方, 对于上述数据集</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201012201001332.png" alt="image-20201012201001332" style="zoom:67%;" /></p><p>这会导致连乘式计算出的概率值为零 (虽然实践中我们通常使用取对数的方式来将连乘转换为连加以避免数值下溢), 进而导致分类器失效. 为了避免这种情况的出现, <strong>我们在估计概率值的时候通常要进行平滑 (smoothing)</strong>. </p><p>平滑有很多种方法, 我们在这里主要介绍<strong>拉普拉斯修正 (Laplace Correction)</strong>. 如果你想了其他修正方法, 可以参考我的 NLP 笔记. </p><blockquote><p>  <strong>拉普拉斯平滑</strong></p><p>  令 $N$ 表示训练集 $D$ 中可能的类别, $N_i$ 表示第 $i$ 个属性可能的取值数, 则修正后的<strong>类先验概率</strong>和<strong>每个属性估计条件概率</strong>可表示为</p><script type="math/tex; mode=display">\hat{P}(c)=\frac{|D_c|+1}{|D|+N}</script><script type="math/tex; mode=display">\hat{P}(x_i|c)=\frac{|D_{c,x_i}|+1}{|D_c|+N_i}</script></blockquote><h3 id="6-Bayes-Network"><a href="#6-Bayes-Network" class="headerlink" title="6. Bayes Network"></a>6. Bayes Network</h3><blockquote><p>  我们首先要介绍一下什么是概率图模型.</p><p>  概率图模型是用图来表示变量概率依赖关系的理论, 结合概率论与图论的知识, 利用图来表示与模型有关的变量的<strong>联合概率分布.</strong> </p><p>  如果用一个词来形容概率图模型（Probabilistic Graphical Model）的话, 那就是“优雅”. 对于一个实际问题, 我们希望能够挖掘隐含在数据中的知识. 概率图模型构建了这样一幅图, 用观测结点表示观测到的数据, 用隐含结点表示潜在的知识, 用边来描述知识与数据的相互关系, <strong>最后基于这样的关系图获得一个概率分布</strong>, 非常“优雅”地解决了问题.</p><p>  概率图中的节点分为隐含节点和观测节点, 边分为有向边和无向边. 从概率论的角度, 节点对应于随机变量, 边对应于随机变量的依赖或相关关系, 其中<strong>有向边表示单向的依赖, 无向边表示相互依赖关系</strong>.</p><p>  概率图模型分为<strong>贝叶斯网络（Bayesian Network）和马尔可夫网络（Markov Network）</strong>两大类. 贝叶斯网络可以用一个<strong>有向图</strong>结构表示, 马尔可夫网络可以表示成一个<strong>无向图</strong>的网络结构. 更详细地说, 概率图模型包括了朴素贝叶斯模型、最大熵模型、隐马尔可夫模型、条件随机场、主题模型等, 在机器学习的诸多场景中都有着广泛的应用.</p></blockquote><h4 id="6-1-Introduction"><a href="#6-1-Introduction" class="headerlink" title="6.1 Introduction"></a>6.1 Introduction</h4><blockquote><p>  对于任意的随机变量, 其联合概率可由各自的局部条件概率分布相乘而得出:</p><script type="math/tex; mode=display">P(x_1,x_2,...,x_k)=P(x_k|x_1,...,x_{k-1})...P(x_2|x_1)P(x_1)</script></blockquote><p>贝叶斯网络 (Bayesian network), 又称信念网络 (Belief Network), 或有向无环图模型 (Directed Acyclic Graphical Model), 是一种概率图模型, 于1985年由Judea Pearl首先提出. 它是一种模拟人类推理过程中因果关系的不确定性处理模型, 其网络拓朴结构是一个有向无环图 (DAG).</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201119204457264.png" alt="image-20201119204457264" style="zoom: 33%;" /></p><p>贝叶斯网络的有向无环图中的节点表示随机变量 ${X_1,X_2,…,X_n}$. 它们可以是可观察到的变量, 或隐变量, 未知参数等. 认为有因果关系（或非条件独立）的变量或命题则用箭头来连接. 若两个节点间以一个单箭头连接在一起, 表示其中一个节点是“因(parents)”，另一个是“果(children)”, 两节点就会产生一个条件概率值.</p><p>简言之, 把某个研究系统中涉及的随机变量, 根据是否条件独立绘制在一个有向图中, 就形成了贝叶斯网络. 其主要用来描述随机变量之间的条件依赖, 用圈表示随机变量 (random variables), 用箭头表示条件依赖(conditional dependencies).</p><p>对于任何贝叶斯网络, 其所代表的<strong>联合概率</strong>可以表示为:</p><script type="math/tex; mode=display">P(\bold{x})=\prod_{i=1}^KP(x_i|pa_i)</script><p>因此上图的联合概率可以表示为:</p><script type="math/tex; mode=display">P(x_1)P(x_2)P(x_3)P(x_4|x_2,x_3)P(x_5|x_1,x_3)P(x_6|x_4)P(x_7|x_4,x_5)</script><p>我们可以发现, 这和我们最开始所说的联合概率可由各自的局部条件概率分布相乘而得出的结果不一样, 这是因为 <strong>A graph not fully connected contains independency assumptions</strong>. 上式是化简后的结果.</p><p>我们再看一下 <strong>A graph fully connected</strong> 的例子: </p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201119205135016.png" alt="image-20201119205135016" style="zoom:33%;" /></p><p>因为 a 导致 b, a和b导致c, 所以有:</p><script type="math/tex; mode=display">P(a,b,c)=P(c|a,b)P(b|a)P(a)</script><p><strong>所以, Fully connected graphs contain no independcy assumption.</strong></p><h4 id="6-2-D-Separation"><a href="#6-2-D-Separation" class="headerlink" title="6.2 D-Separation"></a>6.2 D-Separation</h4><p>Graphical models allow to directly verify independency assumptions through the d-separation criterion.</p><ol><li><p><strong>Head-to-Head</strong></p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201119210625322.png" alt="image-20201119210625322" style="zoom:33%;" /></p><ul><li><p>Joint distribution:</p><p>$P(a,b,c)=P(c|a,b)P(a)P(b)$</p></li><li><p>a and b are <strong>conditionally independent:</strong></p><p>$P(a,b)=\mathop{\sum}\limits_{c}P(c|a,b)P(a)P(b)=P(a)P(b)$</p></li><li><p>a and b are <strong>not conditionally independent given</strong> c:</p><p>$P(a,b|c)=\frac{P(c|a,b)P(a)P(b)}{P(c)}\ne P(a|c)P(b|c)$</p></li></ul><p>所以在 $c$ 未知的条件下, a和b被阻断(blocked), 是独立的, 称之为head-to-head条件独立.</p></li><li><p><strong>Tail-to-Tail</strong></p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201119210852804.png" alt="image-20201119210852804" style="zoom:33%;" /></p><ul><li><p>Joint distribution:</p><p>$P(a,b,c)=P(a|c)P(b|c)P(c)$</p></li><li><p>a and b are <strong>not conditionally independent:</strong></p><p>$P(a,b)=\mathop{\sum}\limits_{c}P(a|c)P(b|c)P(c)\ne P(a)P(b)$</p></li><li><p>a and b are <strong>conditionally independent given c:</strong></p><p>$P(a,b|c)=\frac{P(a,b,c)}{P(c)}=P(a|c)P(b|c)$</p></li></ul><p>即在 $c$ 给定的条件下, a和b被阻断(blocked), 是独立的, 称之为tail-to-tail条件独立.</p></li><li><p><strong>Head-to-Tail</strong></p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201119211454789.png" alt="image-20201119211454789" style="zoom:33%;" /></p><ul><li><p>Joint distribution:</p><p>$P(a,b,c)=P(a)P(c|a)P(b|c)=P(c)P(a|c)P(b|c)$</p></li><li><p>a and b are not <strong>conditionally independent:</strong></p><p>$P(a,b)=P(a)\mathop{\sum}\limits_{c}P(b|c)P(c|a)\ne P(a)P(b)$</p></li><li><p>a and b are <strong>conditionally independent given c:</strong></p><p>$P(a,b|c)=\frac{P(b|c)P(a|c)P(c)}{P(c)}=P(b|c)P(a|c)$</p></li></ul><p>即在 $c$ 给定的条件下, a和b被阻断(blocked), 是独立的, 称之为head-to-tail条件独立.</p><p><strong>插一句</strong>, 这个head-to-tail其实就是一个链式网络, 如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201119212033724.png" alt="image-20201119212033724" style="zoom:33%;" /></p><p>在 $x_i$ 给定的条件下, $x_{i+1}$ 的分布和 $x_1,x_2,…,x_{i-1}$ 的分布条件独立. 即: $x_{i+1}$ 的分布状态只和 $x_i$ 有关, 和其他变量条件独立, 这种顺次演变的随机过程, 就被称为<strong>马尔可夫链 (Markov Chain)</strong>, 且有:</p><script type="math/tex; mode=display">P(X_{n+1}=x|X_0,X_1,X_2,...,X_n)=P(X_{n+1}=x|X_n)</script></li></ol><p>接着, 将上述结点推广到结点集, 则是: 对于任意的结点集 $A,B,C$, 考察所有通过 $A$ 中任意结点到 $B$ 中任意结点的路径, 若要求 $A,B$ 条件独立, 则需要所有的路径都被阻断(blocked), 即满足下列两个前提之一:</p><ul><li>A和B的“head-to-tail型”和“tail-to-tail型”路径都通过C;</li><li>和B的“head-to-head型”路径不通过C以及C的子孙;</li></ul><p>最后, 举例说明上述D-Separation的3种情况, 则是如下图所示:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/8758ff50d_1440w.jpg" alt="8758ff50d_1440w" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何以管理员模式打开 Jupyter Notebook</title>
      <link href="2020/11/14/%E5%A6%82%E4%BD%95%E4%BB%A5%E7%AE%A1%E7%90%86%E5%91%98%E6%A8%A1%E5%BC%8F%E6%89%93%E5%BC%80-Jupyter-Notebook/"/>
      <url>2020/11/14/%E5%A6%82%E4%BD%95%E4%BB%A5%E7%AE%A1%E7%90%86%E5%91%98%E6%A8%A1%E5%BC%8F%E6%89%93%E5%BC%80-Jupyter-Notebook/</url>
      
        <content type="html"><![CDATA[<p>我在使用 StanfordCoreNLP 的时候遇到了需要管理员权限才能成功运行程序的问题. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> stanfordcorenlp <span class="keyword">import</span> StanfordCoreNLP</span><br><span class="line">core_nlp = StanfordCoreNLP(<span class="string">&#x27;library/english&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------------------------------------------</span><br><span class="line">PermissionError                           Traceback (most recent call last)</span><br><span class="line">/Applications/anaconda3/lib/python3.7/site-packages/psutil/_psosx.py in wrapper(self, *args, **kwargs)</span><br><span class="line">    333         try:</span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> 334             <span class="built_in">return</span> fun(self, *args, **kwargs)</span></span><br><span class="line">    335         except ProcessLookupError:</span><br><span class="line"></span><br><span class="line">/Applications/anaconda3/lib/python3.7/site-packages/psutil/_psosx.py in connections(self, kind)</span><br><span class="line">    520         with catch_zombie(self):</span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> 521             rawlist = cext.proc_connections(self.pid, families, types)</span></span><br><span class="line">    522         ret = []</span><br><span class="line"></span><br><span class="line">PermissionError: [Errno 1] Operation not permitted (originated from proc_pidinfo())</span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">AccessDenied                              Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-8-77a67380f158&gt; in &lt;module&gt;</span><br><span class="line">      1 from stanfordcorenlp import StanfordCoreNLP</span><br><span class="line">      2 </span><br><span class="line"><span class="meta">----&gt;</span><span class="bash"> 3 core_nlp = StanfordCoreNLP(<span class="string">&#x27;library/english&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line">/Applications/anaconda3/lib/python3.7/site-packages/stanfordcorenlp/corenlp.py in __init__(self, path_or_host, port, memory, lang, timeout, quiet, logging_level)</span><br><span class="line">     77             if self.port is None:</span><br><span class="line">     78                 for port_candidate in range(9000, 65535):</span><br><span class="line"><span class="meta">---&gt;</span><span class="bash"> 79                     <span class="keyword">if</span> port_candidate not <span class="keyword">in</span> [conn.laddr[1] <span class="keyword">for</span> conn <span class="keyword">in</span> psutil.net_connections()]:</span></span><br><span class="line">     80                         self.port = port_candidate</span><br><span class="line">     81                         break</span><br><span class="line"></span><br><span class="line">/Applications/anaconda3/lib/python3.7/site-packages/psutil/__init__.py in net_connections(kind)</span><br><span class="line">   2153     On macOS this function requires root privileges.</span><br><span class="line">   2154     &quot;&quot;&quot;</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> 2155     <span class="built_in">return</span> _psplatform.net_connections(kind)</span></span><br><span class="line">   2156 </span><br><span class="line">   2157 </span><br><span class="line"></span><br><span class="line">/Applications/anaconda3/lib/python3.7/site-packages/psutil/_psosx.py in net_connections(kind)</span><br><span class="line">    245     for pid in pids():</span><br><span class="line">    246         try:</span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> 247             cons = Process(pid).connections(kind)</span></span><br><span class="line">    248         except NoSuchProcess:</span><br><span class="line">    249             continue</span><br><span class="line"></span><br><span class="line">/Applications/anaconda3/lib/python3.7/site-packages/psutil/_psosx.py in wrapper(self, *args, **kwargs)</span><br><span class="line">    336             raise NoSuchProcess(self.pid, self._name)</span><br><span class="line">    337         except PermissionError:</span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> 338             raise AccessDenied(self.pid, self._name)</span></span><br><span class="line">    339         except cext.ZombieProcessError:</span><br><span class="line">    340             raise ZombieProcess(self.pid, self._name, self._ppid)</span><br><span class="line"></span><br><span class="line">AccessDenied: psutil.AccessDenied (pid=14252)</span><br></pre></td></tr></table></figure><p><strong>解决方案如下:</strong></p><p><strong>Step 1:</strong> 生成一个 notebook 的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure><p><strong>Step 2: 修改配置文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.jupyter/jupyter_notebook_config.py</span><br></pre></td></tr></table></figure><p>通过 <code>vim</code> 打开配置文件并将文件中的 <code>#c.NotebookApp.allow_root = False</code> 去注释, 然后将 False 改为 True.</p><p><strong>Step 3: 在 terminal 以管理员方式运行 notebook</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python -m IPython notebook</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jupyter Notebook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>偏差和方差是什么东西?</title>
      <link href="2020/11/13/%E5%81%8F%E5%B7%AE%E5%92%8C%E6%96%B9%E5%B7%AE%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF/"/>
      <url>2020/11/13/%E5%81%8F%E5%B7%AE%E5%92%8C%E6%96%B9%E5%B7%AE%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Definition"><a href="#1-Definition" class="headerlink" title="1. Definition"></a>1. Definition</h3><p>在机器学习领域, 人们总是希望使自己的模型尽可能准确地描述数据背后的真实规律. 通俗所言的「准确」, 其实就是误差小. 在领域中, 排除人为失误, <strong>人们一般会遇到三种误差来源: 噪声(随机误差), 偏差和方差</strong>. 偏差和方差又与「欠拟合」及「过拟合」紧紧联系在一起.</p><p>对测试样本 $\boldsymbol{x}$, 令 $y_D$ 为 $\boldsymbol{x}$ 在数据集中的标记, $y$ 为 $\boldsymbol{x}$ 的真实标记, $f(\boldsymbol{x};D)$ 为训练集 $D$ 上学得模型 $f$ 在 $\boldsymbol{x}$ 上的预测输出. 以回归任务为例, 学习算法的期望预测为</p><script type="math/tex; mode=display">\overline{f}(x)=\mathbb{E}_D[f(\boldsymbol{x};D)]=\frac{1}{n}(f(\boldsymbol{x};D_1)+...+f(\boldsymbol{x};D_n))</script><blockquote><p>  假设:</p><p>  我们在这里简单认为 $\boldsymbol{x}$ 属于训练集 $D$. 另外, 设有 $n$ 个训练集 $D_1,…,D_n$, 这 $n$ 个训练集都是以独立同分布方式从样本空间采样而得, 并且恰好都包含测试样本 $\boldsymbol{x}$, 该样本在这 $n$ 个训练集是的标记分别为 $y_{D_1},…,y_{D_n}$.</p></blockquote><ul><li><p><strong>噪音 (随机误差)</strong></p><p>随机误差是数据本身的噪音带来的, 这种误差是不可避免的. 一般认为随机误差服从高斯分布, 记作 $\epsilon \sim\mathcal{N}(0,\sigma_{\epsilon})$. 噪声表达了当前任务在任何学习算法所能达到的期望泛化误差的下界, <strong>即刻画了学习问题本身的难度</strong>. 因此, 噪音可以记作</p><script type="math/tex; mode=display">\epsilon^2=\mathbb{E}_D[(y_D-y)^2]=\frac{1}{n}((y_{D_1}-y)^2+...+(y_{D_n}-y)^2)</script></li><li><p><strong>偏差 (Bias)</strong></p><p>描述的是通过学习拟合出来的结果之期望, 与真实规律之间的差距, <strong>即刻画了学习算法本身的拟合能力</strong>, 记作</p><script type="math/tex; mode=display">bias^2(\boldsymbol{x})=(\overline{f}(\boldsymbol{x})-y)^2</script></li><li><p><strong>方差 (Variance)</strong></p><p>描述的是通过学习拟合出来的结果自身的不稳定性, <strong>度量了同样大小的训练集的变动所导致的学习性能的变化, 即刻画了数据扰动所造成的影响</strong>, 记作</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}var(\boldsymbol{x})=&\mathbb{E}_D[(f(\boldsymbol{x};D)-\overline{f}(\boldsymbol{x}))^2] \\\end{aligned}\end{equation}</script></li></ul><p>通过简单的多项式展开合并, 可对算法的期望泛化误差进行分解:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201031002244108.png" alt="image-20201031002244108" style="zoom:50%;" /></p><p>于是</p><script type="math/tex; mode=display">E(f;D)=bias^2(\boldsymbol{x})+var(\boldsymbol{x})+\epsilon^2</script><p><strong>也就是说, 泛化误差可以分解为偏差, 方差与噪声之和.</strong></p><p>接下来我们看一下上诉公式是如何推导的.</p><p>==<strong>第 1 个等号:</strong>== 这是期望泛化误差的定义式, 类似地, 可直观地写为</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201031002447050.png" alt="image-20201031002447050" style="zoom:50%;" /></p><p>我们只能使用数据集中的标记 $y_D$ 评估学习器的泛化性能, 因为真实标记 $y$ 未知;</p><p>==<strong>第 2 个等号:</strong>== 常用的配项技巧, 减去 $\bar{f}(x)$ 再加上 $\bar{f}(x)$, 相当于没有任何变化;</p><p>==<strong>第 3 个等号:</strong>== 令 $a=f(x;D)-\bar{f}(x),b=\bar{f}(x)-y_D$, 则 $(a+b)^2=a^2+b^2+2ab$, 再结合数学期望的性质 $\mathbb{E}[X+Y]=\mathbb{E}[X]+\mathbb{E}[Y]$ 即可;</p><p>==<strong>第 4 个等号:</strong>== 只须证明第 3 个等号最后一项等于 0, 首先</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201031003700878.png" alt="image-20201031003700878" style="zoom:50%;" /></p><ul><li><p>对于第一项</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201031003938631.png" alt="image-20201031003938631" style="zoom:50%;" /></p><p>其中第 1 个等号就是乘开, 把式子的括号去掉; 第 2 个等号是因为期望 $\bar{f}(x)$ 为常量, 因此 $\mathbb{E}_D[·]$ 运算不起作用; 第三个等号使用了 $\bar{f}(x)$ 的定义;</p></li><li><p>对于第二项</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201031004828104.png" alt="image-20201031004828104" style="zoom:50%;" /></p><p>其中第 1 个等号就是乘开, 把式子的括号去掉; 第 2 个等号是根据数学期望的性质 $\mathbb{E}[X+Y]=\mathbb{E}[X]+\mathbb{E}[Y]$; 第 3 个等号中第 1 项 $\mathbb{E}_D[2f(\boldsymbol{x};D)y_D]=2\mathbb{E}_D[f(\boldsymbol{x};D)]\mathbb{E}_D[y_D]$ 是根据数学期望的性质 “当随机变量 $X$ 和 $Y$ 相互独立时, $\mathbb{E}[XY]=\mathbb{E}[X]\mathbb{E}[Y]$”; 第 3 个等号中第 2 项是因为期望 $\bar{f}(x)$ 为常量; 第 4 个等号使用了 $\bar{f}(x)$ 的定义;</p></li></ul><p>综上所述: 第 3 个等号最后一项等于 0, 代入即得第 4 个等号;</p><p>==<strong>第 5 个等号:</strong>== 类似于第 2 个等号, 对第 2 项使用了配项技巧;</p><p>==<strong>第 6 个等号:</strong>== 类似于第 3 个等号, 对第 2 项使用了期望性质 $\mathbb{E}[X+Y]=\mathbb{E}[X]+\mathbb{E}[Y]$;</p><p>==<strong>第 7 个等号:</strong>== 只须证明第 6 个等号最后一项等于 0; 由于 $\bar{f}(x)$ 和 $y$ 均为常量, 因此</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201031011732778.png" alt="image-20201031011732778" style="zoom:50%;" /></p><p>第 3 个等号使用了等式 $\mathbb{E}_D[y_D]=y$, 这是由于我们假定噪声期望为零, 即 $\mathbb{E}_D[y_D-y]=\mathbb{E}_D[y_D]-y=0$, 其中 $y$ 为 $\boldsymbol{x}$ 的真实标记, 是一个常量;</p><p><strong>偏差-方差分解说明:</strong> 泛化性能时由学习算法的能力, 数据充分性以及学习任务本身的难度所共同决定的. 给定学习任务, 为了取得好的泛化性能, 则需偏差较小, 即能够充分拟合数据, 并且使方差较小, 即使数据扰动产生的影响小.</p><h3 id="2-Graphic-Explanation"><a href="#2-Graphic-Explanation" class="headerlink" title="2. Graphic Explanation"></a>2. Graphic Explanation</h3><p><strong>我们看看如何用图形来表示 Bias 和 Variance:</strong> </p><p>下图将机器学习任务描述为一个「打靶」的活动: 根据相同的算法, 不同的数据集训练出的模型, <strong>对同一个样本进行预测</strong>, 每个模型作出的预测相当于是一次打靶. 我们假设红色靶心区域是真正的值, 蓝色点为不同训练集所训练出的模型对样本的预测值, 当我们从靶心逐渐向外移动时, 预测效果逐渐变差.</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201031021500195.png" alt="image-20201031021500195" style="zoom:50%;" /></p><p>左上角的示例是理想状况: Bias 和 Variance 都非常小, 如果有无穷的训练数据, 以及完美的模型算法, 我们是有办法达成这样的情况的. 然而, 现实中的工程问题, 通常数据量都是有限的, 模型也不是完美的. 因此, 这只是一个理想状况.</p><p>右上角的示例表示: Bias 小, Variance 大. 靶纸上的落点都集中分布在红心周围, 它们的期望落在红心之内, 因此偏差较小. 另外一方面, 落点虽然集中在红心周围, 但是比较分散, 这是方差大的表现.</p><p>左下角的示例表示: Bias 大, Variance 小. 显而易见, 靶纸上的落点非常集中, 说明方差小. 但是落点集中的位置距离红心很远, 这是偏差大的体现.</p><p>右下角的示例则是最糟糕的情况: Bias 和 Variance 都非常大. 这是我们最不希望看到的结果.</p><h3 id="3-Example"><a href="#3-Example" class="headerlink" title="3. Example"></a>3. Example</h3><p>现在我们做一个模拟实验, 用于说明至此介绍的内容. 首先, 我们生成了两组 array, 分别作为训练集和验证集. 这里 $x$ 和 $y$ 是线性相关的, 而在 $y$ 上加入了随机噪声, 用以模拟真实问题的情况.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">real_function = <span class="keyword">lambda</span> x: x + x ** <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line">x_train = np.linspace(<span class="number">0</span>,<span class="number">15</span>,<span class="number">100</span>)</span><br><span class="line">y_train = np.array([item <span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">map</span>(real_function,x_train)])</span><br><span class="line">y_noise = <span class="number">2</span> * np.random.normal(size=y_train.size)</span><br><span class="line">y_train += y_noise</span><br><span class="line"></span><br><span class="line">x_valid = np.linspace(<span class="number">0</span>,<span class="number">15</span>,<span class="number">50</span>)</span><br><span class="line">y_valid = np.array([item <span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">map</span>(real_function,x_valid)])</span><br><span class="line">y_noise = <span class="number">2</span> * np.random.normal(size=y_valid.size)</span><br><span class="line">y_valid += y_noise</span><br></pre></td></tr></table></figure><p>现在, 我们选用最小平方误差作为损失函数, 尝试用多项式函数去拟合这些数据.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prop = np.polyfit(x_train,y_train,<span class="number">1</span>)</span><br><span class="line">prop_ = np.poly1d(prop)</span><br><span class="line">overf = np.polyfit(x_train,y_train,<span class="number">15</span>)</span><br><span class="line">overf_ = np.poly1d(overf)</span><br></pre></td></tr></table></figure><p>这里, 对于 <code>prop</code>, 我们采用了一阶的多项式函数 (线性模型) 去拟合数据; 对于 <code>overf</code>, 我们采用了 15 阶的多项式函数 (多项式模型) 去拟合数据. 如此, 我们可以把拟合效果绘制成图.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">_ = plt.figure(figsize=(<span class="number">14</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">prop_err = np.mean((y_train - np.polyval(prop,x_train)) ** <span class="number">2</span>)</span><br><span class="line">overf_err = np.mean((y_train - np.polyval(overf,x_train)) ** <span class="number">2</span>)</span><br><span class="line">xp = np.linspace(-<span class="number">2</span>,<span class="number">17</span>,<span class="number">200</span>)</span><br><span class="line">plt.plot(x_train,y_train,<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">plt.plot(xp,prop_(xp),<span class="string">&#x27;-&#x27;</span>,label = <span class="string">&#x27;proper, err: %.3f&#x27;</span>%(prop_err))</span><br><span class="line">plt.plot(xp,overf_(xp),<span class="string">&#x27;--&#x27;</span>,label = <span class="string">&#x27;overfit, err: %.3f&#x27;</span>%(overf_err))</span><br><span class="line">plt.ylim(-<span class="number">5</span>,<span class="number">20</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.title(<span class="string">&#x27;train set&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">prop_err = np.mean((y_valid - np.polyval(prop,x_valid)) ** <span class="number">2</span>)</span><br><span class="line">overf_err = np.mean((y_valid - np.polyval(overf,x_valid)) ** <span class="number">2</span>)</span><br><span class="line">xp = np.linspace(-<span class="number">2</span>,<span class="number">17</span>,<span class="number">200</span>)</span><br><span class="line">plt.plot(x_valid,y_valid,<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">plt.plot(xp,prop_(xp),<span class="string">&#x27;-&#x27;</span>,label = <span class="string">&#x27;proper, err: %.3f&#x27;</span>%(prop_err))</span><br><span class="line">plt.plot(xp,overf_(xp),<span class="string">&#x27;--&#x27;</span>,label = <span class="string">&#x27;overfit, err: %.3f&#x27;</span>%(overf_err))</span><br><span class="line">plt.ylim(-<span class="number">5</span>,<span class="number">20</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.title(<span class="string">&#x27;validation set&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201031040719512.png" alt="image-20201031040719512" style="zoom:67%;" /></p><p>从训练集上的结果来说, 线性模型的误差要明显高于多项式模型. 站在人类观察者的角度来说, 这似乎是显而易见的: 数据是围绕一个近似线性的函数附近抖动的, 那么用简单的线性模型, 自然就无法准确地拟合数据; 但是, 高阶的多项式函数可以进行各种「扭曲」, 以便将训练集的数据拟合得更好.</p><blockquote><p>  这种情况下, 我们说线性模型在训练集上欠拟合 (underfitting), 而且它的偏差 (bias) 要高于多项式模型的偏差.</p></blockquote><p>但这并不意味着线性模型在这个问题里要弱于多项式模型. 我们看到, 在验证集上, 线性模型的误差要小于多项式模型的误差. 并且线性模型在训练集合验证集上的误差相对接近, 而多项式模型在两个数据集上的误差差距就很大了.</p><blockquote><p>  这种情况下, 我们说多项式模型在训练集上过拟合 (overfitting), 并且它的方差 (variance) 要高于线性模型.</p></blockquote><p>此外, 因为线性模型在两个集合上的误差较为接近, 因此我们说线性模型在训练过程中未见的数据上, 泛化能力更好. 因为, 在真实情况下, 我们都需要使用有限的训练集去拟合模型, 而后工作在无限的真实样本中, 而这些真实样本对于模型的训练过程都是不可见的. 所以, 模型的泛化能力, 是非常重要的指标.</p><h3 id="4-How-to-Balance"><a href="#4-How-to-Balance" class="headerlink" title="4. How to Balance"></a>4. How to Balance</h3><p>在实际应用中, 我们做模型选择的一般方法是:</p><ul><li>选定一个算法;</li><li>调整算法的超参数;</li><li>以某种指标选择最合适的超参数组合;</li></ul><p>也就是说, 在整个过程中, 我们固定训练样本, 改变模型的描述能力 (模型复杂度). 不难理解, 随着模型复杂度的增加, 其描述能力也就会增加; 此时, 模型在验证集上的表现, 偏差会倾向于减小, 而方差会倾向于增大. 而在反方向, 随着模型复杂度的降低, 其描述能力也就会降低; 此时, 模型在验证集上的表现, 偏差会倾向于增大, 而方差会倾向于减小.</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201031045823921.png" alt="image-20201031045823921" style="zoom:67%;" /></p><p>图中的最优位置, 实际上是 total error 曲线的拐点. 我们知道, 连续函数的拐点意味着此处一阶导数的值为 0. 考虑到 total error 是偏差与方差的和, 所以在拐点处, 我们有:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201031050100068.png" alt="image-20201031050100068"></p><p>因此, 若模型的复杂度大于平衡点, 则模型的方差会偏高, 模型倾向于<strong>过拟合</strong>; 若模型复杂度小于平衡点, 则模型的偏差会偏高, 模型倾向于<strong>欠拟合</strong>.</p><p>尽管有了上述数学表述, 但是在现实环境中, 有时候我们很难计算模型的偏差与方差. 因此, 我们需要通过外在表现, 判断模型的拟合状态: 是欠拟合还是过拟合.</p><p>同样地, 在有限的训练数据集中, 不断增加模型的复杂度, 意味着模型会尽可能多地降低在训练集上的误差. 因此, 在训练集上, 不断增加模型的复杂度, 训练集上的误差会一直下降. 因此, 我们可以绘制出这样的图像.</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201031050907824.png" alt="image-20201031050907824" style="zoom:50%;" /></p><p>因此:</p><ul><li>当模型处于欠拟合状态时, 训练集和验证集上的误差都很高;</li><li>当模型处于过拟合状态时, 训练集上误差很低, 而验证集上的误差非常高.</li></ul><p>因此, 我们可以开始处理欠拟合和过拟合:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201031051234568.png" alt="image-20201031051234568" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解 PAC 学习理论</title>
      <link href="2020/11/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-PAC-%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/"/>
      <url>2020/11/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-PAC-%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Entree"><a href="#1-Entree" class="headerlink" title="1. Entree"></a>1. Entree</h3><blockquote><p>  统计学中由<strong>总体集合</strong>和<strong>样本集合</strong>之分, 比如要统计国内本科生对机器学习的掌握情况, 此时全国所有的本科生就是总体集合, 但总体集合往往太大而不具有实际可操作性, 一般都是取总体集合的一部分, 也就是样本集合.</p><p>  在机器学习中, 样本空间对应总体集合, 而我们手头上的样例集 $D$ 对应样本集合, 样例集 $D$ 是从样本空间中采样而得, 分布 $\mathcal{D}$ 可理解为当从样本空间采样获得样例集 $D$ 时每个样本被采到的概率. 我们用 $\mathcal{D}(t)$ 表示样本空间第 $t$ 个样本被采到的概率.</p></blockquote><p>给定样例集 $D=\{(\boldsymbol{x}_1,y_1),(\boldsymbol{x}_2,y_2),…,(\boldsymbol{x}_m,y_m)\}$, 其中 $\boldsymbol{x}_i\in\mathcal{X},y_i\in\mathcal{Y}=\{-1,+1\}$. 我们假设 $\mathcal{X}$ 中的所有样本服从一个隐含未知的分布 $\mathcal{D}$, $D$ 中所有样本都是独立地从这个分布上采样而得, 即独立同分布样本.</p><p><strong>我们令 h 为 $\mathcal{X}$ 到 $\mathcal{Y}$ 的一个映射, 所以泛化误差可以表示为</strong></p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201102030553434.png" alt="image-20201102030553434" style="zoom:67%;" /></p><blockquote><p>  $P_{\boldsymbol{x}\sim D}(h(\boldsymbol{x})\neq y)$ 表示从样本空间中按分布 $\mathcal{D}$ 取一个样本 $\boldsymbol{x}$, 预测的类别标记不等于真实类表标记的概率, 即泛化误差.</p><p>  在接下来的分析中, 我们有时会省略 $\boldsymbol{x}\sim\mathcal{D}$. 同时, 我们会将 $E(h;\mathcal{D})$ 简记为 $E(h)$.</p><p>  泛化误差是 $h$ 在分布 $\mathcal{D}$ 上的期望误差.</p></blockquote><p><strong>$h$ 在 $D$ 上的经验误差为</strong></p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201102031429156.png" alt="image-20201102031429156" style="zoom:67%;" /></p><blockquote><p>  即是在训练集上的误差. 我们会将 $\hat{E}(h;D)$ 简写为 $\hat{E}(h)$.</p><p>  经验误差是 $h$ 在训练集 $D$ 上的平均误差.</p></blockquote><p><strong>若 $h$ 在数据集 $D$ 上的经验误差为 0, 则称 $h$ 与 $D$ 一致, 否则称其与 $D$ 不一致.</strong> 对任意两个映射 $h_1,h_2\in\mathcal{X}→\mathcal{Y}$, 可通过其<strong>不合(disagreement)</strong>来度量它们之间的差别:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201102032108896.png" alt="image-20201102032108896" style="zoom:67%;" /></p><p>几个常用的不等式:</p><ul><li><p><strong>Jensen 不等式</strong></p><p>对于任何凸函数 $f(x)$, 有</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201102032357029.png" alt="image-20201102032357029" style="zoom:67%;" /></p><p>我们简单介绍一下凸凹函数</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201102032450850.png" alt="image-20201102032450850" style="zoom:67%;" /></p><p>左为凹函数: 满足 $f(\frac{x_1+x_2}{2})\gt\frac{f(x_1)+f(x_2)}{2}$;</p><p>右为凸函数: 满足 $f(\frac{x_1+x_2}{2})\lt\frac{f(x_1)+f(x_2)}{2}$;</p></li><li><p><strong>Hoeffding 不等式</strong></p><p>若 $x_1,x_2,…,x_m$ 为 $m$ 个独立随机变量, 且满足 $0\le x_i\le1$, 则对任意 $\epsilon&gt;0$, 有</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201102033228049.png" alt="image-20201102033228049" style="zoom: 50%;" /></p><p>式中, $\frac{1}{m}\sum_{i=1}^mx_i$ 表示 $m$ 个独立随机变量各种的某次观测值的平均值. $\frac{1}{m}\sum_{i=1}^m\mathbb{E}(x_i)$ 表示 $m$ 个独立随机变量各自的期望的平均.</p><p>第一个不等式表示事件 $\frac{1}{m}\sum_{i=1}^mx_i-\frac{1}{m}\sum_{i=1}^m\mathbb{E}(x_i)\ge\epsilon$ 出现概率不大于 $e^{-2m\epsilon^2}$, 第二个等式同理. </p><p><strong>Hoeffding 不等式给出了随机变量和与其期望值偏差的概率上限.</strong></p></li><li><p><strong>McDiarmid 不等式</strong></p><p>若 $x_1,x_2,…,x_m$ 为 $m$ 个独立随机变量, 且对任意 $1\le i\le m$, 函数 $f$ 满足</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201102041115754.png" alt="image-20201102041115754" style="zoom:50%;" /></p><p>则对任意 $\epsilon&gt;0$, 有</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201102041155685.png" alt="image-20201102041155685" style="zoom:50%;" /></p><p>首先, 函数 $f$ 有 $m$ 个输入变量, 相比于 $f(x_1,…,x_m)$, $f(x_1,…,x_{i-1},x_i’,x_{i+1},…,x_m)$ 将第 $i$ 个输出由 $x_i$ 改为 $x_i’$. 所以 $|f(x_1,…,x_m)-f(x_1,…,x_{i-1},x_i’,x_{i+1},…,x_m)|$ 表示改变第 $i$ 个输入后函数值发生的变化量. <strong>sup</strong> 表示上确界 (supremum). </p><p>$x_1,x_2,…,x_m$ 为 $m$ 个独立随机变量, $f(x_1,…,x_m)$ 表示某次观测时对应的函数值. 每次观测中, 随机变量的取值不同则对应的函数值也不同.</p></li></ul><h3 id="2-PAC-Learning-Theory"><a href="#2-PAC-Learning-Theory" class="headerlink" title="2. PAC Learning Theory"></a>2. PAC Learning Theory</h3><blockquote><p>  我们希望用 PAC 理论在解释以下几个问题:</p><ul><li>什么样的问题能够被有效率的学习 (<em>What can be learned efficiently</em>)？</li><li>什么样的问题天生无法有效地被学习 (<em>What is inherently hard to learn</em>)？</li><li>成功的学习需要多少样本 (<em>How many examples are needed to learn successfully</em>)？</li><li>学习有没有一个综合性的模型指导 (<em>Is there a general model of learning</em>)？</li></ul></blockquote><p>计算学习理论中最基本的是 <strong>概率近似正确 (Probably Approximately Correct, 简称 PAC)</strong> 学习理论. 我们首先介绍两个基本概念:</p><ul><li><p><strong>概念类 (Concept Class)</strong></p><p>我们令 $c$ 表示概念 (concept), 这是从样本空间 $\mathcal{X}$ 到标记空间 $\mathcal{Y}$ 的映射, 它决定样例 $\boldsymbol{x}$ 的真实标记 $y$, 若对任何样例 $(\boldsymbol{x},y)$ 有 $c(\boldsymbol{x})=y$ 成立, 则称 c 为目标概念, 所有目标概念所构成的集合称为<strong>概念类 (concept class)</strong>, 用符号 $\mathcal{C}$ 表示.</p><blockquote><p>  即 c 表示能够准确预测所有样本(不仅限于训练集或测试集)的模型.</p></blockquote></li><li><p><strong>假设空间 (Hypothesis Space)</strong></p><p>给定学习算法 $\mathfrak{L}$, 它所考虑的所有可能概念的集合称为<strong>假设空间 (Hypothesis Space)</strong>, 用符号 $\mathcal{H}$ 表示. </p></li></ul><p>若目标概念 $c\in\mathcal{H}$, 则 $\mathcal{H}$ 中存在假设能将所有示例按与真实标记一致的方式完全分开, 我们称该问题对学习算法是 <strong>可分的 (Separable)</strong>, 也可以叫做<strong>一致的 (Consistent)</strong>. 或者按照我们课程上所说是 <strong>Realizable</strong> 的. </p><p>若目标概念 $c\notin\mathcal{H}$ or $c\in\mathcal{H}$, 则 $\mathcal{H}$ 中可能存在假设能将所有示例按与真实标记一致的方式完全分开, 我们则称该学习算法是 <strong>Agnostic</strong> 的.</p><p>若目标概念 $c\notin\mathcal{H}$, 则 $\mathcal{H}$ 中不存在假设能将所有示例按与真实标记一致的方式完全分开, 我们则称该学习算法是<strong>不一致的 (Inconsistent)</strong> 的.</p><blockquote><p>  为什么是 PAC, 或者说叫做概率近似正确?</p><p>  在机器学习中, 是给定训练集, 我们基于学习算法学得的模型所对应的假设 $h$ 应该尽可能接近目标概念 $c$. 这是因为机器学习过程往往受到很多因素的制约, 比如:</p><ul><li>训练集仅含有限数量的样例</li><li>从分布 $\mathcal{D}$ 采样得到 $D$ 的过程有一定的偶然性</li></ul></blockquote><p>现在我们来看看一些和 PAC 相关的定义, <strong>我们令 $\delta$ 表示置信度:</strong></p><p>==<strong>定义 1: PAC 辨识 (PAC Identify)</strong>==</p><p>对 $0&lt;\epsilon,\delta&lt;1$, 所有 $c\in\mathcal{C}$ 和分布 $\mathcal{D}$, 若存在学习算法 $\mathfrak{L}$, 其输出假设 $h\in\mathcal{H}$ 能满足</p><script type="math/tex; mode=display">P(E(h)\le\epsilon)\ge 1-\delta</script><p>我们则称学习算法 $\mathfrak{L}$ 能从假设空间 $\mathcal{H}$ 中 PAC 辨识概念类 $\mathcal{C}$.</p><blockquote><p>  <strong>换句通俗一点的话说就是:</strong> 输出假设 $h$ 的泛化误差 $E(h)\le\epsilon$ 的概率不小于 $1-\delta$.</p><p>  <strong>再换一句更通俗的话说就是:</strong> 学习算法 $\mathfrak{L}$ 能以较大概率 (至少$1-\delta$) 学得目标概念 $c$ 的近似 (误差最大为 $\epsilon$).</p></blockquote><p>==<strong>定义 1.1: PAC Criterion</strong>==</p><p><strong>接下来我们介绍一个在 10-601 上学到的类似概念</strong></p><p>The PAC criterion is that our learner produces a high accuracy learner with high probability:</p><script type="math/tex; mode=display">P(|E(h)-\hat{E}(h)|\le\epsilon)\ge 1-\delta</script><p>==<strong>定义 2: PAC 可学习 (PAC Learnable)</strong>==</p><p>令 $m$ 表示从分布 $\mathcal{D}$ 中独立同分布采样得到的样例数目, $0&lt;\epsilon,\delta&lt;1$, 对所有分布 $\mathcal{D}$, 若存在学习算法 $\mathfrak{L}$ 和多项式函数 $poly(·,·,·,·)$, 使得对于任何 $m\ge poly(\frac{1}{\epsilon},\frac{1}{\delta},size(\boldsymbol{x}),size(c))$, 学习算法 $\mathfrak{L}$, 能从假设空间 $\mathcal{H}$ 中 <strong>PAC 辨识</strong> 概念类 $\mathcal{C}$, 我们则称概念类 $\mathcal{C}$ 对假设空间 $\mathcal{H}$ 而言是 <strong>PAC 可学习的</strong>.</p><blockquote><p>  $\epsilon$: 误差</p><p>  $\delta$: 置信度</p><p>  $size(\boldsymbol{x})$: 数据本身的复杂度</p><p>  $size(c)$: 目标概念的复杂度</p></blockquote><p>因此, 我们知道, 一个概念类 $\mathcal{C}$ 被称为 PAC 可学习的则意味着: 算法在<strong>观测完一定数量</strong> (数量是 $\frac{1}{\epsilon},\frac{1}{\delta},size(\boldsymbol{x}),size(c)$ 的多项式函数) 的样本后, 所返回的假设, 在很大程度上 (至少为 $1-\delta$) 是近似正确的 (approximately right, 错误最多为 $\epsilon$).</p><p>==<strong>定义 3: PAC 学习算法 (PAC Learning Algorithm)</strong>==</p><p>若学习算法 $\mathfrak{L}$ 使概念类 $\mathcal{C}$ 为 PAC 可学习的, 且算法 $\mathfrak{L}$ 的运行时间也是多项式函数 $poly(\frac{1}{\epsilon},\frac{1}{\delta},size(\boldsymbol{x}),size(c))$, 我们则称概念类 $\mathcal{C}$ 是高效 PAC 可学习的, 且学习算法是 $\mathfrak{L}$ 是概念类 $\mathcal{C}$ 的 PAC 学习算法.</p><p>==<strong>定义 4: PAC 样本复杂度 (Sample Complexity)</strong>==</p><p>满足 PAC 学习算法 $\mathfrak{L}$ 所需的 $m\ge poly(\frac{1}{\epsilon},\frac{1}{\delta},size(\boldsymbol{x}),size(c))$ 中最小的 $m$, 称为学习算法 $\mathfrak{L}$ 的样本复杂度.</p><blockquote><p>  有了上述定义之后我们抛出来三个问题:</p><ol><li>研究某任务在什么样的条件下可学得较好的模型? <strong>定义 2</strong></li><li>某算法在什么样的条件下可进行有效的学习? <strong>定义 3</strong></li><li>需要多少训练样例才能获得较好的模型? <strong>定义 4</strong></li></ol></blockquote><p><strong>PAC 的要点:</strong></p><ol><li>PAC框架对分布 $\mathcal{D}$ 没有任何假设, 仅假设其存在.</li><li>训练样本和测试样本都是从同一分布中产生的.</li><li>PAC可学习是针对概念类谈的, 而非特定的那个目标概念.</li></ol><h3 id="3-Hypothesis-Space"><a href="#3-Hypothesis-Space" class="headerlink" title="3. Hypothesis Space"></a>3. Hypothesis Space</h3><p><strong>有限假设空间指 $\mathcal{H}$ 中包含的假设个数是有限的, 反之则为无限假设空间. 无限假设空间更为常见. 一般而言, $\mathcal{H}$ 越大, 其包含任意目标概念的可能性越大, 但从中找到某个具体目标概念的难度也越大.</strong></p><p>我们之前已经了解过了学习算法 <strong>consistent</strong>, <strong>inconsistent</strong>, <strong>agnostic</strong> 的概念. 我们现在想知道在不同的情形下我们要达成 PAC 可学习的样本数量. 在这里我们先给出结论:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201113230710434.png" alt="image-20201113230710434"></p><h4 id="3-1-Finite-and-Realizable"><a href="#3-1-Finite-and-Realizable" class="headerlink" title="3.1 Finite and Realizable"></a>3.1 Finite and Realizable</h4><p>Realizable(Consistent) 意味着目标概念 $c$ 属于假设空间 $\mathcal{H}$. 给定包含 $m$ 个样本的训练集 $D$, 如何找出满足误差参数的假设呢? </p><p><strong>记住! 我们要做的并不是找到 $c$, 而是要找到 $c$ 的近似! (即是训练误差为 0)</strong></p><p>==我们先估计泛化误差大于 $\epsilon$ 但在训练集仍然表现完美的假设出现的概率 (我们要令这个概率小于某个值, 因为我们其实是希望泛化误差小于 $\epsilon$ 但经验误差为零的假设出现的概率不小于 $1-\delta$)==. 假定 $h$ 的泛化误差大于 $\epsilon$, 对分布 $\mathcal{D}$ 上随机采样而得的任何样例 $(\boldsymbol{x},y)$, 有</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201102081759126.png" alt="image-20201102081759126" style="zoom:50%;" /></p><blockquote><p>  第 1 个等号是由于 $P(h(\boldsymbol{x}=y)+P(h(\boldsymbol{x}\neq y)=1$ 恒成立;</p><p>  第 2 个等号是由于 $P(h(\boldsymbol{x}\neq y)$ 就是泛化误差;</p><p>  第 3 个等号是由于我们之前假设泛化误差 $E(h)&gt;\epsilon$, 因此 $1-E(h)&lt;1-\epsilon$</p></blockquote><p>由于 $D$ 包含 $m$ 个从 $\mathcal{D}$ 独立同分布采样而得的样例, 因此, $h$ 与 $D$ 表现一致 (经验误差为 0) 的概率为</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201102082737181.png" alt="image-20201102082737181" style="zoom:50%;" /></p><blockquote><p>  由于 $D$ 包含的 $m$ 个样例是从 $\mathcal{D}$ 独立同分布采样而得, 因此</p><p>  <img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201102082949151.png" alt="image-20201102082949151" style="zoom:50%;" /></p><p>  其中, $\and$ 表示逻辑与, $\prod$ 表示连乘; 上述推导使用了概率论中的结论: 若事件 $A$ 和事件 $B$ 独立, 则 $P(AB)=P(A)P(B)$</p></blockquote><p>我们事先并不知道学习算法 $\mathfrak{L}$ 会输出 $\mathcal{H}$ 中的哪个假设, ==但我们仅需保证泛化误差大于 $\epsilon$, 且在训练集上表现完美的所有假设出现概率之和不大于 $\delta$ 即可==</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201102083913494.png" alt="image-20201102083913494" style="zoom:50%;" /></p><p>令上式不大于 $\delta$, 即</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201102085929352.png" alt="image-20201102085929352" style="zoom:50%;" /></p><p>可得 Sample Complexity</p><script type="math/tex; mode=display">m\ge\frac{1}{\epsilon}(\ln|\mathcal{H}|+\ln\frac{1}{\delta})</script><p>同时我们也能得到 Error Bound</p><script type="math/tex; mode=display">\epsilon\ge\frac{1}{m}(\ln|\mathcal{H}|+\ln\frac{1}{\delta})</script><p>因此用泛化边界的思路可以阐述为</p><script type="math/tex; mode=display">\mathop{error}_{true}(h)\le\epsilon=\frac{1}{m}(\ln|\mathcal{H}|+\ln\frac{1}{\delta})</script><p>==在这里, 经验误差 $\hat{E}(h)=0$, 做的事情是以 $1-\delta$ 概率学得目标概念的 $\epsilon$ 近似. 因此, 我们知道有限假设空间 $\mathcal{H}$ 都是 PAC 可学习的, 所需样例数目: $m\ge\frac{1}{\epsilon}(\ln|\mathcal{H}|+\ln\frac{1}{\delta})$.== </p><blockquote><p>  ① 概率 $P(h\in\mathcal{H}:E(h)&gt;\epsilon\and\hat{E}(h)=0)$ 表示: 对于假设空间 $\mathcal{H}$ 中<strong>某个</strong>特定假设 $h$, 事件 $E(h)&gt;\epsilon$ 和事件 $\hat{E}(h)=0$ 同时成立的概率.</p><p>  ② 根据之前的分析, 我们知道事件 $E(h)&gt;\epsilon$ 和事件 $\hat{E}(h)=0$ 同时成立的概率 $P(E(h)&gt;\epsilon\and\hat{E}(h)=0)&lt;(1-\epsilon)^m$.</p><p>  ③ 假设空间 $\mathcal{H}$ 中共包含 $|\mathcal{H}|$ 个假设, 概率之和如下:</p><script type="math/tex; mode=display">P(h\in\mathcal{H}:E(h)>\epsilon\and\hat{E}(h)=0)\le\sum_{i=1}^{|\mathcal{H}|}P(E(h_i)>\epsilon\and\hat{E}(h_i)=0)</script><p>  ④ 这 $|\mathcal{H}|$ 个假设各自满足事件 $E(h)&gt;\epsilon$ 和事件 $\hat{E}(h)=0$ 成立的概率均小于 $(1-\epsilon)^m$, 即对于 $\forall h_i\in\mathcal{H},P(E(h_i)&gt;\epsilon\and\hat{E}(h_i)=0)&lt;(1-\epsilon)^m$, 因此上式第一个小于号成立.</p><p>  ⑤ 因为 $|\mathcal{H}|$ 和 $m$ 均为正数, 因此第二个小于号实际要证明 $(1-\epsilon)&lt;e^{-\epsilon}$.</p><p>  ⑥ 令函数 $f(\epsilon)=1-\epsilon-e^{-\epsilon}$, 其中定义域为泛化误差 $\epsilon\in[0,1]$; 对函数求导得到 $f’(\epsilon)=-1+e^{-\epsilon}$, 在定义域内, 导数小于等于 0 恒成立, 因此 $f(\epsilon)$ 是单调递减函数, 最大值是 $f(0)=0$, 因此 $(1-\epsilon)\le e^{-\epsilon}$.</p></blockquote><h4 id="3-2-Finite-and-Agnostic"><a href="#3-2-Finite-and-Agnostic" class="headerlink" title="3.2 Finite and Agnostic"></a>3.2 Finite and Agnostic</h4><p>对较为困难的学习问题, 目标概念 $c$ 往往不存在于假设空间中. 假定对于任何 $h\in\mathcal{H}$, $\hat{E}(h)\ne0$, 也就是说, $\mathcal{H}$ 中任意一个假设都会在训练集出现或多或少的错误. </p><p>==<strong>引理 1</strong>==</p><p>若训练集 $D$ 包含 $m$ 个从分布 $\mathcal{D}$ 上独立同分布采样而得的样例, $0&lt;\epsilon&lt;1$, 则对任意 $h\in\mathcal{H}$, 有</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201102101530293.png" alt="image-20201102101530293" style="zoom:50%;" /></p><p>==<strong>推论 1</strong>==</p><p>若训练集 $D$ 包含 $m$ 个从分布 $\mathcal{D}$ 上独立同分布采样而得的样例, $0&lt;\epsilon&lt;1$, 则对任意 $h\in\mathcal{H}$, 下式以至少 $1-\delta$ 的概率成立</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201102101812423.png" alt="image-20201102101812423" style="zoom:50%;" /></p><blockquote><p>  上述推论表明, 样例数目 $m$ 较大时, $h$ 的经验误差是其泛化误差很好的近似.</p><p>  <strong>上述推论的推导过程:</strong></p><p>  我们令 $\delta=2e^{-2m\epsilon^2}$, 则 $\epsilon=\sqrt{\frac{\ln(\frac{2}{\delta})}{2m}}$. 因此, 引理 1 的第三式可以表示为 $P(|E(h)-\hat{E}(h)|\ge\epsilon)\le\delta$, 而这等价于 $P(|E(h)-\hat{E}(h)|\le\epsilon)\ge1-\delta$, 即 $|E(h)-\hat{E}(h)|\le\epsilon$ 成立的概率不小于 $1-\delta$.</p><p>  对于不等式 $|E(h)-\hat{E}(h)|\le\epsilon$, 其等价于</p><p>  <img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201102102527728.png" alt="image-20201102102527728" style="zoom:50%;" /></p><p>  最后将 $\delta=2e^{-2m\epsilon^2}$ 代入即可.</p></blockquote><p>==<strong>定理 1</strong>==</p><p>若 $\mathcal{H}$ 为有限假设空间, $0&lt;\delta&lt;1$, <strong>则对任意</strong> $h\in\mathcal{H}$, 有</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201102103229926.png" alt="image-20201102103229926" style="zoom:50%;" /></p><blockquote><p>  <strong>证明</strong> 令 $h_1,h_2,…,h_{|\mathcal{H}|}$ 表示假设空间 $\mathcal{H}$ 中的假设, 有</p><p>  <img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201102103638000.png" alt="image-20201102103638000" style="zoom:50%;" /></p><p>  由引理 1 第三式可得</p><p>  <img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201102103824620.png" alt="image-20201102103824620" style="zoom:50%;" /></p><p>  于是令 $\delta=2|\mathcal{H}|\exp(-2m\epsilon^2)$ 即可得定理 1.</p></blockquote><p>显然, 当 $c\notin \mathcal{H}$ 时, 学习算法无法学得目标概念 $c$ 的 $\epsilon$ 近似 (因为经验误差无法做到 0). <strong>但是根据上述分析, 我们知道当给定假设空间时, 其中必存在一个泛化误差最小的假设, 找出此假设的 $\epsilon$ 近似也不失为一个较好的目标.</strong> </p><h3 id="4-VC-Dimension"><a href="#4-VC-Dimension" class="headerlink" title="4. VC Dimension"></a>4. VC Dimension</h3><p><a href="https://tangshusen.me/2018/12/09/vc-dimension/">https://tangshusen.me/2018/12/09/vc-dimension/</a></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习基础-神经网络模型</title>
      <link href="2020/11/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
      <url>2020/11/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="1-M-P-Neuron-Model"><a href="#1-M-P-Neuron-Model" class="headerlink" title="1. M-P Neuron Model"></a>1. M-P Neuron Model</h3><p>神经网络是由具有适应性的简单单元组成的广泛并行互连的网络, 它的组织能够模拟生物神经系统对真实世界物体所作出的交互反应. </p><p>神经网络中最基本的成分是<strong>神经元 (Neuron)</strong>模型, 即上述定义中的”简单单元”. 在生物神经网络中, 每个神经元与其他神经元相连, 当它<strong>兴奋时</strong>, 就会向相连的神经元发送化学物质, 从而改变这些神经元内的电位; 如果某神经元的电位超过了一个<strong>阈值 (threshold)</strong>, 那么它就会被激活, 即兴奋起来, 向其他神经元发送化学物质. 下图就是上述描述很好的抽象表示 $→$ <strong>M-P 神经元模型</strong>. </p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029203407575.png" alt="image-20201029203407575" style="zoom:50%;" /></p><p>在这个模型中, 神经元接受到来自 $n$ 个其他神经元传递过来的输入信号, 这些输入信号通过带权重的连接进行传递, 神经元接收到的总输入值将与神经元的阈值进行比较, 然后通过<strong>激活函数 (activation function)</strong> 处理以产生神经元的输出.</p><p>理想中的激活函数是图 (a) 所示的阶跃函数, 它将输入值映射为输出值 0 或 1. 0 对应神经元兴奋, 1 对应神经元抑制. 然而, 阶跃函数具有不连续, 不光滑等不友好的性质, 我们实际常用 Sigmoid 或者 ReLU 函数作为激活函数.</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029204144054.png" alt="image-20201029204144054" style="zoom:50%;" /></p><p>把许多个这样的神经元按一定的层次结构连接起来, 我们就得到了神经网络. <strong>事实上, 从计算机科学的角度看, 我们可以不先考虑神经网络是否真的模拟了生物神经网络, 只需将一个神经网络视为包含了许多参数的数学模型, 这个模型是若干个函数.</strong></p><h3 id="2-Perceptron"><a href="#2-Perceptron" class="headerlink" title="2. Perceptron"></a>2. Perceptron</h3><p>感知机 (Perceptron) 由两层神经元组成, 输入层接收外界输入信号后传递给输出层, 输出层是 M-P 神经元.</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029205028551.png" alt="image-20201029205028551" style="zoom:50%;" /></p><p>给定训练数据集, 权重 $w_i (i=1,2,…,n)$ 以及阈值 $\theta$ 可通过学习得到. 阈值 $\theta$ 可看作一个固定输入为 -1.0 的<strong>“哑结点” (dummy node)</strong> 所对应的连接权重 $w_{n+1}$, 这样, 权重和阈值的学习就可统一为权重的学习. 感知机学习规则非常简单, 对训练样例 ($\mathbf{x},y$), 若当前感知机的输出为 $\hat{y}$, 则感知机权重将这样调整:</p><script type="math/tex; mode=display">w_i\leftarrow w_i+\Delta w_i\\\Delta w_i=\eta(y-\hat{y})x_i</script><p>其中 $\eta\in(0,1)$ 称为学习率 (learning rate). 从上式可看出, 若感知机对训练样例 ($\mathbf{x},y$) 预测正确, 即 $\hat{y}=y$, 则感知机不发生改变, 否则将根据错误的程度进行权重调整. </p><p>感知机只有输出层神经元进行激活函数处理, 即只拥有一层功能神经元 (functional neuron), 其学习能力非常有限, 事实上, 若两类模式是线性可分的, 即存在一个线性超平面能够将它们分开, 如下图所示, 则感知机的学习过程一定会收敛 (converge) 而求得适当的权向量 $w$; 否则感知机学习过程将会发生振荡, $w$ 难以稳定下来, 不能求得合适解.</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029211344492.png" alt="image-20201029211344492" style="zoom:50%;" /></p><h3 id="3-Multi-Layer-Feedforward-Nerual-Networks"><a href="#3-Multi-Layer-Feedforward-Nerual-Networks" class="headerlink" title="3. Multi-Layer Feedforward Nerual Networks"></a>3. Multi-Layer Feedforward Nerual Networks</h3><p>要解决非线性可分问题, 需考虑使用多层功能神经元. 例如下图这个简单的两层感知机就能解决异或问题. </p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029212505038.png" alt="image-20201029212505038" style="zoom:50%;" /></p><p>计算过程如下:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029212628077.png" alt="image-20201029212628077" style="zoom:50%;" /></p><p>更一般的, 常见的神经网络是如下图所示的层级结构, 每层神经元与下一层神经元<strong>全互连</strong>, 神经元之间不存在同层连接, 也不存在跨层连接. 这样的神经网络结构通常称为<strong>多层前馈神经网络 (multi-layer feedforward neural networks)</strong>. 神经网络的学习过程, 就根据训练数据来调整神经元之间的<strong>连接权 (connection weight)</strong> 以及每个功能神经元的阈值; 换言之, 神经网络学到的东西, 蕴含在连接权和阈值中.</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029213027567.png" alt="image-20201029213027567" style="zoom:50%;" /></p><h3 id="4-Error-Backpropogation"><a href="#4-Error-Backpropogation" class="headerlink" title="4. Error Backpropogation"></a>4. Error Backpropogation</h3><p>多层神经网络的学习能力要比单层感知机强很多, 但是要训练多层神经网络, 单层感知机的学习规则就显得不够用了, 因此我们在这里将会介绍误差逆传播 (Error BackPropagation) 算法. 下面我们来以一个单隐层神经网络为例来推导一下 BP 算法.</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029214352239.png" alt="image-20201029214352239" style="zoom:50%;" /></p><p>训练集 $D=\{(\mathbf{x}_1,y_1),(\mathbf{x}_2,y_2),…,(\mathbf{x}_m,y_m)\}$, 其中第 $k$ 个样本 $(\mathbf{x}_k,\mathbf{y}_k)$</p><script type="math/tex; mode=display">\mathbf{x}_k=(x_1^k,x_2^k,...,x_d^k)\in\mathbb{R}^d,\mathbf{y}_k=(y_1^k,y_2^k,...,y_l^k)\in\mathbb{R}^l</script><p>假设隐层和输出层神经元都使用 Sigmoid 函数</p><p><strong>待确定参数:</strong></p><ul><li>输入层到隐层的 $d\times q$ 个权值 $v_{ih}\ (1\leq i\leq d,\ 1\leq h\leq q)$</li><li>隐层到输出层的 $q\times l$ 个权值 $w_{hj}\ (1\leq h\leq q,\ 1\leq j\leq l)$</li><li>隐层的 $q$ 个神经元的阈值 $\gamma_h\ (1\leq h \leq q)$</li><li>输出层的 $l$ 个神经元的阈值 $\theta_j \ (1\leq j \leq l)$</li></ul><p>另外, 隐层的神经元个数 $q$ 以及训练轮数 epoch 也都是需要确定的超参数.</p><p><strong>BP 算法</strong>首先在 $(0,1)$ 范围内随机初始化网络中所有连接权和阈值, 在每一轮迭代中采用梯度下降策略逐步对权重进行更新, 而<strong>标准 BP 算法</strong>在每一轮迭代中是依次仅针对一个训练样例更新连接权和阈值.</p><p>现在我们来开始推导 BP 算法. 首先, 神经网络在一个训练样例 $(\mathbf{x}_k,\mathbf{y}_k)$ 上的均方误差为:</p><script type="math/tex; mode=display">E_k=\frac{1}{2}\sum_{j=1}^l(\hat{y}_j^k-y_j^k)^2</script><p>任意参数的更新估计式为:</p><script type="math/tex; mode=display">v\leftarrow v+\Delta v</script><p>BP 算法基于梯度下降策略, 以目标的负梯度方向对参数进行调整. 对式 (5.4) 的误差 $E_k$, 给定学习率 $\eta$, 有:</p><script type="math/tex; mode=display">\Delta w_{hj}=\eta\frac{\partial E_k}{\partial w_{hj}}</script><p>根据导数运算的规律, 我们能够得到:</p><script type="math/tex; mode=display">\frac{\partial E_k}{\partial w_{hj}}=\frac{\partial E_k}{\partial\hat{y}_j^k}\cdot\frac{\partial\hat{y}_j^k}{\partial\beta_j}\cdot\frac{\partial\beta_j}{\partial w_{hj}}</script><p>其中:</p><script type="math/tex; mode=display">\begin{aligned}&\frac{\partial E_k}{\partial \hat{y}_j^k}=\hat{y}_j^k-y_j^k \\&\frac{\partial \hat{y}_j^k}{\partial \beta_j}=\hat{y}_j^k(1-\hat{y}_j^k)\\&\frac{\partial\beta_j}{\partial w_{hj}}=b_h\end{aligned}</script><p>同理, 我们能够得到:</p><script type="math/tex; mode=display">\frac{\partial E_k}{\partial\theta_j}=\frac{\partial E_k}{\partial\hat{y}_j^k}\cdot\frac{\partial\hat{y}_j^k}{\partial\theta_j}</script><p>其中:</p><script type="math/tex; mode=display">\begin{aligned}&\frac{\partial E_k}{\partial \hat{y}_j^k}=\hat{y}_j^k-y_j^k \\&\frac{\partial E_k}{\partial \theta_j}=-\hat{y}_j^k(1-\hat{y}_j^k)\end{aligned}</script><p>按照这种思路继续往前推, 我们能得到 $\frac{\partial E_k}{\partial v_{ih}}$ 的计算公式:</p><script type="math/tex; mode=display">\frac{\partial E_k}{\partial v_{ih}}=\sum_{j=1}^l\frac{\partial E_k}{\partial \hat{y}_j^k}\cdot\frac{\partial \hat{y}_j^k}{\partial \beta_j}\cdot\frac{\partial\beta_j}{\partial b_h}\cdot\frac{\partial b_h}{\partial\alpha_h}\cdot\frac{\partial \alpha_h}{\partial v_{ih}}</script><p>其中:</p><script type="math/tex; mode=display">\begin{aligned}&\frac{\partial E_k}{\partial \hat{y}_j^k}=\hat{y}_j^k-y_j^k \\&\frac{\partial \hat{y}_j^k}{\partial \beta_j}=\hat{y}_j^k(1-\hat{y}_j^k) \\&\frac{\partial\beta_j}{\partial b_h}=w_{hj} \\&\frac{\partial b_h}{\partial\alpha_h}=b_h(1-b_h) \\&\frac{\partial \alpha_h}{\partial v_{ih}}=x_i \\\end{aligned}</script><p>$\frac{\partial E_k}{\partial \gamma_h}$ 的推导也同上, 在这里我就不赘述了. 到此, 我们的 BP 算法的推导就完成了! 但是你有没有觉得这种单个参数的计算太麻烦了!!! 我们不妨借用矩阵来使我们的运算更方便!</p><h4 id="4-1-Matrix-Solution"><a href="#4-1-Matrix-Solution" class="headerlink" title="4.1 Matrix Solution"></a>4.1 Matrix Solution</h4><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029225819384.png" alt="image-20201029225819384" style="zoom:50%;" /></p><p><strong>Network Overview</strong></p><p>输入层有 6 个特征: $\mathbf{x}=[x_1,…,x_6]^T$</p><p>隐层有 4 个神经元: $\mathbf{z}=[z_1,…,z_4]^T$</p><p>输出层是一个概率分布: $\mathbf{y}=[y_1,y_2,y_3]^T$</p><p><em>We also allow for a bias term by adding a constant one to the input, $x_0=1$ and a constant one to the hidden layer $z_0=1$.</em></p><p>$\alpha$ 是从输入层到隐层的权重矩阵. $\beta$ 是隐层到输出层的参数矩阵.</p><p>$\alpha_{j,i}$ represents the weight going to the node $z_j$ in the hidden layer from the node $x_i$ in the input layer (e.g. $\alpha_{1,2}$ is the weight from $x_2$ to $z_1$ ), and $\beta$ is deﬁned similarly. We will use a <strong>sigmoid activation function</strong> for the hidden layer and a <strong>softmax</strong> for the output layer.</p><p><strong>Network Details</strong>    Equivalently, we define each of the following.</p><p>The input:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029231839772.png" alt="image-20201029231839772" style="zoom:50%;" /></p><p>Linear combination at the first (hidden) layer:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029232006997.png" alt="image-20201029232006997" style="zoom:50%;" /></p><p>Activation at the first (hidden) layer:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029232117730.png" alt="image-20201029232117730" style="zoom:50%;" /></p><p>Linear combination at the second (output) layer:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029232201528.png" alt="image-20201029232201528" style="zoom:50%;" /></p><p>Activation at the second (output) layer:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029232255460.png" alt="image-20201029232255460" style="zoom:50%;" /></p><p>不含 bias 参数的 $\alpha$:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029232424679.png" alt="image-20201029232424679" style="zoom:50%;" /></p><p>不含 bias 参数的 $\beta$:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029232457503.png" alt="image-20201029232457503" style="zoom:50%;" /></p><p>含 bias 参数的 $\alpha$:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029232545404.png" alt="image-20201029232545404" style="zoom:50%;" /></p><p>含 bias 参数的 $\beta$:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029232601815.png" alt="image-20201029232601815" style="zoom:50%;" /></p><p>And we set our first value of our input vectors to always be 1 ($x_0=1$), so our input becomes:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029232758945.png" alt="image-20201029232758945" style="zoom:50%;" /></p><p><strong>Loss</strong></p><p>We will use cross entropy loss, $\ell(\hat{y},y)$. If $\mathbf{y}$ represents our target output, which will be a one-hot vector representing the correct class, and $\hat{\mathbf{y}}$ represents the output of the network, the loss is calculated by:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029234909511.png" alt="image-20201029234909511" style="zoom:50%;" /></p><p><strong>Feed Forward</strong></p><p>$\mathbf{a}=\alpha\mathbf{x}$</p><p>$\mathbf{z}=sigmoid(\mathbf{a})$</p><p>$\mathbf{b}=\beta\mathbf{z}$</p><p>$\hat{\mathbf{y}}=softmax(\mathbf{b})$</p><p><strong>Backpropagation</strong></p><p>$\frac{\partial \ell}{\partial \mathbf{b}}=-\mathbf{y}+\hat{\mathbf{y}}$</p><p>$\frac{\partial \ell}{\partial \beta}=\frac{\partial \ell}{\partial \mathbf{b}}\mathbf{z}^T$</p><p>$\frac{\partial \ell}{\partial \mathbf{z}}=(\beta^{*})^T\frac{\partial \ell}{\partial \mathbf{b}}$</p><p>$\frac{\partial \ell}{\partial \mathbf{a}}=\frac{\partial \ell}{\partial \mathbf{z}}\odot\mathbf{z}\odot(1-\mathbf{z})$</p><p>$\frac{\partial \ell}{\partial \alpha}=\frac{\partial \ell}{\partial \mathbf{a}}\mathbf{x}^T$</p><blockquote><p>  符号 $\odot$ 表示矩阵哈达玛积, 即两个大小相同的矩阵对应位置元素相乘.</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201030000623806.png" alt="image-20201030000623806"></p><h3 id="5-Implementation"><a href="#5-Implementation" class="headerlink" title="5. Implementation"></a>5. Implementation</h3><p><strong>项目地址:</strong> <a href="https://github.com/alvisdeng/OCR-Letter-Recognizer">https://github.com/alvisdeng/OCR-Letter-Recognizer</a></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Supervised Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防止过拟合-正则化(Regularization)</title>
      <link href="2020/11/13/%E9%98%B2%E6%AD%A2%E8%BF%87%E6%8B%9F%E5%90%88-%E6%AD%A3%E5%88%99%E5%8C%96-Regularization/"/>
      <url>2020/11/13/%E9%98%B2%E6%AD%A2%E8%BF%87%E6%8B%9F%E5%90%88-%E6%AD%A3%E5%88%99%E5%8C%96-Regularization/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>正则化 (Regularization) 是机器学习中一种比较常用的技术, 其主要的目的是控制模型的复杂度, 减小过拟合的可能性, 增加模型的泛化能力. </p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029033026156.png" alt="image-20201029033026156" style="zoom:50%;" /></p><p>如上图, 红色这条“想象力”过于丰富上下横跳的曲线就是过拟合情形. 结合上图和正则化的英文 Regularizaiton-Regular-Regularize, <strong>直译应该是: 规则化</strong>. 什么是规则? 你妈喊你6点前回家吃饭, 这就是规则, 一个<strong>限制</strong>. 同理, 在这里, <strong>规则化就是说给需要训练的目标函数加上一些规则 (限制), 让他们不要自我膨胀</strong>. 正则化, 看起来, 挺不好理解的, 追其根源, 还是“正则”这两字在中文中实在没有一个直观的对应, 如果能翻译成<strong>规则化</strong>, 更好理解. </p><p>最基本的正则化方法是在原目标 (代价) 函数中添加惩罚项, 对复杂度高的模型进行“惩罚”. 其数学表达形式为:</p><script type="math/tex; mode=display">\widetilde{J}(w;X,y)=J(w;X,y)+\alpha\Omega(w)</script><p>式中 $X,y$ 为训练样本和相应标签, $w$ 为权重系数向量; $J()$ 为目标函数, $\Omega()$ 即为惩罚项, 可以理解为模型”规模”的某种度量; 参数 $\alpha$ 控制正则化强弱. 不同的 $\Omega$ 函数对权重 $w$ 的最优解有不同的偏好, 因而会产生不同的正则化效果. 最常用的 $\Omega$ 函数有两种, 即 $l_1$ 范数和 $l_2$ 范数, 相应称之为 $l_1$ 正则化和 $l_2$ 正则化, 此时有:</p><script type="math/tex; mode=display">\begin{aligned}&l_1:\Omega=||w||_1=\sum_i|w_i| \\&l_2:\Omega=||w||_2^2=\sum_iw_i^2\end{aligned}</script><h3 id="2-Math-Explanation"><a href="#2-Math-Explanation" class="headerlink" title="2. Math Explanation"></a>2. Math Explanation</h3><p>我们可以从带约束条件的优化求解和最大后验概率两种思路来推导 $l_1,l_2$ 正则化.</p><ol><li><p><strong>正则化理解之基于约束条件的最优化</strong></p><p>对于模型权重系数 $w$ 求解是通过最小化目标函数实现的, 即求解:</p><script type="math/tex; mode=display">\min_wJ(w;X,y)</script><p>我们知道, 模型的复杂度可以用 VC 维来衡量. 通常情况下, 模型 VC 维与参数 $w$ 的个数成线性关系: 即 $w$ 数量越多, VC 维越大, 模型越复杂. 因此, 为了限制模型的复杂度, 很自然的思路是减少系数 $w$ 的个数, 即让 $w$ 向量中一些元素为 0 或者说限制 $w$ 中的非零元素个数. 为此, 我们可以在原优化问题中加入一个约束条件:</p><script type="math/tex; mode=display">\min_wJ(w;X,y) \\s.t.||w||_0\le C</script><p>$||·||_0$ 范数表示向量中非零元素的个数. 但由于该问题是一个 NP 问题且非凸函数, 不易求解, 为此我们需要稍微放松一下约束条件. 为了达到近似效果, 我们不严格要求某些权重 $w$ 为 0, 而是要求权重 $w$ 应该接近于 0, 即尽量小. 从而可以用 $l_1,l_2$ 范数来近似 $l_0$ 范数, 即:</p><script type="math/tex; mode=display">\min_wJ(w;X,y)\quad s.t.||w||_1\le C\\\min_wJ(w;X,y)\quad s.t.||w||_2\le C</script><p>使用 $l_2$ 范数时, 为了方便后续处理, 我们可以对 $||w||_2$ 进行平方, 此时只需要调整 $C$ 的取值即可. 利用拉格朗日算子法, 我们可以将上述带约束条件的最优化问题转换为不带约束项的优化问题, 构造拉格朗日函数:</p><script type="math/tex; mode=display">L(w,\alpha)=J(w;X,y)+\alpha(||w||_1-C) \\L(w,\alpha)=J(w;X,y)+\alpha(||w||_2^2-C)</script><p>其中 $\alpha&gt;0$, 我们假设 $\alpha$ 的最优解为 $\alpha^*$, 则对拉格朗日函数求最小化等价于:</p><script type="math/tex; mode=display">\min_wJ(w;X,y)+\alpha^*||w||_1 \\\min_wJ(w;X,y)+\alpha^*||w||_2^2 \\</script><p><strong>故此, 我们得到对 $l_1,l_2$ 正则化的第一种理解:</strong></p><ul><li>$l_1$ 正则化等价于在原优化目标函数中增加约束条件 $||w||_1\leq C$;</li><li>$l_2$ 正则化等价于在原优化目标函数中增加约束条件 $||w||_2^2\leq C$;</li></ul></li><li><p><strong>正则化理解之最大后验概率估计</strong></p><p>在<strong>最大似然估计</strong>中, 是假设权重 $w$ 是未知的参数, 从而求得对数似然函数:</p><script type="math/tex; mode=display">l(w)=\log[P(y|X;w)]=\log[\prod_iP(y_i|x_i;w)]</script><p>通过假设 $y^i$ 的不同概率分布, 即可得到不同的模型. 例如若假设 $y_i\thicksim N(w^Tx_i,\sigma^2)$ 的高斯分布, 则有:</p><script type="math/tex; mode=display">l(w)=\log[\prod_i\frac{1}{\sqrt{2\pi}\sigma}\exp(-\frac{(y_i-w^Tx_i)^2}{2\sigma^2})]=-\frac{1}{2\sigma^2}\sum_i(y_i-w^Tx_i)^2+C</script><p>式中 $C$ 为常数项, 由于常数项和系数项不影响 $\max l(w)$ 的解, 因而可令 $J(w;X,y)=-l(w)$ 即可得到线性回归的代价函数. </p><p>在<strong>最大后验概率估计</strong>中, 是将权重 $w$ 看作随机变量, 也具有某种分布, 从而有:</p><script type="math/tex; mode=display">P(w|X,y)=\frac{P(w,X,y)}{P(X,y)}=\frac{P(X,y|w)P(w)}{P(X,y)}\propto P(y|X,w)P(w)</script><p>同时取对数有:</p><script type="math/tex; mode=display">\mathbf{MAP}=\log P(y|X,w)P(w)=\log P(y|X,w)+\log P(w)</script><p>可以看出, 后验概率函数在似然函数的基础之上增加了一项 $\log P(w)$. $P(w)$ 的意义是对权重系数 $w$ 的概率分布的先验假设, 在收集到训练样本 $\{X,y\}$ 后, 则可根据 $w$ 在 $\{X,y\}$ 下的后验概率对 $w$ 进行修正, 从而做出对 $w$ 更好的估计. </p><ul><li><p>若假设 $w_j$ 的先验分布为均值是 0 的高斯分布, 即 $w_j\thicksim N(0,\sigma^2)$, 则有:</p><script type="math/tex; mode=display">\log P(w)=\log\prod_jP(w_j)=\log\prod_j\frac{1}{\sqrt{2\pi}\sigma}\exp(-\frac{w_j^2}{2\sigma^2})=-\frac{1}{2\sigma^2}\sum_jw_j^2+C'</script><p>可以看到, 在高斯分布下 $\log P(w)$ 的效果等价于在代价函数中增加 $l_2$ 正则项.</p></li><li><p>若假设 $w_j$ 的先验分布是均值为 0, 参数为 $a$ 的拉普拉斯分布, 即:</p><script type="math/tex; mode=display">P(w_j)=\frac{1}{\sqrt{2a}}\exp(-\frac{|w_j|}{a})</script><p>则有:</p><script type="math/tex; mode=display">\log P(w)=\log\prod_j\frac{1}{\sqrt{2a}}\exp(-\frac{|w_j|}{a})=-\frac{1}{a}\sum_j|w_j|+C'</script><p>可以看到, 在拉普拉斯分布下 $\log P(w)$ 的效果等价于在代价函数中增加 $l_1$ 正则项.</p></li></ul><p><strong>故此, 我们得到对于 $l_1,l_2$ 正则化的第二种理解:</strong></p><ul><li>$l_1$ 正则化可以通过假设权重 $w$ 的先验分布为拉普拉斯分布, 由最大后验概率估计导出;</li></ul></li></ol><ul><li>$l_2$ 正则化可以通过假设权重 $w$ 的先验分布为高斯分布, 由最大后验概率估计导出;</li></ul><h3 id="3-Effect-Analysis"><a href="#3-Effect-Analysis" class="headerlink" title="3. Effect Analysis"></a>3. Effect Analysis</h3><p>我们从直观分析和理论推导两个角度来说明 $l_1,l_2$ 正则化的效果.</p><ol><li><p><strong>直观理解</strong></p><p><u>考虑带约束条件的优化解释, $l_2$ 正则化为:</u></p><script type="math/tex; mode=display">\min_wJ(w;X,y)\quad s.t.||w||_2^2\le C</script><p>该问题的求解示意图如下:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029055813729.png" alt="image-20201029055813729" style="zoom:50%;" /></p><p>图中椭圆为原目标函数 $J(w)$ 的一条等高线, 圆为半径 $\sqrt{C}$ 的范数球. 由于约束条件的限制, $w$ 必须位于 $l_2$ 范数球内. 考虑边界上的一点 $w$, 图中蓝色箭头为 $J(w)$ 在该处的梯度方向 $\nabla J(w)$, 红色箭头为 $l_2$ 范数球在该处的法线方向. 由于 $w$ 不能离开边界 (否则违反约束条件), 因而在使用梯度下降更新 $w$ 时, 只能朝着 $\nabla J(w)$ 在范数球上 $w$ 处的切线方向更新, 即图中的绿色箭头方向. 如此 $w$ 将沿着边界移动, 当 $\nabla J(w)$ 与范数球上 $w$ 处的法线平行时, 此时 $\nabla J(w)$ 在切线方向的分量为 0, $w$ 将无法继续移动, 从而达到最优解 $w^*$ (图中红点所示).</p><blockquote><p>  <strong>为什么 $l_2$ 正则化对应的是一个圆?</strong></p><p>  考虑 $z=w_1^2+w_2^2$ 就是抛物面, 俯视图是一个圆.</p></blockquote><p><u>考虑带约束条件的优化解释, $l_1$ 正则化为:</u></p><script type="math/tex; mode=display">\min_wJ(w;X,y)\quad s.t.||w||_1\le C\\</script><p>该问题的求解示意图如下:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201029061347345.png" alt="image-20201029061347345" style="zoom:50%;" /></p><p>其主要差别在于 $l_1,l_2$ 范数球的形状差异. 由于此时每条边界上 $w$ 的切线方向和法线方向保持不变, 在图中 $w$ 将一直朝着 $\nabla J(w)$ 在切线上的分量沿着边界向左上移动. 当 $w$ 跨过顶点到达 $w’$ 时, $\nabla J(w)$ 在切线方向的分量变为右上方, 因而 $w$ 将朝着右上方移到. 最终, $w$ 将稳定在顶点处, 达到最优解 $w^*$. 此时, 可以看到 $w_1=0$, 这也就是采用 $l_1$ 范数会使 $w$ 产生稀疏性的原因. </p><p>以上分析虽是基于二维的情况, 但不难将其推广到多维情况, 其主要目的是为了直观说明 $l_1$ 和 $l_2$ 正则化最优解的差异, 以及 $l_1$ 范数为什么产生稀疏性.</p><blockquote><p>  <strong>Question:</strong> 为什么 $l_1$ 正则会到达w’呢? 感觉如图的形式, 可能在到达上面的顶点前就能有一个最优解, 就是梯度下降方向与法向量平行? </p><p>  <strong>Answer:</strong> 这种情况是可能会出现的, 但可能性比较小, 而且实际数据维度比较大, 不太容易出现.</p></blockquote></li><li><p><strong>理论推导</strong></p><p>数学功力不够暂时搞不懂, 之后补上…</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Supervised Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解逻辑回归(Logistic Regression)</title>
      <link href="2020/11/12/%E8%AF%A6%E8%A7%A3%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92-Logistic-Regression/"/>
      <url>2020/11/12/%E8%AF%A6%E8%A7%A3%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92-Logistic-Regression/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Logistic-Regression"><a href="#1-Logistic-Regression" class="headerlink" title="1. Logistic Regression"></a>1. Logistic Regression</h3><p>我们之前学习了如何使用线性模型进行回归学习. 但其实我们能使用最后所讲的<strong>广义线性模型</strong>我们能进行分类任务学习: <strong>我们只需要找一个单调可微函数将分类任务的真实标记 $y$ 与线性回归模型的预测值联系起来.</strong></p><p>我们从简单的二分类任务入门, 其输出标记 $y\in \{0,1\}$, 而线性回归模型产生的预测值 $z=w^Tx+b$ 是实值, 于是, 我们需要将实值 $z$ 转换为 0/1 值. 最理想的是<strong>单位阶跃函数 (unit-step function)</strong>. </p><script type="math/tex; mode=display">y=\begin{cases}\begin{aligned}0,\quad z<0;\\0.5,\quad z=0;\\1,\quad z>0;\end{aligned}\end{cases}</script><p>若预测值 $z$ 大于零就判为正例, 小于零则判为反例, 预测值为临界值零则可以任意判别. 我们不难发现单位阶跃函数存在一个问题, 就是不连续! 因此不能将单位阶跃函数用于<strong>广义线性模型</strong>. 因此我们可以用一个替代函数, 也就是下图中的<strong>对数几率函数(或者称为逻辑斯谛函数)</strong>. </p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/1*Q55RIBsXLfSdzYOeltcuGw.png" alt="The differences between Artificial and Biological Neural Networks | by  Richard Nagyfi | Towards Data Science"  /></p><p>对数几率函数将 $z$ 值转换为一个接近 0 或 1 的 $y$ 值, 并且其输出值在 $z=0$ 附近变化很陡. 我们将对数几率函数代入<strong>广义线性模型</strong>之后, 可以得到</p><script type="math/tex; mode=display">y=\frac{1}{1+\exp(-w^Tx-b)}</script><p>通过简单的数学变形, 我们可以得到下式</p><script type="math/tex; mode=display">\log\frac{y}{1-y}=w^Tx+b</script><p>若将 $y$ 视为样本 $x$ 作为正例的可能性, 则 $1-y$ 是其反例的可能性, 两者的比值 $\frac{y}{1-y}$ 称为<strong>几率</strong>, 反映了 $x$ 作为正例的相对可能性. 对几率取对数则得到<strong>对数几率 (log odds, 亦称为 logit)</strong>, $\log{\frac{y}{1-y}}$.</p><p>由此我们知道, $y=\frac{1}{1+\exp(-w^Tx-b)}$ 实际上是在用线性回归模型 ($z=w^Tx+b$) 的预测结果去逼近真实标记的对数几率 ($\log{\frac{y}{1-y}}$). 因此, <strong>其对应的模型称为对数几率回归 (Logistic Regression, 或者叫做逻辑回归, 或逻辑斯谛回归).</strong>  需要注意的是, 虽然其名字里面有一个回归, 但其实际上是一种分类学习算法. </p><ol><li><strong>优点</strong><ul><li><strong>模型:</strong> 模型清晰, 背后的概率推导经得住推敲.</li><li><strong>输出:</strong> 输出值自然地落在0到1之间, 并且有概率意义.</li><li><strong>参数:</strong> 参数代表每个特征对输出的影响, 可解释性强.</li><li><strong>简单高效:</strong> 实施简单, 非常高效（计算量小、存储占用低）, 可以在大数据场景中使用.</li><li><strong>可扩展:</strong> 可以使用online learning的方式更新轻松更新参数, 不需要重新训练整个模型.</li><li><strong>过拟合:</strong> 解决过拟合的方法很多, 如L1、L2正则化.</li><li><strong>多重共线性:</strong> L2正则化就可以解决多重共线性问题.</li></ul></li><li><p><strong>缺点</strong></p><ul><li><strong>特征相关情况:</strong> 因为它本质上是一个线性的分类器, 所以处理不好特征之间相关的情况.</li><li><strong>特征空间:</strong> 特征空间很大时, 性能不好.</li><li><strong>精度:</strong> 容易欠拟合, 精度不高.</li></ul></li><li><p><strong>使用注意事项</strong></p><ul><li>建模数据量不能太少</li><li>排除自变量中共线性的问题</li><li>异常值会给模型带来很大的干扰</li></ul><p>我们在使用逻辑回归的时候很少会把数据直接丢给 LR 来训练, 我们一般会对特征进行离散化处理, 这样做的优势大致有以下几点:</p><ol><li>离散后稀疏向量内积乘法运算速度更快, 计算结果也方便存储, 容易扩展;</li><li>离散后的特征对异常值更具鲁棒性, 如 age&gt;30 为 1 否则为 0, 对于年龄为 200 的也不会对模型造成很大的干扰;</li><li>LR 属于广义线性模型, 表达能力有限, 经过离散化后, 每个变量有单独的权重, 这相当于引入了非线性, 能够提升模型的表达能力, 加大拟合;</li><li>离散后特征可以进行特征交叉, 提升表达能力, 由 M+N 个变量编程 M*N 个变量, 进一步引入非线形, 提升了表达能力;</li><li>特征离散后模型更稳定, 如用户年龄区间, 不会因为用户年龄长了一岁就变化;</li></ol></li></ol><h4 id="1-1-Decision-Boundary"><a href="#1-1-Decision-Boundary" class="headerlink" title="1.1 Decision Boundary"></a>1.1 Decision Boundary</h4><p>根据上面的对数几率公式: $\log\frac{y}{1-y}=w^Tx+b$, 我们很容易知道, 逻辑回归的决策边界为 $w^Tx+b=0$. 根据样本 $x$ 的维度不同, 该决策边界可以是一条直线或者是一个超平面. </p><p>我们用鸢尾花数据集来可视化一下决策边界. 我们首先可视化数据集:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">X = iris.data</span><br><span class="line">y = iris.target</span><br><span class="line">X = X[y&lt;<span class="number">2</span>,:<span class="number">2</span>]</span><br><span class="line">y = y[y&lt;<span class="number">2</span>]</span><br><span class="line">plt.scatter(X[y==<span class="number">0</span>,<span class="number">0</span>],X[y==<span class="number">0</span>,<span class="number">1</span>],color=<span class="string">&quot;red&quot;</span>)</span><br><span class="line">plt.scatter(X[y==<span class="number">1</span>,<span class="number">0</span>],X[y==<span class="number">1</span>,<span class="number">1</span>],color=<span class="string">&quot;blue&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201220030809278.png" alt="image-20201220030809278" style="zoom:50%;" /></p><p>然后使用逻辑回归进行训练:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line">random_state = np.random.RandomState(<span class="number">0</span>)</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X,y,random_state=random_state)</span><br><span class="line"></span><br><span class="line">clf = LogisticRegression(penalty=<span class="string">&quot;l2&quot;</span>)</span><br><span class="line">clf.fit(X_train,y_train)</span><br><span class="line">coef = clf.coef_</span><br><span class="line">intercept = clf.intercept_</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_x2</span>(<span class="params">x1</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (-intercept-coef[<span class="number">0</span>][<span class="number">0</span>]*x1)/coef[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">x1_plot = np.linspace(<span class="number">4</span>,<span class="number">7</span>,<span class="number">1000</span>)</span><br><span class="line">x2_plot = get_x2(x1_plot)</span><br><span class="line">plt.scatter(X[y==<span class="number">0</span>,<span class="number">0</span>],X[y==<span class="number">0</span>,<span class="number">1</span>],color=<span class="string">&quot;red&quot;</span>)</span><br><span class="line">plt.scatter(X[y==<span class="number">1</span>,<span class="number">0</span>],X[y==<span class="number">1</span>,<span class="number">1</span>],color=<span class="string">&quot;blue&quot;</span>)</span><br><span class="line">plt.plot(x1_plot,x2_plot)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201220035812835.png" alt="image-20201220035812835" style="zoom:50%;" /></p><p>但其实决策边界也可以是非线性的, 如果我们遇到下图的情况, 我们就不能用一个直线将其分类了, 而是可以用一个类似圆的图形将数据进行分类. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">666</span>)</span><br><span class="line">X = np.random.normal(<span class="number">0</span>,<span class="number">1</span>,size=(<span class="number">200</span>,<span class="number">2</span>))</span><br><span class="line">y = np.array((X[:,<span class="number">0</span>]**<span class="number">2</span>+X[:,<span class="number">1</span>]**<span class="number">2</span>)&lt;<span class="number">1.5</span>, dtype=np.<span class="built_in">int</span>)</span><br><span class="line">plt.scatter(X[y==<span class="number">0</span>,<span class="number">0</span>],X[y==<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">plt.scatter(X[y==<span class="number">1</span>,<span class="number">0</span>],X[y==<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201220041121535.png" alt="image-20201220041121535" style="zoom:50%;" /></p><p>首先我们使用没添加多项式项的逻辑回归函数, 对上面的样本进行划分. 得到的分类结果应该是很差的.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"></span><br><span class="line">clf = LogisticRegression()</span><br><span class="line">clf.fit(X,y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_decision_boundary</span>(<span class="params">model,axis</span>):</span></span><br><span class="line">    x0, x1 = np.meshgrid( <span class="comment"># meshgrid: https://www.cnblogs.com/lemonbit/p/7593898.html</span></span><br><span class="line">        np.linspace(axis[<span class="number">0</span>],axis[<span class="number">1</span>],<span class="built_in">int</span>((axis[<span class="number">1</span>]-axis[<span class="number">0</span>])*<span class="number">100</span>)).reshape(-<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">        np.linspace(axis[<span class="number">2</span>],axis[<span class="number">3</span>],<span class="built_in">int</span>((axis[<span class="number">3</span>]-axis[<span class="number">2</span>])*<span class="number">100</span>)).reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line">    X_new = np.c_[x0.ravel(),x1.ravel()]</span><br><span class="line">    y_predict = model.predict(X_new)</span><br><span class="line">    zz = y_predict.reshape(x0.shape)</span><br><span class="line">    custom_cmap = ListedColormap([<span class="string">&#x27;#EF9A9A&#x27;</span>,<span class="string">&#x27;#FFF59D&#x27;</span>,<span class="string">&#x27;#90CAF9&#x27;</span>])</span><br><span class="line">    plt.contourf(x0,x1,zz,linewidth=<span class="number">5</span>,cmap=custom_cmap)</span><br><span class="line"></span><br><span class="line">plot_decision_boundary(clf,[-<span class="number">4</span>,<span class="number">4</span>,-<span class="number">4</span>,<span class="number">4</span>])</span><br><span class="line">plt.scatter(X[y==<span class="number">0</span>,<span class="number">0</span>], X[y==<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">plt.scatter(X[y==<span class="number">1</span>,<span class="number">0</span>], X[y==<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse/image-20201220045412022.png" alt="image-20201220045412022" style="zoom:50%;" /></p><p>然后使用逻辑回归的方式添加多项式特征, 对上面的样本进行划分: 为逻辑回归算法添加多项式项, 设置pipeline. 管道的第一步是添加多项式项, 第二部是归一化, 第三部进行逻辑回归过程, 返回实例对象.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为逻辑回归添加多项式项的管道</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PolynomialLogisticRegression</span>(<span class="params">degree</span>):</span></span><br><span class="line">    <span class="keyword">return</span> Pipeline([</span><br><span class="line">        (<span class="string">&#x27;poly&#x27;</span>, PolynomialFeatures(degree=degree)),</span><br><span class="line">        (<span class="string">&#x27;std_scaler&#x27;</span>, StandardScaler()),</span><br><span class="line">        (<span class="string">&#x27;clf&#x27;</span>, LogisticRegression(penalty=<span class="string">&#x27;none&#x27;</span>))</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用管道得到对象</span></span><br><span class="line">poly_log_reg = PolynomialLogisticRegression(degree=<span class="number">2</span>)</span><br><span class="line">poly_log_reg.fit(X, y)</span><br><span class="line">poly_log_reg.score(X, y)</span><br><span class="line"></span><br><span class="line">plot_decision_boundary(poly_log_reg, axis=[-<span class="number">4</span>, <span class="number">4</span>, -<span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line">plt.scatter(X[y==<span class="number">0</span>,<span class="number">0</span>], X[y==<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">plt.scatter(X[y==<span class="number">1</span>,<span class="number">0</span>], X[y==<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse/image-20201220050015303.png" alt="image-20201220050015303" style="zoom:50%;" /></p><p>下面我们更改degree参数 (多项式拓展的阶数), 将其变大 (那肯定会过拟合):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">poly_log_reg2 = PolynomialLogisticRegression(degree=<span class="number">20</span>)</span><br><span class="line">poly_log_reg2.fit(X, y)</span><br><span class="line">plot_decision_boundary(poly_log_reg2, axis=[-<span class="number">4</span>, <span class="number">4</span>, -<span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line">plt.scatter(X[y==<span class="number">0</span>,<span class="number">0</span>], X[y==<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">plt.scatter(X[y==<span class="number">1</span>,<span class="number">0</span>], X[y==<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201220050405341.png" alt="image-20201220050405341" style="zoom:50%;" /></p><p>我们可以在创建 <code>clf</code> 的时候, 可以使用 <code>penalty</code> 参数来防止过拟合.</p><h4 id="1-2-Parameter-Estimation"><a href="#1-2-Parameter-Estimation" class="headerlink" title="1.2 Parameter Estimation"></a>1.2 Parameter Estimation</h4><p>现在我们来研究如何求解参数 $w$ 和 $b$. 我们若将 $y$ 视作<strong>类后验概率估计</strong> $P(y=1|x)$, 则<strong>对数几率</strong> $\log{\frac{y}{1-y}}$ 可以重写为</p><script type="math/tex; mode=display">\log\frac{P(y=1|x)}{P(y=0|x)}=w^Tx+b</script><p>显然有</p><script type="math/tex; mode=display">P(y=1|x)=\frac{\exp(w^Tx+b)}{1+\exp(w^Tx+b)} \\P(y=0|x)=\frac{1}{1+\exp(w^Tx+b)}</script><p>于是, 我们可通过<strong>极大似然法 (maximum likelihood method)</strong> 来估计 $w$ 和 $b$. 给定数据集 $\{(x_i,y_i)\}_{i=1}^N$, $y_i\in\{0,1\}$, 对数几率回归模型最大化<strong>对数似然 (log likelihood)</strong>.</p><p><strong>设:</strong></p><script type="math/tex; mode=display">P(Y=1|x)=\pi(x)=\frac{\exp(w^Tx+b)}{1+\exp(w^Tx+b)}\\P(Y=0|x)=1-\pi(x)=\frac{1}{1+\exp(w^Tx+b)}</script><p><strong>似然函数 (Likelihood Function) 为</strong></p><script type="math/tex; mode=display">\prod_{i=1}^m[\pi(x_i)]^{y_i}[1-\pi(x_i)]^{1-y_i}</script><p><strong>对数似然函数 (Log Likelihood Function) 为</strong></p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}L(w,b)=&\sum_{i=1}^N[y_i\log\pi(x_i)+(1-y_i)\log(1-\pi(x_i))] \\=&\sum_{i=1}^N[y_i\log\frac{\pi(x_i)}{1-\pi(x_i)}+\log(1-\pi(x_i))] \\=&\sum_{i=1}^N[y_i(w^Tx_i+b)-\log(1+\exp(w^Tx_i+b)]\end{aligned}\end{equation}</script><p><strong>通过对 $L(w,b)$ 求极大值, 我们得到 $w,b$ 的估计值.</strong> (如果还记得Cross Entropy, 那么极大化对数似然函数就是在最小化Cross Entropy Error) 常用的方法是梯度下降法和牛顿法.</p><h3 id="3-Multinomial-Logistic-Regression"><a href="#3-Multinomial-Logistic-Regression" class="headerlink" title="3. Multinomial Logistic Regression"></a>3. Multinomial Logistic Regression</h3><p>多元逻辑回归也被称为 Softmax Regression 或 Multiclass Logistic Regression. </p><p>我们拥有的数据集如下:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201113140307456.png" alt="image-20201113140307456" style="zoom:50%;" /></p><ul><li>N 是样本数</li><li>K 是类别数</li><li>M 是特征数</li></ul><p>我们的分类器如下:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201113140532127.png" alt="image-20201113140532127" style="zoom:50%;" /></p><ul><li>$\Theta$ 是 $K\times(M+1)$ 的矩阵</li><li>$\Theta_k$ 是矩阵 $\Theta$ 的第 $k$ 行, 代表 k-th class 的参数向量</li><li>我们假设我们往矩阵 $\Theta$ 增加了 bias 列, 因此 $x^{(i)}\in\mathbb{R}^{M+1}$</li></ul><p>因此对于单个训练样本, 其似然为:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201113141253758.png" alt="image-20201113141253758" style="zoom:50%;" /></p><p>同时我们假设 $Y^{(i)}$ 是独立同分布的, 因此我们能将数据集最大似然估计表示为:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201113141453893.png" alt="image-20201113141453893" style="zoom:50%;" /></p><p>我们新建一个大小为 $N\times K$ 的矩阵 $\mathbf{T}$, 其中 $\mathbf{T}_{ij}=\mathbb{I}(y^{(i)}=j)$. 因此上式可以表示为:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201113142310608.png" alt="image-20201113142310608" style="zoom:50%;" /></p><p>进而我们的损失函数可以表示为:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201113142728518.png" alt="image-20201113142728518" style="zoom: 50%;" /></p><p>那么我们对 $J(\Theta)$ 求偏导可以得到:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201113142855559.png" alt="image-20201113142855559" style="zoom:50%;" /></p><h3 id="4-Implementation"><a href="#4-Implementation" class="headerlink" title="4. Implementation"></a>4. Implementation</h3><p><strong>项目地址:</strong> <a href="https://github.com/alvisdeng/NLP-Sentiment-Polarity-Analyzer">https://github.com/alvisdeng/NLP-Sentiment-Polarity-Analyzer</a></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Supervised Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化绝技-梯度下降(Gradient Descent)</title>
      <link href="2020/11/12/%E4%BC%98%E5%8C%96%E7%BB%9D%E6%8A%80-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D-Gradient-Descent/"/>
      <url>2020/11/12/%E4%BC%98%E5%8C%96%E7%BB%9D%E6%8A%80-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D-Gradient-Descent/</url>
      
        <content type="html"><![CDATA[<p>在线性模型中, 我们除了使用最小二乘法 (或者称为正规方程法), 我们还可以使用一种常用的凸优化技术: <strong>梯度下降!</strong>  它的主要目的是通过迭代找到目标函数的最小值, </p><blockquote><p>  梯度下降法的基本思想可以类比为一个下山的过程.</p><p>  假设这样一个场景: 一个人被困在山上, 需要从山上下来(找到山的最低点, 也就是山谷). 但此时山上的浓雾很大, 导致可视度很低; 因此, 下山的路径就无法确定, 必须利用自己周围的信息一步一步地找到下山的路. 这个时候, 便可利用梯度下降算法来帮助自己下山. <strong>怎么做呢? 首先以他当前的所处的位置为基准, 寻找这个位置最陡峭的地方, 然后朝着下降方向走一步, 然后又继续以当前位置为基准, 再找最陡峭的地方, 再走直到最后到达最低处; 同理上山也是如此, 只是这时候就变成梯度上升算法了.</strong></p><p>  从上面的解释可以看出, 梯度下降不一定能够找到全局的最优解, 有可能是一个局部最优解. 当然, 如果损失函数是严格凸函数, 梯度下降法得到的解就一定是全局最优解.</p><p>  <img src="https://i.loli.net/2020/10/04/KAjc83rfMSbHlwu.png" alt="img"></p></blockquote><p>梯度下降的基本过程就和下山的场景很类似. 根据之前的场景假设, 最快的下山的方式就是找到当前位置最陡峭的方向, 然后沿着此方向向下走, <strong>对应到函数中, 就是找到给定点的梯度</strong>, 然后朝着梯度相反的方向, 就能让函数值下降的最快! <strong>因为梯度的方向就是函数之变化最快的方向.</strong></p><h3 id="1-Why-Gradient"><a href="#1-Why-Gradient" class="headerlink" title="1. Why Gradient?"></a>1. Why Gradient?</h3><p>所以, 我们重复利用这个方法, 反复求取梯度, 最后就能到达局部的最小值, 这就类似于我们下山的过程. 而求取梯度就确定了最陡峭的方向, 也就是场景中测量方向的手段. 那么为什么梯度的方向就是最陡峭的方向呢? 接下来, 我们从微分开始讲起.</p><p>看待微分的意义, 可以有不同的角度, 最常用的两种是:</p><ul><li><em>函数图像中, 某点的切线的斜率</em></li><li><em>函数的变化率</em></li></ul><p>单变量微分我们这里就不介绍了, 主要看一下多变量微分. 当函数有多个变量的时候, 即分别对每个变量进行求微分. 梯度实际上就是多变量微分的一般化. 这里以二元函数 $z=f(x,y)$ 为例讲解偏导数, 其余情况以此类推.</p><p>由于二元函数具有两个自变量 $(x,y)$, 因此函数图像为一个曲面. 与一元函数类似, <strong>如何计算二元函数对曲面上一点</strong> $(x_0,y_0)$ <strong>的变化率呢?</strong> 此处需要注意的是, <strong>因为过曲面上一点可以作出无数条切线, 因此函数在该点也具有无数个变化率.</strong> 为了简单起见, 可以<strong>先考虑函数沿着两个坐标轴 $x$ 轴和 $y$ 轴方向的变化率.</strong></p><ul><li>当自变量 $y$ 固定在 $y_0$, 函数在点 $x_0$ 处的变化率称为函数在点 $(x_0,y_0)$ 处对 $x$ 的偏导数, 记作 $f_x(x_0,y_0)$;</li><li>当自变量 $x$ 固定在 $x_0$, 函数在点 $y_0$ 处的变化率称为函数在点 $(x_0,y_0)$ 处对 $y$ 的偏导数, 记作 $f_y(x_0,y_0)$;</li></ul><p><img src="https://i.loli.net/2020/10/05/B4RAzTwtPxiUQIq.png" alt="image-20201005113705980" style="zoom: 50%;" /></p><p><strong>可能到这里, 读者就已经发现偏导数的局限性了, 原来我们学到的偏导数指的是多元函数沿坐标轴的变化率, 但是我们往往很多时候要考虑多元函数沿任意方向的变化率, 那么就引出了方向导数.</strong></p><p>因此, 如何求出函数在点 $(x_0,y_0)$ 处沿某一方向的变化率呢? 万变不离其宗, 此时仍然按照变化率的定义去求解, 即只需求出函数的增量与自变量沿着某一方向增量比值的极限即可. </p><p>假设某一方向的单位向量为 $e_l=(\cos\alpha,\sin\alpha)$, $\alpha$ 为此向量与 $x$ 轴正向夹角. 显然, $\alpha$ 不同, 此向量能够表示任意方向的单位向量. 当点 $(x_0,y_0)$ 沿着该方向产生一个增量 $t$ 到达点 $(x_0+t\cos\alpha,y_0+t\sin\alpha)$ 时, 函数 $z$ 也会产生一个增量 $\triangle z=f(x_0+t\cos\alpha,y_0+t\sin\alpha)-f(x_0,y_0)$, 此时函数沿此方向的变化率为</p><script type="math/tex; mode=display">\lim\limits_{t\rightarrow0^+}\frac{f(x_0+t\cos\alpha,y_0+t\sin\alpha)-f(x_0,y_0)}{t}=f_x(x_0,y_0)\cos\alpha+f_y(x_0,y_0)\sin\alpha</script><p>在了解了多元函数的方向导数之后, 一个很自然的问题是: 既然函数在点 $(x_0,y_0)$ 处沿着任意的方向都有一个变化率, <strong>那么沿着哪个方向 ($\alpha=?$) 函数的变化率最大呢?</strong></p><p>根据上面的推导, 我们知道函数 $z=f(x,y)$ 沿着任意方向 ($\alpha$ 取任意值) 的变化率为</p><script type="math/tex; mode=display">f_x(x_0,y_0)\cos\alpha+f_y(x_0,y_0)\sin\alpha</script><p>因此接下来只需求得使其达到最大值时的 $\alpha$ 便可以解决上诉问题. 由于上式可以看成两个向量的内积, 令</p><script type="math/tex; mode=display">\mathbf{g}=(f_x(x_0,y_0),f_y(x_0,y_0)) \\\mathbf{e}_l=(\cos\alpha,\sin\alpha)</script><p>则</p><script type="math/tex; mode=display">f_x(x_0,y_0)\cos\alpha+f_y(x_0,y_0)\sin\alpha=\mathbf{g}\cdot\mathbf{e}_l=|\mathbf{g}||\mathbf{e}_l|\cos\theta=|\mathbf{g}|\cos\theta</script><p>其中, $\theta$ 为 $\mathbf{g}$ 和 $\mathbf{e}_l$ 的夹角, 根据上式, 我们可以得出结论:</p><ul><li>当 $\theta=0$, 即 $\mathbf{g}$ 和 $\mathbf{e}_l$ 方向相同时, 函数的变化率最大, 且在点 $(x_0,y_0)$ 呈上升趋势;</li><li>当 $\theta=\pi$, 即 $\mathbf{g}$ 和 $\mathbf{e}_l$ 方向相反时, 函数的变化率最大, 且在点 $(x_0,y_0)$ 呈下降趋势;</li></ul><p>最后, 当点 $(x_0,y_0)$ 确定后, 向量 $\mathbf{g}$ 也随之确定. 由于向量 $\mathbf{g}$ 的方向为函数值增加最快的方向, 而此方向经常被用于实际生活中, 因此为便于表述, 人们为其取了一个名字—梯度. 换而言之, <strong>多元函数在某一点的梯度是一个非常特殊的向量, 其由多元函数对每个变量的偏导数组成 (这即是为什么求梯度的时候需要对各个变量求偏导的原因), 其方向为函数在该点增加最快的方向, 大小为函数在该点的最大变化率.</strong></p><h3 id="2-Example"><a href="#2-Example" class="headerlink" title="2. Example"></a>2. Example</h3><h4 id="2-1-Single-Variable"><a href="#2-1-Single-Variable" class="headerlink" title="2.1 Single Variable"></a>2.1 Single Variable</h4><p>我们首先给出数学公式: $\theta_1=\theta_0-\alpha\triangledown\mathbf{J}(\theta)$</p><p>此公式的意义是: $\mathbf{J}$ 是关于 $\theta$ 的一个函数, 我们当前所处的位置为 $\theta_0$ 点, 要从这个点走到 $\mathbf{J}$ 的最小值点, 也就是山底. 首先我们先确定前进的方向, 也就是梯度的反向, 然后走一段距离的步长, 也就是 $\alpha$, 走完这个段步长, 就到达了 $\theta_1$ 这个点!</p><p>$\alpha$ 在梯度下降算法中被称作为学习率或者步长, 意味着我们可以通过 $\alpha$ 来控制每一步走的距离, 以保证不要步子跨的太大扯着蛋, 哈哈, 其实就是不要走太快, 错过了最低点. 同时也要保证不要走的太慢, 导致太阳下山了, 还没有走到山下. 所以 $\alpha$ 的选择在梯度下降法中往往是很重要的!</p><blockquote><p>  注:</p><p>  梯度前加一个负号, 就意味着朝着梯度相反的方向前进! 我们在前文提到, 梯度的方向实际就是函数在此点上升最快的方向! 而我们需要朝着下降最快的方向走, 自然就是负的梯度的方向, 所以此处需要加上负号; <strong>那么如果时上坡, 也就是梯度上升算法, 当然就不需要添加负号了.</strong></p></blockquote><p>我们利用上述的数学公式来看一个个简单的梯度下降的例子. 我们假设有一个单变量的函数</p><p>$\mathbf{J}(\theta)=\theta^2$</p><p>函数的微分, 直接求导就可以得到</p><p>$\mathbf{J}’(\theta)=2\theta$</p><p>初始化, 也就是起点, 起点可以随意的设置, 这里设置为1</p><p>$\theta_0=1$</p><p>学习率也可以随意的设置, 这里设置为0.4</p><p>$\alpha=0.4$</p><p>根据梯度下降的计算公式</p><p> $\theta_1=\theta_0-\alpha\triangledown\mathbf{J}(\theta)$</p><p>我们开始进行梯度下降的迭代计算过程</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201220010006930.png" alt="image-20201220010006930" style="zoom:50%;" /></p><p>如图, 经过四次的运算, 也就是走了四步, 基本就抵达了函数的最低点, 也就是山底</p><p><img src="https://i.loli.net/2020/10/05/DFHAwxhE3etCyOc.png" alt="image-20201005124317847" style="zoom: 50%;" /></p><h4 id="2-2-Multi-Varibles"><a href="#2-2-Multi-Varibles" class="headerlink" title="2.2 Multi Varibles"></a>2.2 Multi Varibles</h4><p>我们假设有一个目标函数</p><p>$\mathbf{J}(\theta)=\theta_1^2+\theta_2^2$</p><p>现在要通过梯度下降法计算这个函数的最小值. 我们通过观察就能发现最小值其实就是 (0, 0)点. 但是接下来, 我们会从梯度下降算法开始一步步计算到这个最小值!</p><p>我们假设初始的起点为</p><p>$\theta_0=(1,3)$</p><p>初始的学习率为</p><p>$\alpha=0.1$</p><p>函数的梯度为</p><p>$\triangledown\mathbf{J}(\theta)=<2\theta_1,2\theta_2>$</p><p>进行多次迭代</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201220010136155.png" alt="image-20201220010136155" style="zoom:50%;" /></p><blockquote><p>  我们此时注意到, 在更新 $\theta$ 的时候, 我们是同步更新. 具体来说, 我们在这里有两个参数, 我们是同步更新的, 而不是先计算其中一个参数然后用这个新的值去计算另外一个参数.</p></blockquote><p>我们发现，已经基本靠近函数的最小值点</p><p><img src="https://i.loli.net/2020/10/05/jr1hW2ubmY4NcBp.png" alt="image-20201005125448139" style="zoom: 50%;" /></p><h4 id="2-3-Linear-Regression"><a href="#2-3-Linear-Regression" class="headerlink" title="2.3 Linear Regression"></a>2.3 Linear Regression</h4><p>我们用 Python 来实现一个简单的梯度下降算法. 场景是一个简单的线性回归的例子: 假设现在我们有一系列的点, 如下图所示</p><p><img src="https://i.loli.net/2020/10/05/VTGt4zFDsnLl9Jr.png" alt="image-20201005130025746" style="zoom:50%;" /></p><p>首先, 我们需要定义一个代价函数, 在此我们选择均方误差代价函数</p><p>$\mathbf{J}(\theta)=\frac{1}{2m}\sum_{i=1}^m(h_{\theta}(x^{(i)}-y^{(i)})^2$</p><p>此公式中:</p><ul><li><p>m是数据集中数据点的个数, 也就是样本数;</p></li><li><p>$\frac{1}{2}$ 是一个常量, 这样是为了在求梯度的时候, 二次方乘下来的 2 就和这里的 $\frac{1}{2}$ 抵消了, 自然就没有多余的常数系数, 方便后续的计算, 同时对结果不会有影响;</p></li><li><p>$y$ 是数据集中每个点的真实 $y$ 坐标的值, 也就是类标签;</p></li><li><p>$h$ 是我们的预测函数 (假设函数), 根据每一个输入$x$, 根据 $\theta$ 计算得到预测的 $y$ 值, 即</p><p>$h_{\theta}(x^{(i)})=\theta_0+\theta_1x^{(i)}$</p></li></ul><p>我们可以根据代价函数看到, 代价函数中的变量有两个, 所以是一个多变量的梯度下降问题, 求解出代价函数的梯度, 也就是分别对两个变量进行微分</p><script type="math/tex; mode=display">\triangledown\mathbf{J}(\theta)=<\frac{\delta\mathbf{J}}{\delta\theta_0},\frac{\delta\mathbf{J}}{\delta\theta_1}> \\\frac{\delta\mathbf{J}}{\delta\theta_0}=\frac{1}{m}\sum_{i=1}^m(h_{\theta}(x^{(i)}-y^{(i)}) \\\frac{\delta\mathbf{J}}{\delta\theta_1}=\frac{1}{m}\sum_{i=1}^m(h_{\theta}(x^{(i)}-y^{(i)})x^{(i)}</script><p>根据, 我们之前在线性回归 <code>Normal Equation Method</code> 那里所提到的, 我们可以将目标函数和以及其梯度给转换成矩阵形式</p><script type="math/tex; mode=display">\mathbf{J}(\theta)=\frac{1}{2m}(X\Theta-\overrightarrow{y})^T(X\Theta-\overrightarrow{y}) \\\triangledown\mathbf{J}(\theta)=\frac{1}{m}X^T(X\Theta-\overrightarrow{y})</script><p>代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这其实是一个 batch gradient descent</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据集大小, 即 20 个数据点</span></span><br><span class="line">m = <span class="number">20</span></span><br><span class="line"><span class="comment"># Design Matrix</span></span><br><span class="line">x0 = np.ones((m,<span class="number">1</span>))</span><br><span class="line">x1 = np.arange(<span class="number">1</span>,m+<span class="number">1</span>).reshape(m,<span class="number">1</span>)</span><br><span class="line">X = np.hstack((x0,x1))</span><br><span class="line"><span class="comment"># 对应的 y </span></span><br><span class="line">y = np.array([</span><br><span class="line">    <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">12</span>,</span><br><span class="line">    <span class="number">11</span>,<span class="number">13</span>,<span class="number">13</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">21</span></span><br><span class="line">]).reshape(m,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 学习率</span></span><br><span class="line">alpha = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义代价函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost_function</span>(<span class="params">theta,X,y</span>):</span></span><br><span class="line">    diff = np.dot(X,theta) - y</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>/<span class="number">2</span>*m) * np.dot(diff.T,diff)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义代价函数对应的梯度函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_function</span>(<span class="params">theta,X,y</span>):</span></span><br><span class="line">     diff = np.dot(X,theta) - y</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>/m * np.dot(X.T,diff)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度下降迭代</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span>(<span class="params">X,y,alpha</span>):</span></span><br><span class="line">    theta = np.array([<span class="number">1</span>,<span class="number">1</span>]).reshape(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">    gradient = gradient_function(theta,X,y)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> <span class="built_in">all</span>(<span class="built_in">abs</span>(gradient) &lt;= <span class="number">1e-5</span>):</span><br><span class="line">        theta = theta - alpha*gradient</span><br><span class="line">        gradient = gradient_function(theta,X,y)</span><br><span class="line">    <span class="keyword">return</span> theta</span><br></pre></td></tr></table></figure><h3 id="3-Algorithm"><a href="#3-Algorithm" class="headerlink" title="3. Algorithm"></a>3. Algorithm</h3><p>一般线性回归函数的假设函数为</p><script type="math/tex; mode=display">h_{\theta}=\sum_{j=0}^n\theta_jx_j</script><p>对应的损失函数形式为</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{2m}\sum_{i=1}^m(h_\theta(x_i)-y_i)^2</script><p>下图为一个二维参数 $(\theta_0,\theta_1)$ 组对应损失函数的可视化图</p><p><img src="https://i.loli.net/2020/10/05/MS2PxbVNDIzeYyT.png" alt="image-20201005145948910" style="zoom:50%;" /></p><p>接下来, 我们介绍三种不同的梯度下降算法:</p><ul><li><strong>批量梯度下降法 (Batch Gradient Descent)</strong></li><li><strong>随机梯度下降法 (Stochastic Gradient Descent)</strong></li><li><strong>小批量梯度下降法 (Mini-batch Gradient Descent)</strong></li></ul><h4 id="3-1-Batch-Gradient-Descent"><a href="#3-1-Batch-Gradient-Descent" class="headerlink" title="3.1 Batch Gradient Descent"></a>3.1 Batch Gradient Descent</h4><p>批量梯度下降法 (Batch Gradient Descent, 简称BGD) 是梯度下降法最原始的形式, 它的具体思路是在更新每一参数时都使用所有的样本来进行更新, 其数学形式如下:</p><p><strong>Step 1: 对上述的损失函数求偏导</strong></p><script type="math/tex; mode=display">\frac{\delta J(\theta)}{\delta\theta_j}=\frac{1}{m}\sum_{i=1}^m(h_{\theta}(x_i)-y_i)x_j</script><p><strong>Step 2: 由于是最小化风险函数，所以按照每个参数 $\theta$ 的梯度负方向来更新每个 $\theta$</strong></p><script type="math/tex; mode=display">\theta_{j_{new}}=\theta_{j_{old}}-\frac{1}{m}\sum_{i=1}^m(h_{\theta}(x_i)-y_i)x_j</script><p><strong>具体的伪代码形式为</strong></p><script type="math/tex; mode=display">\begin{aligned}\mathbf{repeat}&\{ \\&\theta_{j_{new}}=\theta_{j_{old}}-\frac{1}{m}\sum_{i=1}^m(h_{\theta}(x_i)-y_i)x_j\\&(for\ every\ j=0,...,n)\\\}\end{aligned}</script><p>从上面公式可以注意到, 它得到的是一个全局最优解, 但是每迭代一步, 都要用到训练集所有的数据, 如果样本数目 $m$ 很大, 那么可想而知这种方法的迭代速度! 所以, 这就引入了另外一种方法, 随机梯度下降.</p><ul><li><strong>优点:</strong> 对于严格凸函数而言, 它得到的是一个<strong>全局最优解</strong>, 且易于理解和<strong>并行实现</strong>;</li><li><strong>缺点:</strong> 当样本数目很多时, 训练过程会很慢, 因为每一次计算梯度 (也就是更新参数) 的时候都需要所有的样本;</li></ul><p>从迭代的次数上来看, <strong>BGD迭代的次数相对较少.</strong> 其迭代的收敛曲线示意图可以表示如下:</p><p><img src="https://i.loli.net/2020/10/05/APwDbIqN3Gz6M7Q.png" alt="image-20201005152031253" style="zoom:50%;" /></p><h4 id="3-2-Stochastic-Gradient-Descent"><a href="#3-2-Stochastic-Gradient-Descent" class="headerlink" title="3.2 Stochastic Gradient Descent"></a>3.2 Stochastic Gradient Descent</h4><p>由于批量梯度下降法在更新每一个参数时, 都需要所有的训练样本, 所以训练过程会随着样本数量的加大而变得异常的缓慢. 随机梯度下降法 (Stochastic Gradient Descent, 简称SGD) 正是为了解决批量梯度下降法这一弊端而提出的.</p><p>它是利用<strong>每个样本</strong>的<strong>损失函数</strong>对 $\theta$ 求偏导得到对应的梯度, 来更新 $\theta$:</p><script type="math/tex; mode=display">\theta_{j_{new}}=\theta_{j_{old}}-\alpha(h_{\theta}(x_i)-y_i)x_j</script><p><strong>具体的伪代码形式为</strong></p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201220015307108.png" alt="image-20201220015307108" style="zoom:50%;" /></p><p>随机梯度下降是通过每个样本来迭代更新一次, 如果样本量很大的情况 (例如几十万), 那么可能只用其中几万条或者几千条的样本, 就已经将theta迭代到最优解了, 对比上面的批量梯度下降, 迭代一次需要用到十几万训练样本, 一次迭代不可能最优, 如果迭代10次的话就需要遍历训练样本10次. 但是, SGD伴随的一个问题是噪音较BGD要多, 使得SGD并不是每次迭代都向着整体最优化方向.</p><ul><li><strong>优点:</strong> 训练速度快;</li><li><strong>缺点:</strong> 准确度下降, 不易于并行实现;</li></ul><blockquote><p>  注:</p><p>  一般在生产中的场景 objective function 都不是单峰的, 自然, BGD 就不一定做到全局最优, 反而是sgd更可能跳出局部最优.</p></blockquote><p>从迭代的次数上来看, SGD迭代的次数较多, 在解空间的搜索过程看起来很盲目. 其迭代的收敛曲线示意图可以表示如下:</p><p><img src="https://i.loli.net/2020/10/05/NGiwXMVInc16aq3.png" alt="image-20201005160111136" style="zoom:50%;" /></p><h4 id="3-3-Mini-batch-Gradient-Descent"><a href="#3-3-Mini-batch-Gradient-Descent" class="headerlink" title="3.3 Mini-batch Gradient Descent"></a>3.3 Mini-batch Gradient Descent</h4><p>有上述的两种梯度下降法可以看出, 其各自均有优缺点, 那么能不能在两种方法的性能之间取得一个折衷呢? 即, 算法的训练过程比较快, 而且也要保证最终参数训练的准确率, 而这正是小批量梯度下降法 (Mini-batch Gradient Descent, 简称MBGD) 的初衷.</p><p>MBGD 在每次更新参数时使用 b 个样本 (b一般为10), 其具体的伪代码形式为:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201220015703862.png" alt="image-20201220015703862" style="zoom:50%;" /></p><h3 id="4-Conclusion"><a href="#4-Conclusion" class="headerlink" title="4. Conclusion"></a>4. Conclusion</h3><ol><li>批梯度下降每次更新使用了所有的训练数据, 最小化损失函数, <strong>如果只有一个极小值, 那么批梯度下降是考虑了训练集所有数据, 是朝着最小值迭代运动的, </strong>但是缺点是如果样本值很大的话, 更新速度会很慢.</li><li>随机梯度下降在每次更新的时候, 只考虑了一个样本点, 这样会大大加快训练数据, 也恰好是批梯度下降的缺点, 但是有可能由于训练数据的噪声点较多, <strong>那么每一次利用噪声点进行更新的过程中, 就不一定是朝着极小值方向更新, 但是由于更新多轮, 整体方向还是大致朝着极小值方向更新, 又提高了速度.</strong></li><li>小批量梯度下降法是<strong>为了解决批梯度下降法的训练速度慢, 以及随机梯度下降法的准确性综合而来, 但是这里注意, 不同问题的batch是不一样的.</strong></li></ol><p><img src="https://i.loli.net/2020/10/05/mSfG68M3LPUdnHq.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Optimization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解线性回归(Linear Regression)</title>
      <link href="2020/11/12/%E8%AF%A6%E8%A7%A3%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-Linear-Regression/"/>
      <url>2020/11/12/%E8%AF%A6%E8%A7%A3%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-Linear-Regression/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Notation"><a href="#1-Notation" class="headerlink" title="1. Notation"></a>1. Notation</h3><p>给定由 d 个属性描述的示例 $x=(x_1;x_2;…;x_d)$, 其中 $x_i$ 是 $x$ 在第 $i$ 个属性上的取值, 线性模型 (linear model) 试图学得一个通过属性的线性组合来进行预测的函数, 即</p><script type="math/tex; mode=display">f(x)=w_1x_1+w_2x_2+...+w_dx_d+b</script><p>一般用向量形式写成</p><script type="math/tex; mode=display">f(x)=w^Tx+b</script><p>其中 $w=(w_1;w_2;…;w_d)$</p><blockquote><p>  注: 我们可以观测到 $x,w$ 的向量表示中都有分号 <code>;</code>. 这说明其是一个列向量. 因此 $x^T,w^T$ 则是行向量.</p></blockquote><h3 id="2-Standard-Linear-Regression"><a href="#2-Standard-Linear-Regression" class="headerlink" title="2. Standard Linear Regression"></a>2. Standard Linear Regression</h3><h4 id="2-1-Simple-LR"><a href="#2-1-Simple-LR" class="headerlink" title="2.1 Simple LR"></a>2.1 Simple LR</h4><p>这种情况下, 输入属性的数目只有一个. 为便于讨论, 此时我们忽略关于属性的下标, 即 $D=\{(x_i,y_i)\}_{i=1}^m$, 其中 $x_i\in\mathbb{R}$. </p><p>简单线性回归试图学得</p><script type="math/tex; mode=display">f(x_i)=wx_i+b,\quad thus \ f(x_i)\approx y_i</script><p>如何确定 $w$ 和 $b$ 呢? 我们可以通过<strong>最小化均方误差 (mean squared error, MSE)</strong> 来得到 $w$ 和 $b$, 即</p><p>基于均方误差最小化来进行模型求解的方法称为 <strong>“最小二乘法 (least square method)”</strong>. 在线性回归中, 最小二乘法就是试图找到一条直线, 使所有样本到直线上的欧氏距离之和最小.</p><p>求解 $w$ 和 $b$ 使 $E_{(w,b)}=\frac{1}{2}\sum_{i=1}^m(y_i-wx_i-b)^2$ 最小化的过程, 称为线性回归模型的最小二乘 <strong>“参数估计 (parameter estimation)”</strong>. 我们可以将 $E_{(w,b)}$ 分别对 $w$ 和 $b$ 求导, 得到</p><script type="math/tex; mode=display">\frac{\delta E(w,b)}{\delta w}=\sum_{i=1}^m(y_i-wx_i-b)x_i \\\frac{\delta E(w,b)}{\delta b}=\sum_{i=1}^m(y_i-wx_i-b)</script><p>然后令上面两个式子为零可得到 $w$ 和 $b$ 最优解的<strong>闭式 (closed-form) 解</strong>.</p><blockquote><p>  注:</p><p>  这里 $E_{(w,b)}$ 是关于 $w$ 和 $b$ 的<strong>凸函数</strong>, 当它关于 $w$ 和 $b$ 的导数均为零时, 我们能得到 $w$ 和 $b$ 的最优解.</p><p>  对于曲线 $[a,b]$ 上定义的函数 $f$, 若它对区间的任意两点 $x_1,x_2$ 均有 $f(\frac{x_1+x_2}{2})\le\frac{f(x_1)+f(x_2)}{2}$, 则称 $f$ 为区间 $[a,b]$ 上的凸函数.</p><p>  对实数集上的函数, 可以通过求二阶导数来判别. 若二阶导数在区间上非负, 则称为凸函数; 若二阶导数在区间上恒大于 0, 则称为严格凸函数.</p></blockquote><h4 id="2-2-Multivariate-LR"><a href="#2-2-Multivariate-LR" class="headerlink" title="2.2 Multivariate LR"></a>2.2 Multivariate LR</h4><p>在实际回归问题中, 更一般的情形是如本节开头的数据集 $D$, 样本由 $d$ 个属性描述. 此时我们试图学得</p><script type="math/tex; mode=display">f(x_i)=w^Tx_i,\quad thus \ f(x_i)\approx y_i</script><blockquote><p>  注: 我们此时将 $b$ 包括进了 $w$.</p></blockquote><p>那我们如何求解最优的 $w$ 呢? </p><p>我们可以同样适用均方误差来求解, 即</p><script type="math/tex; mode=display">f(w)=\frac{1}{2}\sum_{i=1}^m(y_i-x_i^Tw)^2</script><p>对于上述式子 $f(w)$ 可以通过梯度下降等方法得到最优解. 但是使用矩阵表示将会是的求解和程序更为简单:</p><script type="math/tex; mode=display">f(w)=(y-Xw)^T(y-Xw)</script><p>将 $f(w)$ 对 $w$ 求导可得:</p><script type="math/tex; mode=display">\frac{\delta f(w)}{\delta w}=-2X^T(y-Xw)</script><p>使其等于0, 我们便可得到:</p><script type="math/tex; mode=display">\hat{w}=(X^TX)^{-1}X^Ty</script><p>然而在现实操作中, 会出现 $X^TX$ 不可逆的情况. 如果这种情况出现了, 我们一般考虑以下两种情况:</p><ul><li>移除冗余特征, 一些特征存在线性依赖;</li><li>特征太多时, 要删除一些特征. 例如 (m&lt;n), 对于小样本数据使用正则化;</li></ul><h4 id="2-3-Probabilistic-Explanation"><a href="#2-3-Probabilistic-Explanation" class="headerlink" title="2.3 Probabilistic Explanation"></a>2.3 Probabilistic Explanation</h4><p>关于: 为何在进行线性回归时, 选择用最小二乘拟合 (距离的平方和) 来进行, 而不是选用其他的模型 (比如三次方或四次方)?</p><p>我们更新一下假设函数, 使之变为:</p><script type="math/tex; mode=display">y_{i}=\theta^Tx_{i}+ε_{i}</script><p>其中, $ε_{i}$ 是误差项, 表示未捕获的特征 (unmodeled effects), 比如房子存在壁炉也影响价格, 或者其他的一些随机噪音 (random noise).</p><p>一般，会假设误差项$ε_{i}∼N(0,σ^2)$ (满足正态分布), 也就是:</p><p>关于为什么假设正态分布的解释:</p><ol><li>便于数学运算;</li><li>很多独立分布的变量之间相互叠加后会趋向于正态分布 (中心极限定理), 在大多数情况下能成立;</li></ol><script type="math/tex; mode=display">P(ε_{i})=\frac{1}{\sqrt{2\pi}\sigma}\exp(-\frac{(ε_{i})^2}{2\sigma^2})</script><p>所以, $y^{(i)}$ 的后验分布:</p><script type="math/tex; mode=display">P(y_{i}|x_i;\theta)=\frac{1}{\sqrt{2\pi}}\exp(-\frac{(y_i-\theta^Tx_i)^2}{2\sigma^2})\sim N(\theta^Tx_i,\sigma^2)</script><p>之后, 进行极大似然估计 (MLE): $\max L(θ)$, 即选择合适的 $θ$, 使得$y^{(i)}$ 对于 $x^{(i)}$ 出现的概率最高 (有一些存在即合理的感觉), 其中 $L(θ)$ 的定义如下:</p><script type="math/tex; mode=display">L(\theta)=P(y|x;\theta)=\prod_{i=1}^{m}P(y_i|x_i;\theta)=\prod_{i=1}^m\frac{1}{\sqrt{2\pi}}\exp(-\frac{(y_i-\theta^Tx_i)^2}{2\sigma^2})</script><p>那么, 为了计算方便, 我们取对数:</p><script type="math/tex; mode=display">LL(\theta)=\log L(\theta)=\sum_{i=1}^m\log P(y_i|x_i;\theta)=m\cdot\log\frac{1}{\sqrt{2\pi}\sigma}-\sum_{i=1}^m\frac{(y_i-\theta^Tx_i)^2}{2\sigma^2}</script><p>于是, 极大似然估计变为最小化:</p><script type="math/tex; mode=display">\sum_{i=1}^m\frac{(y_i-\theta^Tx_i)^2}{2\sigma^2}</script><p>也即之前线性回归所需进行最小二乘拟合的 $J(θ)$.</p><h4 id="2-4-Code"><a href="#2-4-Code" class="headerlink" title="2.4 Code"></a>2.4 Code</h4><p>数据集来源: <a href="http://archive.ics.uci.edu/ml/datasets/Abalone">http://archive.ics.uci.edu/ml/datasets/Abalone</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 加载数据</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    X, Y = [], []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            splited_line = [<span class="built_in">float</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> line.split()]</span><br><span class="line">            x, y = splited_line[: -<span class="number">1</span>], splited_line[-<span class="number">1</span>]</span><br><span class="line">            X.append(x)</span><br><span class="line">            Y.append(y)</span><br><span class="line">    X, Y = np.matrix(X), np.matrix(Y).T</span><br><span class="line">    <span class="keyword">return</span> X, Y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">standarize</span>(<span class="params">X</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 中心化 &amp; 标准化数据 (零均值, 单位标准差)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    std_deviation = np.std(X, <span class="number">0</span>)</span><br><span class="line">    mean = np.mean(X, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> (X - mean)/std_deviation</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">std_linreg</span>(<span class="params">X, Y</span>):</span></span><br><span class="line">    xTx = X.T*X</span><br><span class="line">    <span class="keyword">if</span> np.linalg.det(xTx) == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">&#x27;xTx is a singular matrix&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">return</span> xTx.I*X.T*Y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_corrcoef</span>(<span class="params">X, Y</span>):</span></span><br><span class="line">    <span class="comment"># X Y 的协方差</span></span><br><span class="line">    cov = np.mean(X*Y) - np.mean(X)*np.mean(Y)</span><br><span class="line">    <span class="keyword">return</span> cov/(np.var(X)*np.var(Y))**<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;__main__&#x27;</span> == __name__:</span><br><span class="line">    <span class="comment"># 加载数据</span></span><br><span class="line">    X, Y = load_data(<span class="string">&#x27;abalone.txt&#x27;</span>)</span><br><span class="line">    X, Y = standarize(X), standarize(Y)</span><br><span class="line">    <span class="comment"># 增加 bias</span></span><br><span class="line">    X = np.insert(X,<span class="number">0</span>,<span class="number">1</span>,axis=<span class="number">1</span>)</span><br><span class="line">    w = std_linreg(X, Y)</span><br><span class="line">    Y_prime = X*w</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;w: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(w))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算相关系数</span></span><br><span class="line">    corrcoef = get_corrcoef(np.array(Y.reshape(<span class="number">1</span>, -<span class="number">1</span>)),</span><br><span class="line">                            np.array(Y_prime.reshape(<span class="number">1</span>, -<span class="number">1</span>)))</span><br><span class="line">    print(<span class="string">&#x27;Correlation coeffient: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(corrcoef))</span><br></pre></td></tr></table></figure><p>在例子中我们计算了相关系数, 这是用来判断模型预测能力好或坏的指标. 换句话说, 我们需要计算得到的 $y$ 的值向量与实际 $y$ 值向量的匹配程度, 也就是计算相关系数 Correlation Coefficient. 相关系数的计算公式:</p><script type="math/tex; mode=display">r(X,Y)=\frac{Cov(X,Y)}{\sigma_X\sigma_Y}</script><p>也就是两个数据序列的协方差并除上各自的标准差, 本质上就是一种剔除了两个变量量纲影响, 标准化后的特殊协方差. 而协方差便是衡量两个变量变化趋势是否相似的一种方法, 是同向变化(同时变大或变小)还是反向变化(一个变大一个变小), 同向或者反向的程度如何, 计算公式如下:</p><script type="math/tex; mode=display">Cov(X,Y)=E[(X-E[X])(Y-E[Y])]</script><p>通过公式可以看出, 如果对于向量中的每个 $x,y$ 同时大于或同时小于各自的期望值, 协方差为正, 相反则为负. 可见如果协方差越大相似程度就越高, 协方差越小相似程度就越小. 也可以看到如果 $X,Y$ 相同, 协方差就是方差, 也就是方差是一种特殊情况下的协方差. </p><h3 id="3-Local-Weighted-Linear-Regression"><a href="#3-Local-Weighted-Linear-Regression" class="headerlink" title="3. Local Weighted Linear Regression"></a>3. Local Weighted Linear Regression</h3><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201219181452545.png" alt="image-20201219181452545" style="zoom:50%;" /></p><p>上面的数据点事通过公式 $y=3+1.7x+0.1\sin(30x)$ 添加噪声生成的数据, 而标准的线性回归是一种无偏差估计, 在计算所有点的时候都是无偏差的计算误差并通过优化方法优化误差, 如果针对不同的点能够对误差进行调整便可以一定程度上避免标准线性回归带来的欠拟合现象.</p><p>也就是引入偏差来降低预测的均方误差, 本部分总结下局部加权线性回归的方法. 当我们获取某个 $x$ 的预测值的时候，我们需要计算回归系数 $w$, 但是如果针对样本中的数据, 距离 $x$ 越近我们就给个越大的权重, <strong>如果距离越远就给一个小的权重</strong>, 这样就会使得针对 $x$ 的预测值 $y_{predict}$ 能够更贴合样本数据.</p><p>当我们需要对数据点 $x$ 相应的目标值进行预测的时候, 我们需要给样本中的每个点赋予一个权重值 $w_i$ (为了区分权重和回归系数，在这里用 $\theta$ 表示回归系数, $w$ 表示权重), 那么平方误差的表达式就变成:</p><script type="math/tex; mode=display">f(\theta)=\sum_{i=1}^mw_i(y_i-x_i^T\theta)^2</script><p>通过矩阵可以表示成:</p><script type="math/tex; mode=display">f(\theta)=(y-X\theta)^TW(y-X\theta)</script><p>计算 $f(\theta)$ 对 $\theta$ 求导可得:</p><script type="math/tex; mode=display">\frac{\delta f(\theta)}{\delta\theta}=-2X^TW(y-X\theta)=0 \\\hat{\theta}=(X^TWX)^{-1}X^TWy</script><p>通过上面的公式, 对于任意给定的未知数据可以计算出对应的回归系数 $\theta$, 并得到相应的预测值 $y_{predict}$, 其中 $W$ 是一个对角矩阵, 对角线上的元素 $w_{ii}$ 对应样本点 $x_i$ 的权重值. </p><h4 id="3-1-Gaussian-Kernel"><a href="#3-1-Gaussian-Kernel" class="headerlink" title="3.1 Gaussian Kernel"></a>3.1 Gaussian Kernel</h4><p>那么权重的表达式又是怎样的呢, 我们需要赋予距离给定 $x$ 的样本点的权重越高, LWLR 使用核来对附近的点赋予更高的权重, 最常用的是高斯核函数, 对应表达式如下:</p><script type="math/tex; mode=display">w_{ii}=\exp(\frac{|x_i-x|^2}{-2k^2})</script><p>通过公式可以看到如果 $x_i$ 距离 $x$ 的距离越小, $w_{ii}$ 就会越大, 其中参数 $k$ 决定了权重的大小. $k$ 越大权重差距就越小, $k$ 越小权重差距就很, 大, 仅有局部的点参与进回归系数的求取, 其他距离较远的权重都趋近于零. 如果 $k$ 趋近于无穷大, 所有权重都趋近于1, $W$ 也就近似等于单位矩阵, 局部加权线性回归变成标准的无偏差线性回归, 会造成欠拟合的现象. 当 $k$ 很小的时候, 距离较远的样本点无法参与回归参数的求取, 会造成过拟合的现象.</p><h4 id="3-2-Code"><a href="#3-2-Code" class="headerlink" title="3.2 Code"></a>3.2 Code</h4><p>数据集: <a href="https://raw.githubusercontent.com/PytLab/MLBox/master/linear_regression/ex0.txt">https://raw.githubusercontent.com/PytLab/MLBox/master/linear_regression/ex0.txt</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    加载数据</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    X, Y = [], []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            splited_line = [<span class="built_in">float</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> line.split()]</span><br><span class="line">            x, y = splited_line[: -<span class="number">1</span>], splited_line[-<span class="number">1</span>]</span><br><span class="line">            X.append(x)</span><br><span class="line">            Y.append(y)</span><br><span class="line">    X, Y = np.matrix(X), np.matrix(Y).T</span><br><span class="line">    <span class="keyword">return</span> X, Y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_corrcoef</span>(<span class="params">X, Y</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    X Y 的协方差</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span> </span><br><span class="line">    cov = np.mean(X*Y) - np.mean(X)*np.mean(Y)</span><br><span class="line">    <span class="keyword">return</span> cov/(np.var(X)*np.var(Y))**<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lwlr</span>(<span class="params">x,X,Y,k</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    局部加权线性回归, 给定一个点, 获取相应权重矩阵并返回回归系数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n_samples,_ = X.shape</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创造针对 x 的权重矩阵</span></span><br><span class="line">    W = np.matrix(np.zeros((n_samples,n_samples)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_samples):</span><br><span class="line">        xi = np.array(X[i])</span><br><span class="line">        x = np.array(x)</span><br><span class="line">        W[i, i] = np.exp((np.linalg.norm(x - xi))/(-<span class="number">2</span>*k**<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取此点相应的回归系数</span></span><br><span class="line"></span><br><span class="line">    xWx = X.T*W*X</span><br><span class="line">    <span class="keyword">if</span> np.linalg.det(xWx) == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">&#x27;xWx is a singular matrix&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    w = xWx.I*X.T*W*Y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;__main__&#x27;</span> == __name__:</span><br><span class="line">    k = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line">    X, Y = load_data(<span class="string">&#x27;ex0.txt&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    y_prime = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> X.tolist():</span><br><span class="line">        w = lwlr(x, X, Y, k).reshape(<span class="number">1</span>, -<span class="number">1</span>).tolist()[<span class="number">0</span>]</span><br><span class="line">        y_prime.append(np.dot(x, w))</span><br><span class="line"></span><br><span class="line">    corrcoef = get_corrcoef(np.array(Y.reshape(<span class="number">1</span>, -<span class="number">1</span>)), np.array(y_prime))</span><br><span class="line">    print(<span class="string">&#x27;Correlation coefficient: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(corrcoef))</span><br><span class="line"></span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制数据点</span></span><br><span class="line">    x = X[:, <span class="number">1</span>].reshape(<span class="number">1</span>, -<span class="number">1</span>).tolist()[<span class="number">0</span>]</span><br><span class="line">    y = Y.reshape(<span class="number">1</span>, -<span class="number">1</span>).tolist()[<span class="number">0</span>]</span><br><span class="line">    ax.scatter(x, y,s=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制拟合直线</span></span><br><span class="line">    x, y = <span class="built_in">list</span>(<span class="built_in">zip</span>(*<span class="built_in">sorted</span>(<span class="built_in">zip</span>(x, y_prime), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])))</span><br><span class="line">    ax.plot(x, y, c=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>1) 当 k=0.5, 基本上就是无偏差的标准线性回归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Correlation coefficient: <span class="number">0.9869292425124011</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201219214623357.png" alt="image-20201219214623357" style="zoom: 57%;" /></p><p>2) 当 k=0.1, 可以较好的反应数据的潜在规律</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Correlation coefficient: <span class="number">0.9978904026105981</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201219214715053.png" alt="image-20201219214715053" style="zoom:50%;" /></p><p>3) 当 k=0.02, 拟合所得曲线较多的考虑了噪声数据导致过拟合的现象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Correlation coefficient: <span class="number">0.9998256819814548</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201219214858931.png" alt="image-20201219214858931" style="zoom:39%;" /></p><h3 id="4-Ridge-Regression"><a href="#4-Ridge-Regression" class="headerlink" title="4. Ridge Regression"></a>4. Ridge Regression</h3><p>我们已经知道标准线性回归的参数可以通过 $w=(X^TX)^{-1}X^Ty$ 进行求解. 但是 $X^TX$ 不一定总是可逆. 在种情况下, 我们需要对最初的标准线性回归做一定的变化使原先无法求逆的矩阵变得非奇异, 使得问题可以稳定求解. 我们可以通过缩减的方式来处理这些问题例如岭回归和LASSO.</p><p>我们首先介绍一下数据的中心化和标准化, 在回归问题和一些机器学习算法中通常要对原始数据进行中心化和标准化处理, 也就是需要将数据的均值调整到0, 标准差调整为1, 计算过程很简单就是将所有数据减去平均值后再除以标准差:</p><script type="math/tex; mode=display">x_i'=\frac{x_i-\mu}{\sigma}</script><p>之所以需要进行中心化其实就是个平移过程, 将所有数据的中心平移到原点. 而标准化则是使得所有数据的不同特征都有相同的尺度Scale, 这样在使用梯度下降法以及其他方法优化的时候不同特征参数的影响程度就会一致了.</p><p>如下图所示，可以看出得到的标准化数据在每个维度上的尺度是一致的:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/original-zeroed-normalized.jpeg" alt="Notes on Feature Preprocessing: The What, the Why, and the How" style="zoom:50%;" /></p><p>现在我们开始介绍<strong>岭回归 (Ridge Regression)</strong></p><p>标准最小二乘法优化问题: </p><script type="math/tex; mode=display">f(w)=\sum_{i=1}^m(y_i-x_i^Tw)^2</script><p>也可以通过矩阵表示:</p><script type="math/tex; mode=display">f(w)=(y-Xw)^T(y-Xw)</script><p>得到归回归系数为:</p><script type="math/tex; mode=display">\hat{w}=(X^TX)^{-1}X^Ty</script><p>这个问题解存在且唯一的条件就是 $X$ 列满秩: $rank(X)=dim(X)$</p><p>即使 $X$ 列满秩, 但是当数据特征中存在共线性, 即相关性比较大的时候, 会使得标准最小二乘求解不稳定, $X^TX$ 的行列式接近零, 计算 $X^TX$ 的时候误差会很大. 这个时候我们需要在 cost function 上添加一个惩罚项 $\lambda\sum_{i=1}^nw_i^2$, 也就是 L2 正则化. 这个时候的cost function的形式就为:</p><script type="math/tex; mode=display">f(x)=\sum_{i=1}^m(y_i-x_i^Tw)^2+\lambda\sum_{i=1}^nw_i^2</script><p>将岭回归系数用矩阵的形式表示:</p><script type="math/tex; mode=display">\hat{w}=(X^TX+\lambda I)^{-1}X^Ty</script><p>可以看到，就是通过将 $X^TX$ 加上一个类单位矩阵变成非奇异矩阵并可以进行求逆运算. 更多正则化相关内容, 可以查看我的相关文章.</p><p><strong>岭回归的一些性质</strong></p><ol><li>当岭参数 $\lambda=0$ 时, 得到的解是最小二乘解.</li><li>当岭参数 $\lambda$ 趋向更大时, 岭回归系数 $w_i$ 向于0.</li></ol><h4 id="4-1-Code"><a href="#4-1-Code" class="headerlink" title="4.1 Code"></a>4.1 Code</h4><p>数据集: <a href="http://archive.ics.uci.edu/ml/datasets/Abalone">http://archive.ics.uci.edu/ml/datasets/Abalone</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    加载数据</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    X, Y = [], []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            splited_line = [<span class="built_in">float</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> line.split()]</span><br><span class="line">            x, y = splited_line[: -<span class="number">1</span>], splited_line[-<span class="number">1</span>]</span><br><span class="line">            X.append(x)</span><br><span class="line">            Y.append(y)</span><br><span class="line">    X, Y = np.matrix(X), np.matrix(Y).T</span><br><span class="line">    <span class="keyword">return</span> X, Y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_corrcoef</span>(<span class="params">X, Y</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    X Y 的协方差</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span> </span><br><span class="line">    cov = np.mean(X*Y) - np.mean(X)*np.mean(Y)</span><br><span class="line">    <span class="keyword">return</span> cov/(np.var(X)*np.var(Y))**<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">standarize</span>(<span class="params">X</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 中心化 &amp; 标准化数据 (零均值, 单位标准差)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    std_deviation = np.std(X, <span class="number">0</span>)</span><br><span class="line">    mean = np.mean(X, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> (X - mean)/std_deviation</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ridge_regression</span>(<span class="params">X, y, lambd=<span class="number">0.2</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 获取岭回归系数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    XTX = X.T*X</span><br><span class="line">    m, _ = XTX.shape</span><br><span class="line">    I = np.matrix(np.eye(m))</span><br><span class="line">    w = (XTX + lambd*I).I*X.T*y</span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ridge_traj</span>(<span class="params">X, y, ntest=<span class="number">30</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 获取岭轨迹矩阵</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    _, n = X.shape</span><br><span class="line">    ws = np.zeros((ntest, n))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ntest):</span><br><span class="line">        w = ridge_regression(X, y, lambd=np.exp(i-<span class="number">10</span>))</span><br><span class="line">        ws[i, :] = w.T</span><br><span class="line">    <span class="keyword">return</span> ws</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;__main__&#x27;</span> == __name__:</span><br><span class="line">    ntest = <span class="number">30</span></span><br><span class="line">    <span class="comment"># 加载数据</span></span><br><span class="line">    X, y = load_data(<span class="string">&#x27;abalone.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 中心化 &amp; 标准化</span></span><br><span class="line">    X, y = standarize(X), standarize(y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试数据和训练数据</span></span><br><span class="line">    w_test, errors = [], []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ntest):</span><br><span class="line">        lambd = np.exp(i - <span class="number">10</span>)</span><br><span class="line">        <span class="comment"># 训练数据</span></span><br><span class="line">        X_train, y_train = X[: <span class="number">180</span>, :], y[: <span class="number">180</span>, :]</span><br><span class="line">        <span class="comment"># 测试数据</span></span><br><span class="line">        X_test, y_test = X[<span class="number">180</span>: -<span class="number">1</span>, :], y[<span class="number">180</span>: -<span class="number">1</span>, :]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 岭回归系数</span></span><br><span class="line">        w = ridge_regression(X_train, y_train, lambd)</span><br><span class="line">        error = np.std(X_test*w - y_test)</span><br><span class="line">        w_test.append(w)</span><br><span class="line">        errors.append(error)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选择误差最小的回归系数</span></span><br><span class="line">    w_best, e_best = <span class="built_in">min</span>(<span class="built_in">zip</span>(w_test, errors), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">    print(<span class="string">&#x27;Best w: &#123;&#125;, best error: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(w_best, e_best))</span><br><span class="line"></span><br><span class="line">    y_prime = X*w_best</span><br><span class="line">    <span class="comment"># 计算相关系数</span></span><br><span class="line">    corrcoef = get_corrcoef(np.array(y.reshape(<span class="number">1</span>, -<span class="number">1</span>)),</span><br><span class="line">                            np.array(y_prime.reshape(<span class="number">1</span>, -<span class="number">1</span>)))</span><br><span class="line">    print(<span class="string">&#x27;Correlation coefficient: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(corrcoef))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制岭轨迹</span></span><br><span class="line">    ws = ridge_traj(X, y, ntest)</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">    lambdas = [i-<span class="number">10</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ntest)]</span><br><span class="line">    ax.plot(lambdas, ws)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><strong>岭轨迹图: 不同 $\lambda$ 下各特征回归系数的变化情况.</strong></p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse/image-20201219225347836.png" alt="image-20201219225347836" style="zoom:50%;" /></p><h3 id="5-LASSO"><a href="#5-LASSO" class="headerlink" title="5. LASSO"></a>5. LASSO</h3><p>LASSO(The Least Absolute Shrinkage and Selection Operator)是另一种缩减方法, 将回归系数收缩在一定的区域内. LASSO的主要思想是构造一个一阶惩罚函数获得一个精炼的模型, 通过最终确定一些变量的系数为0进行特征筛选.</p><p>LASSO的惩罚项为:</p><script type="math/tex; mode=display">\sum_{i=1}^n|w_i|\le t</script><p>与岭回归的不同在于, 此约束条件使用了绝对值的一阶惩罚函数代替了平方和的二阶函数. 虽然只是形式稍有不同, 但是得到的结果却又很大差别. 在LASSO中, 当 $\lambda$ 很大的时候，一些系数会随着变为0, 而岭回归却很难使得某个系数<strong>恰好</strong>缩减为0. 具体的几何解释可以查看我的另一篇讲正则化的博文. </p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Supervised Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模型选择与评估</title>
      <link href="2020/11/12/%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9%E4%B8%8E%E8%AF%84%E4%BC%B0/"/>
      <url>2020/11/12/%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9%E4%B8%8E%E8%AF%84%E4%BC%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Basic-Knowledge"><a href="#1-Basic-Knowledge" class="headerlink" title="1. Basic Knowledge"></a>1. Basic Knowledge</h3><p>通常我们把分类错误的样本数占总数的比例称为 <strong>“错误率” (error rate</strong>), 即如果在 m 个样本中有 a 个样本分类错误, 则错误率 $E=a/m$. 相应的, $1-a/m$ 称为 <strong>“精度” (accuracy)</strong>.</p><p><strong>训练误差 (training error)</strong> 或 <strong>经验误差 (empirical error):</strong> 学习器在训练集上的误差.</p><p><strong>泛化误差 (generalizaiton error):</strong> 学习器在测试集上的误差.</p><p><u>很显然, 我们希望得到泛化误差较小的学习器.</u> 但是我们提前是不知道新样本是什么样的, 实际我们能做的就是努力使经验误差最小化. 但是在训练集上做的好, 不代表其能在测试集上做的好. 这就引出了两种现象:</p><ul><li><p><strong>过拟合 (Overfitting)</strong></p><p>学习器把训练样本学得”太好”, 已经把训练样本自身的一些特点当作了所有潜在样本都会具有的一般性质, 这样就会导致泛化性能下降.</p></li><li><p><strong>欠拟合 (Underfitting)</strong></p><p>对训练样本的一般性质尚未学好</p></li></ul><p>欠拟合比较好解决, 麻烦的是过拟合. 实际工作中大多数时候都是在处理过拟合. 各类学习算法都必然带有一些针对过拟合的措施, 然而我们必须认识到, 过拟合是无法避免的, 我们所能做的只是”缓解”. </p><h3 id="2-Model-Evaluation"><a href="#2-Model-Evaluation" class="headerlink" title="2. Model Evaluation"></a>2. Model Evaluation</h3><p>通常, 我们可以通过<strong>测试集 (testing set)</strong> 来测试学习器对新样本的判别能力, 然后以测试集上的<strong>测试误差 (testing error)</strong> 作为泛化误差的近似. 通常我们假设测试样本也是从样本真实分布中<strong>独立同分布采样而得</strong>. 但需注意的是, 测试集应该尽可能与训练集互斥, 即测试样本尽量不在训练集中出现且未在训练过程中使用过.</p><p>可是, 我们只有一个包含 m 个样例的数据集 $D$, 既要训练, 又要测试, 怎么才能做到呢? 答案是: 通过对 $D$ 进行适当的处理, 从中产生出训练集 $S$ 和测试集 $T$. 我们在这里介绍几种常见的做法:</p><ul><li><strong>留出法(hold-out):</strong> 数据量大</li><li><strong>交叉验证法(cross validatation):</strong> 数据量大</li><li><strong>自助法(bootstrapping):</strong> 数据量小</li></ul><h4 id="2-1-Hold-Out"><a href="#2-1-Hold-Out" class="headerlink" title="2.1 Hold-Out"></a>2.1 Hold-Out</h4><p><strong>留出法</strong>直接将数据集 $D$ 划分为两个互斥的集合, 其中一个集合作为训练集 $S$, 另外一个作为测试集 $T$, 即 $D=S\cup T,S\cap T=\emptyset$. 我们在 S 上训练出模型之后, 用 $T$ 来评估器测试误差, 作为对泛化误差的估计.</p><p>对于留出法, 我们需要注意的是要尽量保证 $S$ 和 $T$ 的数据分布的一致性, 避免因数据划分过程中引入额外的偏差而对最终结果产生影响. </p><blockquote><p>  <strong>举个例子, 在分类任务中, 我们至少要保证样本的类别比例相似.</strong></p><p>  如果从采样 (sampling) 的角度来看待数据的划分过程, 则保留类别比例的采样方式通常称为<strong>分层采样 (stratified sampling)</strong>. 我们现在通过对 $D$ 进行分层采样获得 70% 样本的训练集 $S$ 和含 30% 样本的测试集 $T$. 若 $D$ 包含 500 个正例, 500 个反例, 则我们的训练集 $S$ 应该包含 350 个正例和 350 个反例, 而测试集 $T$ 应该包含 150 个正例和 150 个反例.</p><p>  若 $S,T$ 中的样本类别比例差别很大, 则误差估计将由于 $S,T$ 数据分布的差异而产生一定的偏差.</p></blockquote><p>在上面的例子中, 还有一个问题. 在构建 $S$ 或者 $T$ 的时候, 我们可以对 $D$ 进行排序, 然后将前 350 个正例或最后 350 个正例放到训练集中. 这些不同的划分将使我们得到不同的 $S$ 和 $T$, 进而模型评估的结果也会有差别, 因此单次留出法的结果往往不是很可靠. </p><p>所以再实际操作留出法的时候, 我们可能需要进行 100 次随机划分, 每次产生一组 $S,T$ 用于评估, 而最后的结果是这 100 次评估的平均值. 通过这样做, 我们同样可以得到估计结果的标准差.</p><p><strong>Another problem</strong></p><p>尽管我们做了上面的范例操作, 但是同样还存在一个问题. 我们在划分训练集和测试集的时候, 需要指定比例. 试想: 若我们令训练集 $S$ 包含过多的样本, 那么我们训练得到模型可能更接近用 $D$ 训练出来的模型, 但由于 $T$ 比较小, 评估结果可能不够稳定和准确. 同理, 训练集比较小也会出现相应的问题. 但对于这个问题, 我们并没有完美的解决方案, 常见的做法是将大约 2/3 ~ 4/5 的样本用于训练, 剩余样本用于测试.</p><h4 id="2-2-Cross-Validation"><a href="#2-2-Cross-Validation" class="headerlink" title="2.2 Cross Validation"></a>2.2 Cross Validation</h4><p><strong>交叉验证法</strong>先将数据集 $D$ 划分为 k 个大小相似的互斥子集, 即 $D=D_1\cup D_2\cup …\cup D_k,D_i\cap D_j=\emptyset(i\ne j).$ 其中每个子集 $D_i$ 都尽可能保持数据分布的一致性, 即从 $D$ 中通过分层采样得到</p><p>然后, 我们每次使用 $k-1$ 个子集的并集作为训练集, 余下的那个子集作为测试集. 这样我们就能获得 $k$ 组训练/测试集, 从而可以进行 $k$ 次训练和测试, 最终返回的是这 $k$ 个测试结果的均值. $k$ 最常用的取值是 10, 此时称为 10 折交叉验证; 其他常用的 k 值有 5, 20 等.</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/b04c27c5-7e3f-428a-9aa6-bb3ebcd3584c.png" alt="K-fold cross-validation - Mastering Predictive Analytics with scikit-learn  and TensorFlow" style="zoom:50%;" /></p><p>与留出法相似, 将数据集 $D$ 划分为 k 个子集同样存在多种划分方式. 为减小因样本划分不同而引入的差别, $k$ 折交叉验证通常要随机使用不同的划分重复 $p$ 次, 最终的评估结果是这 $p$ 次 $k$ 折交叉验证结果的均值, 例如常见的有 “10 次 10 折交叉验证”.</p><p>假设数据集 $D$ 中包含 $m$ 个样本, 若令 $k=m$, 则得到交叉验证法的一个特例: 留一法 (Leave-One-Out, 简称 LOO). 显然, 留一法不受随机样本划分方式的影响, 因为 $m$ 个样本只有唯一的方式划分 $m$ 个子集 — 每个子集包含一个样本. 留一法使用的训练集与初始数据集相比只少了一个样本, 这就使得在绝大数情况下, 留一法中被实际评估的模型与期望评估的用 $D$ 训练出的模型很相似. 因此, 留一法的评估结果往往被认为比较准确. 然而, 留一法也有其缺陷: 在数据集比较大时, 训练 $m$ 个模型的计算开销可能是难以忍受的 (例如数据集包含 1 百万个样本, 则需训练 1 百万个模型), 而这还是在未考虑算法调参的情况下. </p><h4 id="2-3-Bootstrapping"><a href="#2-3-Bootstrapping" class="headerlink" title="2.3 Bootstrapping"></a>2.3 Bootstrapping</h4><p>我们现在已经大概了解了<strong>留一法</strong>和<strong>交叉验证法</strong>的优缺点. 那么是否存在一个方法: 可以减少训练样本规模不同造成的影响, 同时还能比较高效地进行实验估计呢?</p><p><strong>自助法 (boostrapping)</strong> 是一个比较好的解决方案, 它直接以自助采样法 (bootstrap sampling) 为基础. 给定包含 $m$ 个样本的数据集 $D$, 我们对它进行采样数据集 $D’$: 每次随机从 $D$ 中挑选一个样本, 将其拷贝放入 $D’$, 然后再将该样本放回初始数据集 $D$ 中, 使得该样本在下次采样时仍有可能被采到; 这个过程重复执行 $m$ 次后, 我们就得到了包含 $m$ 个样本的数据集 $D’$, 这就是自助采样的结果. 显然, $D$ 中的一部分样本会在 $D’$ 中多次出现, 而另外一部分样本不出现. 我们可以做一个简单的估计, 样本在 $m$ 次采样中始终不被采到的概率是 $(1-\frac{1}{m})^m$, 取极限得到:</p><script type="math/tex; mode=display">\lim\limits_{m\rightarrow\inf}(1-\frac{1}{m})\approx\frac{1}{e}\approx0.368</script><p>通过自助采样, 初始数据集 $D$ 中约有 36.8% 的样本未出现在采样数据集 $D’$ 中. 于是我们可以将 $D’$ 用作训练集, $D\backslash D’$ 用作测试集.</p><h3 id="3-Parameter-Tuning"><a href="#3-Parameter-Tuning" class="headerlink" title="3. Parameter Tuning"></a>3. Parameter Tuning</h3><p><strong>参数配置不同, 我们得到的模型的性能往往有显著的差别.</strong></p><p>机器学习中很多算法的参数选择往往是在实数范围内取值, 因此, 对每种参数配置都训练出来模型是不可行的. 比较常见的做法, 是对每个参数选定一个范围和变化步长. 但是这样的参数选定往往得到的结果都不是最佳值, <strong>但是这是在计算开销和性能估计之间进行折中的结果</strong>.</p><p>但其实, 在这种折中之后, 调参依然很困难. 举个例子, 我们的算法有 3 个参数, 每个参数仅考虑 5 个候选值, 这样对每一组训练/测试集就有 $5^3=125$ 个模型需要考察. 然而很多机器学习算法往往有很多参数需要设定, 这就意味着我们的调参工程量极大.</p><p>需要注意的是, 我们通常把学得模型在实际使用中遇到的数据成为测试数据, 为了加以区分, 模型评估与选择中用于评估测试的数据集常称为 <strong>验证集 (validation set)</strong>. </p><blockquote><p>  在研究不同算法的泛化性能时, 我们用<strong>测试集</strong>上的判别效果来估计模型在实际使用时的泛化能力.</p><p>  而把<strong>训练数据</strong>另外划分为训练集和验证集, 基于验证集上的性能来进行模型选择和调参.</p></blockquote><h3 id="4-Performance-Measure"><a href="#4-Performance-Measure" class="headerlink" title="4. Performance Measure"></a>4. Performance Measure</h3><p>性能度量反映了任务需求, 在对比不同的模型的能力时, 使用不同的性能度量往往会导致不同的评判结果; 这意味着模型的好坏是相对的, 什么样的模型是好的, 不仅取决于算法和数据, 还取决于任务需求. </p><h4 id="4-1-Error-Rate-and-Accuracy"><a href="#4-1-Error-Rate-and-Accuracy" class="headerlink" title="4.1 Error Rate and Accuracy"></a>4.1 Error Rate and Accuracy</h4><p>本节开头, 在介绍基础知识的时候, 我们就谈到了<strong>错误率</strong>和<strong>精度</strong>. 这是分类任务中最常用的两种性能度量, 既适用于二分类任务, 也适用于多分类任务. </p><p><strong>错误率</strong>是分类错误的样本数占样本总数的比例, <strong>精度</strong>则是分类正确的样本数占样本总数的比例. </p><h4 id="4-2-Precision-Recall-and-F1"><a href="#4-2-Precision-Recall-and-F1" class="headerlink" title="4.2 Precision, Recall and F1"></a>4.2 Precision, Recall and F1</h4><p>错误率和精度虽然常用, 但并不能满足所有任务需求. 以西瓜问题为例, 假定瓜农拉来了一车西瓜, 我们用训练好的模型对这些西瓜进行判别, 显然, 错误率衡量了有多少比例的瓜被判别错误. 但是若我们关心的是<strong>挑出来的西瓜中有多少比例是好瓜</strong>或者<strong>所有好瓜中有多少比例被挑了出来</strong>. 那么错误率就不合适了, 这个时候我们就需要使用其他的性能度量.</p><p>所以, 我们在这里就引入两个新的度量:</p><ul><li><strong>查准率 (precision)</strong></li><li><strong>查全率 (recall)</strong></li></ul><p>对于二分类问题, 可将样例根据其真实类别与学习器预测类别的组合划分为<strong>真正例 (true positive)</strong>, <strong>假正例 (false positive)</strong>, <strong>真反例 (true negative)</strong>, <strong>假反例 (false negative)</strong> 四种情形. 令 <strong>TP, FP, TN, FN</strong> 分别表示其对应的样例数, 则显然有 <strong>TP+FP+TN+FN=样例总数</strong>. 分类结果的 <strong>混淆矩阵 (confusion matrix)</strong> 如下图所示.</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/1*fxiTNIgOyvAombPJx5KGeA.png" alt="Confusion Matrix for Your Multi-Class Machine Learning Model | by Joydwip  Mohajon | Towards Data Science" style="zoom:50%;" /></p><p>查准率 $Precision$ 和查全率 $Recall$ 分别定义为:</p><script type="math/tex; mode=display">Precision=\frac{TP}{TP+FP},\\Recall=\frac{TP}{TP+FN}.</script><p>查准率和查全率是一对矛盾的度量. 一般来说, <strong>查准率高时, 查全率往往偏低</strong>. 例如, 若希望将好瓜尽可能多地选出来, 则可通过增加选瓜的数量来实现, 如果将所有西瓜都选上, 那么所有的好瓜也必然都被选上了, 但这样查准率就会降低. 若希望选出的好瓜中好瓜比例尽可能高, 则可只挑选最有把握的瓜, 但这样就难免会漏掉不少好瓜, 使得查全率较低. 通常只有在一些简单任务中, 才可能使查全率和查准率都很高.</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/7uHAtN2MbcLj7699f4JrD_yxgowXG2zA2cpdp-Tc8u9SHa3vzlykGaLu5Im4ELS_LgKcaa6r_eWxQddmSUDHPkFPs6l2DZQidoX_cgUfZcvh-vFt11pRhK9n.png" alt="img"  /></p><p>$P-R$ 图直观地显示出学习器在样本总体上的查全率, 查准率. 在进行比较时, 若一个学习器的 $P-R$ 曲线被另一个学习器的曲线完全包住, 则可断言后者的性能优于前者. 例如, 上图中学习器 A 的性能优于学习器 C. </p><p><strong>但如果曲线出现交叉的情况</strong>, 我们就需要使用其他方法来综合考虑查准率, 查全率的性能度量. <strong>平衡点 (Break-Even Point, BEP)</strong> 是其中一个方法, 即 $P=R$ 时的取值, 据此, 我们可以说学习器 A 是优于学习器 B 的.</p><p>但 <strong>BEP</strong> 过于简化了, 我们更常用的是 $F1$ 度量. $F1$ 是基于查准率和查全率的调和平均:</p><script type="math/tex; mode=display">\frac{1}{F1}=\frac{1}{2}\cdot(\frac{1}{Precision}+\frac{1}{Recall})</script><p>不同应用对 $P$ 和 $R$ 的重视程度是不同的. 例如, 在商品推荐系统中, 为了尽可能少打扰用户, 我们更希望推荐内容确实是用户感兴趣的, 此时查准率更重要; 而在逃犯信息检索系统中, 更希望尽可能少漏掉逃犯, 此时查全率更重要. 所以, 我们引入 $F1$ 度量的一般形式 $→$ $F_\beta$</p><script type="math/tex; mode=display">\frac{1}{F_{\beta}}=\frac{1}{1+\beta^2}(\frac{1}{Precsion}+\frac{\beta^2}{Recall})</script><blockquote><p>  $\beta$ &gt; 1时, 查全率有更大影响;</p><p>  $\beta$ &lt; 1时, 查准率有更大影响;</p></blockquote><p>很多时候我们有多个二分类混淆矩阵, 例如进行多次训练/测试, 每次得到一个混淆矩阵. 或者我们执行多分类任务, 每两两类别的组合都对应一个混淆矩阵. 总之, 我们希望在 $n$ 个二分类混淆矩阵上综合考察 $P$ 和 $R$. 我们这里有两种做法:</p><ol><li><p><strong>macro-P and macro-R</strong></p><p>一种直接的做法是先在各混淆矩阵上分别计算出查准率和查全率, 再计算平均值, 这样就得到<strong>宏查准率 (macro-P)</strong> 和<strong>宏查全率 (macro-R)</strong>,以及相应的<strong>宏 $F1$ .</strong></p><script type="math/tex; mode=display">macro-P=\frac{1}{n}\sum_{i=1}^nP_i,\\macro-R=\frac{1}{n}\sum_{i=1}^nR_i,\\macro-F1=\frac{2\times macro-P\times macro-R}{macro-P+macro-R}</script></li><li><p><strong>micro-P and micro-R</strong></p><p>我们还可以先将各混淆矩阵的对应元素进行平均, 得到 $TP,FP,TN,FN$ 的平均值, 然后再基于这些平均值计算出:</p><script type="math/tex; mode=display">micro-P=\frac{\overline{TP}}{\overline{TP}+\overline{FP}},\\micro-R = \frac{\overline{TP}}{\overline{TP}+\overline{FN}},\\micro-F1=\frac{2\times micro-P\times micro-R}{micro-P+micro-R}</script></li></ol><h5 id="4-2-1-Plot-Confusion-Matrix"><a href="#4-2-1-Plot-Confusion-Matrix" class="headerlink" title="4.2.1 Plot Confusion Matrix"></a>4.2.1 Plot Confusion Matrix</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">sns.<span class="built_in">set</span>()</span><br><span class="line">f,ax=plt.subplots()</span><br><span class="line">y_true = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">y_pred = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">C2= confusion_matrix(y_true, y_pred,labels=[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># print(C2) #打印出来看看</span></span><br><span class="line">sns.heatmap(C2,annot=<span class="literal">True</span>,ax=ax) <span class="comment">#画热力图</span></span><br><span class="line"></span><br><span class="line">ax.set_title(<span class="string">&#x27;confusion matrix&#x27;</span>) <span class="comment">#标题</span></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;predict&#x27;</span>) <span class="comment">#x轴</span></span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;true&#x27;</span>) <span class="comment">#y轴</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse/image-20201219043532565.png" alt="image-20201219043532565" style="zoom:50%;" /></p><h5 id="4-2-2-Plot-PR-Curve"><a href="#4-2-2-Plot-PR-Curve" class="headerlink" title="4.2.2 Plot PR Curve"></a>4.2.2 Plot PR Curve</h5><p>根据学习器的预测结果对样本进行排序, 排在前面的是学习器认为最可能是正例的样本, 排在最后的是最不可能是正例的样本, 按此顺序逐个将样本作为正例预测, 则每次可以计算出当前的查全率、查准率，以查全率为横轴、查准率为纵轴做图, 得到的查准率-查全率曲线即为P-R曲线. </p><p>也就是说对每个样本预测其为正例的概率, 然后将所有样本按预测的概率进行排序, 然后依次将排序后的样本做为正例进行预测, 从而得到每次预测的查全率与查准率. 这个依次将样本做为正例的过程实际上就是逐步降低样本为正例的概率的域值, 通过降低域值, 更多的样本会被预测为正例, 从而会提高查全率, 相对的查准率可能降低, 而随着后面负样本的增加, 查全率提高缓慢甚至没有提升, 精度降低会更快.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_recall_curve</span><br><span class="line"><span class="keyword">from</span> sklearn.utils.fixes <span class="keyword">import</span> signature</span><br><span class="line"></span><br><span class="line">plt.figure(<span class="string">&quot;P-R Curve&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Precision/Recall Curve&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Recall&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Precision&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#y_true为样本实际的类别，y_scores为样本为正例的概率</span></span><br><span class="line">y_true = np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">y_scores = np.array([<span class="number">0.9</span>, <span class="number">0.75</span>, <span class="number">0.86</span>, <span class="number">0.47</span>, <span class="number">0.55</span>, <span class="number">0.56</span>, <span class="number">0.74</span>, <span class="number">0.62</span>, <span class="number">0.5</span>, <span class="number">0.86</span>, <span class="number">0.8</span>, <span class="number">0.47</span>, <span class="number">0.44</span>, <span class="number">0.67</span>, <span class="number">0.43</span>, <span class="number">0.4</span>, <span class="number">0.52</span>, <span class="number">0.4</span>, <span class="number">0.35</span>, <span class="number">0.1</span>])</span><br><span class="line">precision, recall, thresholds = precision_recall_curve(y_true, y_scores)</span><br><span class="line"></span><br><span class="line"><span class="comment">#print(precision)</span></span><br><span class="line"><span class="comment">#print(recall)</span></span><br><span class="line"><span class="comment">#print(thresholds)</span></span><br><span class="line">plt.plot(recall,precision)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse/image-20201219042544752.png" alt="image-20201219042544752" style="zoom:50%;" /></p><h4 id="4-3-ROC-and-AUC"><a href="#4-3-ROC-and-AUC" class="headerlink" title="4.3 ROC and AUC"></a>4.3 ROC and AUC</h4><p>很多学习器是为测试样本产生一个预测值, 然后将这个预测值与一个分类阈值 (threshold) 进行比较, 若大于阈值则分为正类, 否则为反类. 例如, 神经网络在一般情形下是对每个测试样本预测出一个 [0.0, 1.0] 之间的实值, 然后将这个值与 0.5 进行比较, 大于 0.5 则判为正例, 否则为反例. 这个实值或概率预测结果的好坏, 直接决定了学习器的泛化能力. </p><p><strong>根据这个实值或概率预测结果</strong>, 我们可将测试样本进行<strong>排序</strong>, <strong>最可能</strong>是正例的排在前面, <strong>最不可能</strong>是正例的排在最后面. 这样, 分类过程就相当于在这个排序中以某个<strong>截断点 (cut point)</strong> 将样本分为两部分, 前一部分判作正例, 后一部分则判作反例. 在不同的任务中, 我们可以根据具体的任务绪论来采用不同的截断点.</p><ul><li><strong>排序中靠前的位置进行截断</strong> $\rightarrow$ <strong>更重视 $Precision$</strong></li><li><strong>排序中靠后的位置进行截断</strong> $→$ <strong>更重视 $Recall$</strong></li></ul><h5 id="4-3-1-ROC"><a href="#4-3-1-ROC" class="headerlink" title="4.3.1 ROC"></a>4.3.1 ROC</h5><p><strong>因此排序本身的好坏, 体现了综合考虑学习器在不同任务下的期望泛化性能的好坏.</strong> ROC 曲线则是从这个角度出发来研究泛化性能的有力工具.</p><p>ROC全称是<strong>“受试者工作特征”(Receiver Operating Characteristic)曲线</strong>, 它源于“二战”中用于敌机检测的雷达信号分析技术.</p><p>具体来说, 据说在二战期间, 军队中雷达兵的任务是通过观察显示屏的雷达信号来判断是不是有敌人来了, 在以下两种情况下显示屏上会有雷达信号:</p><ul><li>有敌机来袭 (真实情况下的正例)</li><li>有飞鸟 (真实情况下的负例)</li></ul><p>这个时候不同的雷达兵就可能会报出不同的结果:</p><ul><li>假如这个雷达兵比较谨慎, 只要有信号就报告有敌情 (可以看作更重视“查全率”), 就会增加误报的风险;</li><li>假如这个雷达兵比较大胆, 只要有信号就认为是鸟 (可以看作更重视“查准率”), 就会增加漏报的风险;</li></ul><p>这样就有了我们针对这个问题的“混淆矩阵”:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201219003520752.png" alt="image-20201219003520752" style="zoom: 33%;" /></p><p>理想情况下, 希望每个雷达兵能够好好研究飞机和飞鸟信号的区别, 进行准确的判断. 但是现实问题是, 每个雷达兵的判断标准不一, 谨慎的容易出现误报, 胆大的容易出现漏报. 针对以上问题, 雷达兵的上级管理者汇总了每个雷达兵的汇报特点, 尤其是他们的漏报和误报的概率, 并将这些概率基于二维坐标系绘制成一个图形:</p><ul><li>纵坐标为敏感性(真阳性率): 表示在所有敌人来袭(即真实情况为正例, TP+FN)的事件中, 每个雷达兵准确预报(即TP)的概率;</li><li>横坐标为1-特异性(假阳性率): 表示在所有飞鸟信号(即真实情况为反例, TN+FP)中, 每个雷达兵预报错误(即FP)的概率;</li></ul><p>每个雷达兵的预报标准不同, 所以得到的敏感性和特异性的组合也不同. 一个雷达兵的敏感性和特异性的组合正好在一条曲线上, 这条曲线就是ROC曲线. 到这里就不难理解ROC曲线为什么叫做“受试者工作特征”曲线了, 在这里受试者就是指雷达兵, 绘制这个曲线的目的就是观察雷达兵的工作特征, 所以叫做受试者工作特征曲线. </p><p><strong>在机器学习中, 受试者就是我们的学习器了, 绘制曲线的目的就是观察学习器的工作性能. 不同的截断点会产生不同的 P-R 曲线或 ROC 曲线. 不同的算法模型对于同一个问题也会产生不同的 P-R 曲线或 ROC 曲线.</strong></p><p>现在, 我们来研究如何绘制 <strong>ROC 曲线.</strong></p><p>与我们之前介绍的 P-R 曲线类似, 我们根据学习器的预测结果对样例进行排序, 按此顺序<strong>逐个把样本作为正例进行预测</strong>, 每次计算出两个重要量的值:</p><ul><li><p><strong>真正例率 (True Positive Rate), 也可以称为灵敏度 (Sensitivity)</strong></p><script type="math/tex; mode=display">TPR=\frac{TP}{TP+FN}</script></li><li><p><strong>假正例率 (False Positive Rate), 也可以称为 $1-Specificity$ (特异度)</strong></p><script type="math/tex; mode=display">FPR=\frac{FP}{TN+FP}</script></li></ul><p>以FPR作为横轴, TPR作为纵轴作图, 就得到了“ROC曲线”, 显示ROC曲线的图叫做“ROC图”, 如下所示:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/1*2nd7NTEBosPakccmLVWy9A.png" alt="ROC Curve Transforms the Way We Look at a Classification Problem | by Huy  Bui | Towards Data Science" style="zoom:50%;" /></p><p>对 ROC 曲线的几点解释:</p><ol><li>图中的对角线 (图中的虚线), 对应随机猜测模型, 这种模型没有任何价值;</li><li>$ROC$ 曲线越靠近左上角, 性能越好；</li><li>点(0,1) (左上角), 对应于将所有正例排在所有反例之前的“<strong>理想模型</strong>”, 也就是 <code>FPR=0,TPR=1</code>, 结合上面的公式, 可以得到这时 <code>FP=0,FN=0</code> 模型对所有的样本分类都正确, 也就是将真实为正的预测为正, 真实为反的预测为反.</li><li>$ROC$ 曲线与  $P-R$ 曲线不一样的地方在于, 当正反样例分布发生剧烈变化的时候: <strong>ROC曲线</strong>的形状基本能够保持不变, <strong>P-R曲线</strong>的形状一般会发生剧烈变化.</li></ol><p>对于“理想模型”, 即将所有正例排在所有反例之前, 在画 ROC 曲线过程中, 由于前 $m^+$ 个样例均为真正例, 即从 $(0,0)$ 一直沿纵轴方向增加 $m^+$ 次, 每次增加 $\frac{1}{m^+}$, 到达坐标 (0,1); 接下来 $m^-$ 个样例均为假正例, 即一直沿着横坐标走, 轨迹为从 $(0,0)$ 至 $(1,1)$.</p><p>对于“随机猜测”模型, 即根据预测结果对样例进行排序基本是正例和反例均匀分布 (假如正例个数等于反例个数, 则应该是一个正例一个反例), 在画 ROC 曲线过程中, 向纵方向走一步, 然后向横轴方向走一步, 因此轨迹为从 $(0,0)$ 至 $(1,1)$.</p><p>现实任务中, 通常是利用<strong>有限个</strong>测试样例来绘制ROC图, 此时仅能获得有限个(FPR,TPR)坐标对, 无法产生图中光滑的ROC曲线,绘制过程如下:</p><ol><li>给定 $m^+$ 个正例和 $m^-$ 个反例, 根据学习器预测结果对样例进行排序;</li><li>设置不同的分类阈值:<ul><li>把分类阈值设为最大, 即把所有样例均预测为反例, 此时TPR=FPR=0. 在坐标(0,0)处标记一个点.</li><li>将分类阈值依次设为每个样例的预测值, 即依次将每个样例划分为正例. 设前一个标记点坐标为 $(x,y)$:<ul><li>当前若为真正例 (TP), 则对应标记点的坐标为 $(x,y+\frac{1}{m^+})$</li><li>当前若为假正例(FP), 则对应标记点的坐标为 $(x+\frac{1}{m^-},y)$</li></ul></li><li>最后用线段连接相邻点即得 ROC曲线;</li></ul></li></ol><h5 id="4-3-2-AUC"><a href="#4-3-2-AUC" class="headerlink" title="4.3.2 AUC"></a>4.3.2 AUC</h5><p>进行学习器比较时, 与P-R图类似:</p><ul><li>若一个学习器的ROC曲线被另一个学习器的曲线完全“包住”, 则可断言后者的性能优于前者;</li><li>若两个学习器的ROC曲线发生交叉, 则难以一般性地断言两者哪个更优. 此时如果一定要进行比较, 则较为合理的判据是: 比较ROC曲线下的面积, 即<strong>AUC</strong>(Area Under ROC Curve).</li></ul><p>从定义可知, AUC可通过对ROC曲线下各部分的面积求和而得. 我们假定 ROC 曲线是有坐标为 $\{(x_1,y_1),(x_2,y_2),…,(x_m,y_m)\}$ 的点按序连接而形成, 参见图 (b), 则 AUC 可以估算为:</p><script type="math/tex; mode=display">AUC=\frac{1}{2}\sum_{i=1}^{m-1}(x_{i+1}-x_i)\cdot(y_i+y_{i+1})</script><h5 id="4-3-3-What-are-they"><a href="#4-3-3-What-are-they" class="headerlink" title="4.3.3 What are they?"></a>4.3.3 What are they?</h5><p><strong>看书到此, 可能感觉也知道了什么是 ROC、什么是 AUC, 却又感觉没有理解其含义.</strong></p><p>先梳理四个概念: 真正例率 TPR、假正例率 FPR、真反例率 TNR、假反例率 FNR，各概念的定义如下图所示:</p><p><img src="https://i.loli.net/2020/10/04/i3QDuhnlvfzpgC2.png" alt="image-20201004150516758" style="zoom: 50%;" /></p><blockquote><p>   注: 上图由如下步骤绘出, 首先随机生成了 10000 个样本预测值 (位于 0~1 之间); 然后将每个样本随机指派为正例或反例, 样本预测值越大被指派为正例的概率越大, 反之被指派为反例的概念越大, 指派结果作为对应的 10000 个样本真实标记; 最后将 0~1 划分为 10 个区间, 分别统计每个区间内包含的正例个数和反例个数, 并用直方图表示.</p><p>   由上图可以看出, 无论分类域值设置为多少, 肯定都会有样本被分类错误. 这也是实际当中最常见的情形. 设当前分类域值等于 0.6, 则可以分别得到真正例、假正例、真反例、 假反例的个数 TP、FP、TN、FN, 进而可依次计算出真正例率 TPR、假正例率 FPR、真反 例率 TNR、假反例率 FNR.</p></blockquote><p>实际上, TPR、FPR、TNR、FNR 就是把<strong>混淆矩阵</strong>中的四个值均除以对应的行元素之和, 而行元素之和分别表示正例样本个数和反例样本个数, 因此还可以使用条件概率做如下解释:</p><p><img src="https://i.loli.net/2020/10/04/zFOtJL8BfkrV4Nx.png" alt="image-20201004151407009.png" style="zoom: 50%;" /></p><p>接下来, 我们对 ROC 和 AUC 做几条解释:</p><ol><li>由上图还可以看出, 绘制 ROC 曲线时使用的 TPR 和 FPR, 都是基于分类域值右侧 (大于分类域值) 的样本.</li><li>由式(2.21)可知, $\ell_{rank}$ 表示任取一对正例和反例, 正例预测值小于反例预测值的概率 (简单起见可以暂不考虑预测值相等的情况); 这是因为分母表示所有正例和反例组合对的个数, 分子的求和项表示正例和反例组合对中, 正例预测值小于反例预测值的组合对个数. 显然, 这个概率越小越好 (正例预测值应该大于反例预测值).</li><li>$AUC+\ell_{rank}=1$, 因此 AUC 表示任取一对正例和反例, 正例预测值大于反例预测值的概率. 显然, 这个概率越大越好.</li><li>按西瓜书所述, ROC 曲线绘制的过程. 其实就是将上图中分类域值从右往左（即从 1 到 0）滑动一遍, 依次记录每个域值时的 TPR 和 FPR, 描点画线即可.</li><li>ROC 曲线的绘制所使用的样本集应该是测试集, 即 ROC 曲线上的每个点表示了当取不同分类域值时, 分类器泛化性能的度量 (正例样本的精度 TPR 和反例样本的错误率 FPR).</li></ol><p><strong>AUC的优势</strong>：AUC的计算方法同时考虑了分类器对于正例和反例的分类能力, 在<strong>样本不均衡</strong>的情况下, 依然能够对分类器作出合理的评价. (即AUC对样本类别是否均衡并<strong>不敏感</strong>, 这也是<strong>不均衡样本</strong>通常用AUC评价分类器性能的一个原因)</p><blockquote><p>  <strong>例如</strong>：在反欺诈场景, 设非欺诈类样本为正例, 反例占比很少(假设为0.1%):</p><ul><li>如果使用<strong>准确率</strong>评估, 把所有样本预测为正, 便可以获得99.9%的准确率;</li><li>但是如果使用<strong>AUC</strong>, 把所有样本预测为正例, TPR=FPR=1, AUC仅为0.5, 成功规避了样本不均衡带来的问题;</li></ul></blockquote><h5 id="4-4-4-Plot-Curve"><a href="#4-4-4-Plot-Curve" class="headerlink" title="4.4.4 Plot Curve"></a>4.4.4 Plot Curve</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import the data to play with </span></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">X = iris.data</span><br><span class="line">y = iris.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据二分类</span></span><br><span class="line">X,y = X[y!=<span class="number">2</span>],y[y!=<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加噪声特征</span></span><br><span class="line">random_state = np.random.RandomState(<span class="number">0</span>)</span><br><span class="line">n_samples,n_features = X.shape</span><br><span class="line">X = np.c_[X,random_state.randn(n_samples,<span class="number">200</span>*n_features)]</span><br><span class="line"></span><br><span class="line">cv = StratifiedKFold(n_splits=<span class="number">5</span>) <span class="comment">#导入该模型，后面将数据划分5份</span></span><br><span class="line">classifier = svm.SVC(kernel=<span class="string">&#x27;linear&#x27;</span>,probability=<span class="literal">True</span>,random_state=random_state)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画平均ROC曲线的两个参数</span></span><br><span class="line">mean_tpr = <span class="number">0.0</span>      <span class="comment"># 用来记录画平均ROC曲线的信息</span></span><br><span class="line">mean_fpr = np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, (train,test) <span class="keyword">in</span> <span class="built_in">enumerate</span>(cv.split(X,y)):</span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">    probas_ = classifier.fit(X[train],y[train]).predict_proba(X[test]) <span class="comment"># 训练模型后预测每条样本得到两种结果的概率</span></span><br><span class="line">    fpr,tpr,thresholds =roc_curve(y[test],probas_[:,<span class="number">1</span>])  <span class="comment"># 该函数得到伪正例、真正例、阈值，这里只使用前两个</span></span><br><span class="line"></span><br><span class="line">    mean_tpr += np.interp(mean_fpr,fpr,tpr) <span class="comment"># 插值函数:两点之间的线性取值</span></span><br><span class="line"></span><br><span class="line">    roc_auc = auc(fpr,tpr)</span><br><span class="line">    plt.plot(fpr,tpr,lw=<span class="number">1</span>,label=<span class="string">&quot;K Fold &#123;0&#125; (area=&#123;1:.2f&#125;&quot;</span>.<span class="built_in">format</span>(i,roc_auc))</span><br><span class="line"></span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>],<span class="string">&#x27;--&#x27;</span>,color=(<span class="number">0.6</span>,<span class="number">0.6</span>,<span class="number">0.6</span>),label=<span class="string">&quot;Random&quot;</span>) <span class="comment"># 画对角线</span></span><br><span class="line"></span><br><span class="line">mean_tpr /= cnt <span class="comment"># 求均值</span></span><br><span class="line">mean_tpr[<span class="number">0</span>] = <span class="number">0.0</span> <span class="comment"># 将第一个真正例</span></span><br><span class="line">mean_tpr[-<span class="number">1</span>] = <span class="number">1.0</span> <span class="comment"># 坐标最后一个点为（0,1） </span></span><br><span class="line">mean_auc = auc(mean_fpr, mean_tpr)</span><br><span class="line"></span><br><span class="line">plt.plot(mean_fpr, mean_tpr, <span class="string">&#x27;k--&#x27;</span>,label=<span class="string">&#x27;Mean ROC (area = &#123;0:.2f&#125;)&#x27;</span>.<span class="built_in">format</span>(mean_auc), lw=<span class="number">2</span>)</span><br><span class="line">plt.xlim([-<span class="number">0.05</span>, <span class="number">1.05</span>])     <span class="comment"># 设置x、y轴的上下限，设置宽一点，以免和边缘重合，可以更好的观察图像的整体</span></span><br><span class="line">plt.ylim([-<span class="number">0.05</span>, <span class="number">1.05</span>])</span><br><span class="line">plt.xlabel(<span class="string">&#x27;False Positive Rate&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;True Positive Rate&#x27;</span>)    <span class="comment"># 可以使用中文，但需要导入一些库即字体</span></span><br><span class="line">plt.title(<span class="string">&#x27;Receiver Operating Characteristic Example&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&quot;lower right&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果如下:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201219053227939.png" alt="image-20201219053227939" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>决策树(Decision Tree)</title>
      <link href="2020/11/12/%E5%86%B3%E7%AD%96%E6%A0%91-Decision-Tree/"/>
      <url>2020/11/12/%E5%86%B3%E7%AD%96%E6%A0%91-Decision-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Base-Algorithm-for-Decision-Tree"><a href="#1-Base-Algorithm-for-Decision-Tree" class="headerlink" title="1. Base Algorithm for Decision Tree"></a>1. Base Algorithm for Decision Tree</h3><ol><li><p><strong>Algorithm 1: Memorization Algorithm</strong></p><p>算法的伪代码如下:</p><p><img src="https://i.loli.net/2020/09/03/Na1fAgwnhcDbzuM.png" alt="image-20200903205445477" style="zoom:50%;" /></p><blockquote><p>  我们来思考一个问题: <strong>Does the memorization algorithm learn?</strong></p><p>  答案是 <strong>Yes!</strong> 因为随着数据集的增大, 我们的准确率会越来越高.</p></blockquote></li><li><p><strong>Algorithm 2: Majority Vote Algorithm</strong></p><p>算法伪代码如下:</p><p><img src="https://i.loli.net/2020/09/03/M9Ol41rKap6ycqB.png" alt="image-20200903205526193" style="zoom:50%;" /></p><blockquote><p>   同样我们来看一个问题: <strong>What does the majority vote algorithm return on this training data?</strong></p><p>   <img src="https://i.loli.net/2020/09/03/xv6ge8tXmcV9LKW.png" alt="image-20200903203619463" style="zoom: 25%;" /></p><p>   答案是 <code>+</code></p></blockquote></li><li><p><strong>Algorithm 3: Decision Stump</strong></p><p><strong>核心思想是: Split data based on a single attribute and do majority vote at leaves.</strong> </p><p>我们所用到的数据集是:</p><p><img src="https://i.loli.net/2020/09/03/xv6ge8tXmcV9LKW.png" alt="image-20200903203619463" style="zoom: 25%;" /></p><p>用 Attribute <code>A</code> 的示意图如下:</p><p><img src="https://i.loli.net/2020/09/03/LFpJWthzwNQZ7uj.png" alt="image-20200903204014704" style="zoom:25%;" /></p><p>算法伪代码如下:</p><p><img src="https://i.loli.net/2020/09/03/gVbyBZnsLuHTvka.png" alt="image-20200903205835284" style="zoom: 50%;" /></p><p>如果我们选择 Arribute <code>B</code>, 我们可以得到最低的 Error Rate:</p><p><img src="https://i.loli.net/2020/09/03/sLQKOpPSaoRlA4W.png" alt="image-20200903204850653" style="zoom:25%;" /></p><p>相关数学表达:</p><p><img src="https://i.loli.net/2020/09/15/ziDZJP9yYaBM5Vf.png" alt="image-20200915160058376" style="zoom:33%;" /></p></li></ol><h3 id="2-Decision-Tree"><a href="#2-Decision-Tree" class="headerlink" title="2. Decision Tree"></a>2. Decision Tree</h3><p>我们看一下如何使用一个递归伪代码来建立一个决策树:</p><p><img src="https://i.loli.net/2020/09/28/X2wLcdaKHTinzxI.png" alt="image-20200928055729758" style="zoom: 50%;" /></p><p>显然, 决策树的生成是一个递归过程. 在决策树的基本算法中, 有三种情形会导致递归返回:</p><ul><li>当前结点包含的样本全属于同一类别, 无需划分;</li><li>当前属性集为空, 或是所有样本在所有属性上取值相同, 无法划分;</li><li>当前结点包含的样本集合为空, 不能划分;</li></ul><p>在伪代码中我们提到了根据<strong>信息增益 (ID3)/信息增益比 (ID4.5)/基尼系数 (CART)</strong>来选择最优属性. 而这些数值的计算则是基于我们之前已经介绍过的 Entropy. </p><p>在对熵有了基本了解之后, 我们引入 <code>条件熵</code> 和 <code>互信息</code> 的概念. <strong>注: 决策树学习中的信息增益等价于训练集中类与特征的互信息.</strong></p><p><img src="https://i.loli.net/2020/09/17/FVCWjmH4T12tBx7.png" alt="image-20200917155140385" style="zoom: 25%;" /></p><p>在决策树算法中, 我们使用<strong>互信息(信息增益)</strong>来选择特征. 信息增益越大, 说明该特征对数据集 <code>D</code> 的分类的不确定性消减程度越大. 显然, 对于数据集 <code>D</code> 而言, 不同的特征往往具有不同的信息增益. 信息增益更大的特征具有更强的分类能力.</p><blockquote><p>  我们看一个例子来熟悉一下信息增益, 数据集如下:</p><p>  <img src="https://i.loli.net/2020/09/17/w4G8UeoX1NhZYLH.png" alt="image-20200917160504839" style="zoom: 25%;" /></p><p>  $H(Y)=-\frac{2}{8}\log_2\frac{2}{8}-\frac{6}{8}\log_2\frac{6}{8}=0.811$</p><p>  <strong>如果使用特征 <code>A</code>:</strong></p><p>  <img src="https://i.loli.net/2020/09/17/m1Dev8bEBwL47ro.png" alt="image-20200917161221017" style="zoom:25%;" /></p><p>  $H(Y|A=0)=undefined$</p><p>  $H(Y|A=1)=H(Y)$</p><p>  $H(Y|A)=P(A=0)H(Y|A=0)+P(A=1)H(Y|A=1)=0+H(Y)=H(Y)$</p><p>  $I(Y;A)=H(Y)-H(Y|A)=0$</p><p>  <strong>如果使用特征 <code>B</code>:</strong></p><p>  <img src="https://i.loli.net/2020/09/17/2D5Jz4mwehu1Rso.png" alt="image-20200917161653256" style="zoom:25%;" /></p><p>  $H(Y|B=0)=-\frac{2}{4}\log_2\frac{2}{4}-\frac{2}{4}\log_2\frac{2}{4}=1$</p><p>  $H(Y|B=1)=-0\log_20-1\log_21=0$</p><p>  $H(Y|B)=P(B=0)H(Y|B=0)+P(B=1)H(Y|B=1)=0.5$</p><p>  $I(Y;B)=H(Y)-H(Y|B)=0.311$</p><p>  <strong>Since $I(Y;B)&gt;I(Y;A)$, we split on B.</strong></p></blockquote><h4 id="2-1-ID3-and-C4-5"><a href="#2-1-ID3-and-C4-5" class="headerlink" title="2.1 ID3 and C4.5"></a>2.1 ID3 and C4.5</h4><p>我们主要介绍两种决策树经典算法: <code>ID3</code> 和 <code>C4.5</code>.</p><ol><li><p><strong>ID3</strong></p><p>ID3 算法的核心是在决策树各个结点上应用<strong>信息增益准则</strong>选择特征, 递归的构建决策树. 具体的方法是: 从根结点开始, 对结点计算所有可能的特征的信息增益, 选择信息增益最大的特征作为结点的特征, 由该特征的不同取值建立子节点, 再对子节点递归地调用以上方法, 构建决策树. 直到所有特征的信息增益均很小或没有特征可以选择为止. </p><script type="math/tex; mode=display">Gain(D,a)=Ent(D)-\sum_{v=1}^V\frac{|D^v|}{|D|}Ent(D^v)</script><blockquote><p>  <strong>输入:</strong> 训练数据集 D, 特征集 A, 阈值 $\varepsilon$</p><p>  <strong>输出:</strong> 决策树 T</p><p>  <strong>算法步骤:</strong></p><ol><li>若 D 中所有实类属于同一类 $C_k$, 则 T 为单结点树, 并将类 $C_k$ 作为该结点的类标记, 返回 T.</li><li>若 $A=\emptyset$, 则 T 为单结点树, 并将 D 中实例树最大的类 $C_k$ 作为作为该结点的类标记, 返回 T.</li><li>否则, 计算 A 中的各特征对 D 的信息增益, 选择信息增益最大的特征 $A_g$.</li><li>如果 $A_g$ 的信息增益小于阈值 $\varepsilon$, 则设置 T 为单结点树, 并将 D 中实例数最大的类 $C_k$ 作为该结点的类标记, 返回 T.</li><li>否则, 对 $A_g$ 的每一可能值 $a_i$, 依 $A_g=a_i$ 将 D 分割为若干非空子集 $D_i$, 将 $D_i$ 中实例数最大的类作为标记, 构建子结点, 由结点及其子结点构成树 T, 返回 T.</li><li>对第 $i$ 个子结点, 以 $D_i$ 为训练集, 以 $A-\{A_g\}$ 为特征集, 递归地调用步骤 1~5, 得到子树 $T_i$, 返回 $T_i$.</li></ol></blockquote><p><strong>评价:</strong></p><p>ID3 算法只有树的生成, 所以该算法生成的树容易产生过拟合.</p></li><li><p><strong>C4.5</strong></p><p>C4.5 算法与 ID3 算法相似, 但有一些改进. C4.5 在生成的过程中, 用信息增益比选择特征.</p><blockquote><p>  <strong>输入:</strong> 训练数据集 D, 特征集 A, 阈值 $\varepsilon$</p><p>  <strong>输出:</strong> 决策树 T</p><p>  <strong>算法步骤:</strong></p><ol><li>若 D 中所有实类属于同一类 $C_k$, 则 T 为单结点树, 并将类 $C_k$ 作为该结点的类标记, 返回 T.</li><li>若 $A=\emptyset$, 则 T 为单结点树, 并将 D 中实例树最大的类 $C_k$ 作为作为该结点的类标记, 返回 T.</li><li>否则, 计算 A 中的各特征对 D 的信息增益比, 选择信息增益比最大的特征 $A_g$.</li><li>如果 $A_g$ 的信息增益比小于阈值 $\varepsilon$, 则设置 T 为单结点树, 并将 D 中实例数最大的类 $C_k$ 作为该结点的类标记, 返回 T.</li><li>否则, 对 $A_g$ 的每一可能值 $a_i$, 依 $A_g=a_i$ 将 D 分割为若干非空子集 $D_i$, 将 $D_i$ 中实例数最大的类作为标记, 构建子结点, 由结点及其子结点构成树 T, 返回 T.</li><li>对第 $i$ 个子结点, 以 $D_i$ 为训练集, 以 $A-\{A_g\}$ 为特征集, 递归地调用步骤 1~5, 得到子树 $T_i$, 返回 $T_i$.</li></ol></blockquote><p><strong>注: 这里我们引入了新概念 <code>信息增益比 (information gain ratio)</code></strong></p><p>以信息增益作为划分训练数据集的特征, 存在偏向于选择取值数目较多的属性的问题. 使用<strong>信息增益比 (information gain ratio)</strong> 可以对这一问题进行校正. <code>Information Gain Ratio</code> 的定义如下:</p><p>特征 <code>A</code> 对训练数据集 <code>D</code> 的信息增益比 $g_R(D,A)$ 定义为其信息增益 $g(D,A)$ 与训练数据集 <code>D</code> 关于特征 <code>A</code> 的值熵 $H_A(D)$ 之比, 即</p><p>$g_R(D,A)=\frac{g(D,A)}{H_A(D)}$, 其中 $H_A(D)=-\sum_{i=1}^{n}\frac{|D_i|}{|D|}\log_2\frac{|D_i|}{|D|}$</p></li></ol><h4 id="2-2-CART"><a href="#2-2-CART" class="headerlink" title="2.2 CART"></a>2.2 CART</h4><p>CART是“Classification and Regression Trees”的缩写. 从其名字我们就不难理解, CART算法是即可以用于分类, 也可以用于回归的.</p><h5 id="2-2-1-Classification"><a href="#2-2-1-Classification" class="headerlink" title="2.2.1 Classification"></a>2.2.1 Classification</h5><p>我们针对特征值的类型来分别介绍CART算法是如何进行分类的, 以及和C4.5有什么异同. </p><ol><li><p><strong>连续特征值</strong></p><p>CART的处理思想与C4.5是相同的, 即将连续特征值<strong>离散化.</strong> 唯一不同的地方是度量的标准不一样, CART采用基尼指数, 而C4.5采用信息增益比. 下面举个例子说明下:</p><p>特征 $a$ 有连续值 $m$ 个, 从小到大排列:</p><p>$a_1, a_2,a_3,…,a_{m-1},a_m$</p><p>我们对相邻的两个值求平均得到 $m-1$ 个切分点:</p><p>$Split \ 1: \frac{a_1+a_2}{2}$</p><p>$Split\ 2:\frac{a_2+a_3}{2}$</p><p>$…$</p><p>然后我们使用每个切分点把数据集离散划分成两类: $D_1,D_2$, 然后计算每个划分点所对应的基尼系数, 选择值最小的一个作为最终的特征划分. </p><blockquote><p>  基尼系数:</p><p>  Gini系数是一种与信息熵累类似的做特征选择的方式, 可以用来衡量数据的不纯度. 计算公式如下:</p><script type="math/tex; mode=display">  Gini(D)=1-\sum_{k=1}^K(\frac{|C_k|}{|D|})^2 \\  Gini(D,A)=\frac{|D_1|}{|D|}Gini(D_1)+\frac{|D_2|}{|D|}Gini(D_2)</script><p>  其中 $|C_k|$ 表示数据中每个类别也就是 $(Y=y_k)$ 的instances数量. $|D|$ 表示数据中所有instances的数量.</p></blockquote><p>CART与ID3, C4.5处理离散属性不同的是: 如果当前节点为连续属性, 则该属性后面还可以参与子节点的产生选择过程.</p></li><li><p><strong>离散特征值</strong></p><p>CART的处理思想与C4.5稍微所有不同. 如果离散特征值多于两个, 那么C4.5会在节点上根据特征值划分出多叉树. 但是CART则不同, 无论离散特征值有几个, 在节点上都划分成二叉树. CART树是如何进行分类的呢? 我们还是用一个例子来讲解:</p><p>特征 $a$ 有 $m$ 个离散值:</p><p>$a_1,a_2,a_3,…,a_{m-1},a_m$</p><p>分类标准是: 每一次将其中一个特征分为一类, 其它非该特征分为另外一类. 依照这个标准遍历所有的分类情况, 计算每种分类下的基尼指数, 最后选择值最小的一个作为最终的特征划分.</p></li></ol><p><strong>特征值连续和离散有各自的处理方法, 不应该混淆使用. 比如分类0,1,2只代表标签含义, 如果进行加减的运算或者求平均则没有任何意义. 因此, CART分类树会根据特征类型选择不同的划分方法, 并且与C4.5不同是, 它永远只有两个分支.</strong></p><p>现在我们给出CART的算法流程:</p><blockquote><p>  <strong>输入:</strong> 训练数据集 $D$, 停止计算的参数条件.</p><p>  <strong>输出:</strong> CART 决策树.</p><p>  <strong>算法步骤:</strong> </p><p>  根据训练数据集, 从根节点开始, 递归地对每个结点进行以下操作, 构建二叉决策树.</p><ol><li>如果样本个数小于阈值或者没有特征, 则返回决策子树, 当前节点停止递归.</li><li>计算样本集 $D$ 的基尼系数, 如果基尼系数小于阈值, 则返回决策子树, 当前节点停止递归.</li><li>识别各个特征类型, 是离散值还是连续值? 对每种类型使用相应的处理方法并计算每个切分下的基尼系数.</li><li>在计算出来的各个特征的各个特征值对数据集 $D$ 的基尼系数中, 选择基尼系数最小的特征 $A$ 和对应的特征值 $a$. 根据这个最优特征和最优特征值, 把数据集划分成两部分 $D_1$ 和 $D_2$, 同时建立当前节点的左右节点, 左节点的数据集 $D$ 为 $D_1$, 右节点的数据集 $D$ 为 $D_2$.</li><li>对左右的子节点递归的调用1-4步, 生成决策树.</li></ol><p>  算法停止计算的条件是: 如步骤1,2所示, 结点中的样本个数小于预定的阈值. 或样本集的Gini系数小于预定阈值 (样本基本属于同一类), 或者没有更多的特征.</p></blockquote><h5 id="2-2-2-Regression"><a href="#2-2-2-Regression" class="headerlink" title="2.2.2 Regression"></a>2.2.2 Regression</h5><p>与分类树不同, 回归树的预测变量是连续值, 比如预测一个人的年龄, 又或者预测季度的销售额等等. 另外, 回归树在<strong>选择特征的度量标准</strong>和<strong>决策树建立后预测的方式</strong>上也存在不同. </p><ol><li><p><strong>预测方式</strong></p><p>一个回归树对应着输入特征空间的一个划分, 以及在划分单元上的输出值. 先假设数据集已被划分为 $R_1,R_2,…,R_m$ 共 $m$ 个子集, 回归树要求每个划分 $R_m$ 中都对应一个固定的输出值 $c_m$. </p><script type="math/tex; mode=display">f(x)=\sum_{m=1}^Mc_m\mathbb{I}(x\in R_m)</script><p>这个 $c_m$ 值其实就是每个子集中所有样本的目标变量 $y$ 的平均值, 并以此 $c_m$ 作为该子集的预测值. 所有分支节点都是如此, 叶子节点也不例外. 因此, 可以知道回归树的预测方式是: <strong>将叶子节点中样本的y均值作为回归的预测值. </strong> 而分类树的预测方式则是: 叶子节点中概率最大的类别作为当前节点的预测类别. </p></li><li><p><strong>选择特征的度量标准</strong></p><p>CART回归树对于特征类型的处理与分类树一样, 连续值与离散值分开对待, 并<strong>只能生成二叉树</strong>. 但是CART回归树对于选择特征的度量标准则完全不同. </p><p>分类树的特征选择标准使用基尼指数, 而回归树则使用RSS<strong>残差平方和</strong>. 了解线性回归的朋友知道, 损失函数是以最小化离差平方和的形式给出的. 回归树使用的度量标准也是一样的, 通过最小化残差平方和作为判断标准，公式如下:</p><script type="math/tex; mode=display">\mathop{\min}\limits_{j,s}[\mathop{\min}\limits_{c_1}\sum_{x_i\in R_1(j,s)}(y_i-c_1)^2+\mathop{\min}\limits_{c_2}\sum_{x_2\in R_2(j,s)}(y_i-c_2)^2]</script><p>我们首先遍历变量 $j$, 对固定的切分变量 $j$ 扫描切分点 $s$, 选择使上式达到最小的对 $(j,s)$. </p><p>然后我们用选定的对 $(j,s)$ 划分区域并决定相应的输出值:</p><script type="math/tex; mode=display">R_1(j,s)=\{x|x^{(j)}\le s\},\quad R_2(j,s)=\{x|x^{(j)}>s\} \\\hat{c}_m=\frac{1}{N_m}\sum_{x_i\in R_m(j,s)}y_i,\quad x\in R_m, m=1,2</script><p>我们继续对两个子区域调用上述两个步骤, 直至满足停止条件. </p></li></ol><p>我们来看一个回归树的例子, 训练数据见下表, 目标是得到一棵最小二乘回归树.</p><div class="table-container"><table><thead><tr><th>x</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>y</td><td>5.56</td><td>5.7</td><td>5.91</td><td>6.4</td><td>6.8</td><td>7.05</td><td>8.9</td><td>8.7</td><td>9</td><td>9.05</td></tr></tbody></table></div><p>我们第一步需要选择最优切分变量 $j$ 和最优切分点 $s$. 在本数据集中, 只有一个变量, 因此最优切分变量自然是 $x$. 接下来我们考虑9个切分点[ 1.5 , 2.5 , 3.5 , 4.5 , 5.5 , 6.5 , 7.5 , 8.5 , 9.5 ]. 例如, 如果我们取 $s=1.5$, 此时 $R_1=\{1\}$, $R_2=\{2,3,4,5,6,7,8,9,10\}$. 这两个区域的输出值分别为: $c_1=5.56$, $c_2=7.5$. 因此我们能得到下表:</p><div class="table-container"><table><thead><tr><th>s</th><th>1.5</th><th>2.5</th><th>3.5</th><th>4.5</th><th>5.5</th><th>6.5</th><th>7.5</th><th>8.5</th><th>9.5</th></tr></thead><tbody><tr><td>$c_1$</td><td>5.56</td><td>5.63</td><td>5.72</td><td>5.89</td><td>6.07</td><td>6.24</td><td>6.62</td><td>6.88</td><td>7.11</td></tr><tr><td>$c_2$</td><td>7.5</td><td>7.73</td><td>7.99</td><td>8.25</td><td>8.54</td><td>8.91</td><td>8.92</td><td>9.03</td><td>9.05</td></tr></tbody></table></div><p>然后我们计算不同切分点下的残差和, 即 $\sum_{x_i\in R_1(j,s)}(y_i-c_1)^2+\sum_{x_2\in R_2(j,s)}(y_i-c_2)^2$, 我们能得到下表:</p><div class="table-container"><table><thead><tr><th>s</th><th>1.5</th><th>2.5</th><th>3.5</th><th>4.5</th><th>5.5</th><th>6.5</th><th>7.5</th><th>8.5</th><th>9.5</th></tr></thead><tbody><tr><td>rss</td><td>15.72</td><td>12.08</td><td>8.37</td><td>5.78</td><td>3.91</td><td>1.93</td><td>8.00</td><td>11.74</td><td>15.74</td></tr></tbody></table></div><p>显然当 $s=6.5$ 时, 残差和取得最小. 因此第一个划分对为 $(j=x,s=6.5)$.</p><p>接下来就是递归生回归树, 过程不在此赘述, 直接看代码.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Declare Package</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dataset</span></span><br><span class="line">x = np.arange(<span class="number">1</span>,<span class="number">11</span>).reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">y = np.array([<span class="number">5.56</span>,<span class="number">5.7</span>,<span class="number">5.91</span>,<span class="number">6.4</span>,<span class="number">6.8</span>,<span class="number">7.05</span>,<span class="number">8.9</span>,<span class="number">8.7</span>,<span class="number">9</span>,<span class="number">9.05</span>]).ravel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fit Model</span></span><br><span class="line">model1 = DecisionTreeRegressor(max_depth=<span class="number">1</span>)</span><br><span class="line">model2 = DecisionTreeRegressor(max_depth=<span class="number">3</span>)</span><br><span class="line">model3 = DecisionTreeRegressor(max_depth=<span class="number">5</span>)</span><br><span class="line">model4 = linear_model.LinearRegression()</span><br><span class="line"></span><br><span class="line">model1.fit(x,y)</span><br><span class="line">model2.fit(x,y)</span><br><span class="line">model3.fit(x,y)</span><br><span class="line">model4.fit(x,y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Predict</span></span><br><span class="line">x_test = np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">100</span>).reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">y_1 = model1.predict(x_test)</span><br><span class="line">y_2 = model2.predict(x_test)</span><br><span class="line">y_3 = model3.predict(x_test)</span><br><span class="line">y_4 = model4.predict(x_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the results</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(x,y,s=<span class="number">20</span>,edgecolor=<span class="string">&quot;black&quot;</span>,c=<span class="string">&quot;darkorange&quot;</span>,label=<span class="string">&quot;data&quot;</span>)</span><br><span class="line">plt.plot(x_test,y_1,color=<span class="string">&quot;cornflowerblue&quot;</span>,label=<span class="string">&quot;max_depth=1&quot;</span>,linewidth=<span class="number">2</span>)</span><br><span class="line">plt.plot(x_test,y_2,color=<span class="string">&quot;yellowgreen&quot;</span>,label=<span class="string">&quot;max_depth=3&quot;</span>,linewidth=<span class="number">2</span>)</span><br><span class="line">plt.plot(x_test,y_3,color=<span class="string">&quot;grey&quot;</span>,label=<span class="string">&quot;max_depth=5&quot;</span>,linewidth=<span class="number">2</span>)</span><br><span class="line">plt.plot(x_test,y_4,color=<span class="string">&quot;red&quot;</span>,label=<span class="string">&quot;linear regression&quot;</span>,linewidth=<span class="number">2</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;data&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;target&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;CART vs Linear Regression&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201217232054452.png" alt="image-20201217232054452" style="zoom:50%;" /></p><h3 id="3-Pros-and-Cons"><a href="#3-Pros-and-Cons" class="headerlink" title="3. Pros and Cons"></a>3. Pros and Cons</h3><p>决策树的优势:</p><ul><li>便于理解和解释。树的结构可以可视化出来。</li><li>训练需要的数据少。其他机器学习模型通常需要数据规范化，比如构建虚拟变量和移除缺失值,不过请注意，这种模型不支持缺失值。</li><li>由于训练决策树的数据点的数量导致了决策树的使用开销呈指数分布(训练树模型的时间复杂度是参与训练数据点的对数值)。</li><li>能够处理数值型数据和分类数据。其他的技术通常只能用来专门分析某一种变量类型的数据集。详情请参阅算法。</li><li>能够处理多路输出的问题。</li><li>使用白盒模型。如果某种给定的情况在该模型中是可以观察的，那么就可以轻易的通过布尔逻辑来解释这种情况。相比之下，在黑盒模型中的结果就是很难说明清楚地。</li><li>可以通过数值统计测试来验证该模型。这对事解释验证该模型的可靠性成为可能。</li><li>即使该模型假设的结果与真实模型所提供的数据有些违反，其表现依旧良好。</li></ul><p>决策树的缺点包括:</p><ul><li>决策树模型容易产生一个过于复杂的模型,这样的模型对数据的泛化性能会很差。这就是所谓的过拟合.一些策略像剪枝、设置叶节点所需的最小样本数或设置数的最大深度是避免出现 该问题最为有效地方法。</li><li>决策树可能是不稳定的，因为数据中的微小变化可能会导致完全不同的树生成。这个问题可以通过决策树的集成来得到缓解</li><li>在多方面性能最优和简单化概念的要求下，学习一棵最优决策树通常是一个NP难问题。因此，实际的决策树学习算法是基于启发式算法，例如在每个节点进 行局部最优决策的贪心算法。这样的算法不能保证返回全局最优决策树。这个问题可以通过集成学习来训练多棵决策树来缓解,这多棵决策树一般通过对特征和样本有放回的随机采样来生成。</li><li>有些概念很难被决策树学习到,因为决策树很难清楚的表述这些概念。例如XOR，奇偶或者复用器的问题。</li><li>如果某些类在问题中占主导地位会使得创建的决策树有偏差。因此，我们建议在拟合前先对数据集进行平衡。</li></ul><h3 id="4-Implementation"><a href="#4-Implementation" class="headerlink" title="4. Implementation"></a>4. Implementation</h3><p><strong>项目一地址:</strong> <a href="https://github.com/alvisdeng/Decision-Tree-ID3">https://github.com/alvisdeng/Decision-Tree-ID3</a></p><p>说实话, 这份代码我写的不是很满意, 主要是因为那个时候刚开始接触… 后续有时间再做优化吧… 主要是写的太啰嗦了.</p><p><strong>项目二:</strong> 使用Sklearn的CART分类树</p><p>数据使用项目一的Education Dataset</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">import</span> graphviz</span><br><span class="line"></span><br><span class="line">train_file = <span class="string">&quot;data/education_train.tsv&quot;</span></span><br><span class="line">test_file = <span class="string">&quot;data/education_test.tsv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Preprocessing</span></span><br><span class="line">train_data = pd.read_csv(filepath_or_buffer=train_file,</span><br><span class="line">                         sep=<span class="string">&quot;\t&quot;</span>,</span><br><span class="line">                         encoding=<span class="string">&quot;utf8&quot;</span>,</span><br><span class="line">                         converters=&#123;</span><br><span class="line">                             <span class="string">&quot;M1&quot;</span>:<span class="keyword">lambda</span> x:np.where(x==<span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">                             <span class="string">&quot;M2&quot;</span>:<span class="keyword">lambda</span> x:np.where(x==<span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">                             <span class="string">&quot;M3&quot;</span>:<span class="keyword">lambda</span> x:np.where(x==<span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">                             <span class="string">&quot;M4&quot;</span>:<span class="keyword">lambda</span> x:np.where(x==<span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">                             <span class="string">&quot;M5&quot;</span>:<span class="keyword">lambda</span> x:np.where(x==<span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">                             <span class="string">&quot;P1&quot;</span>:<span class="keyword">lambda</span> x:np.where(x==<span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">                             <span class="string">&quot;P2&quot;</span>:<span class="keyword">lambda</span> x:np.where(x==<span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">                             <span class="string">&quot;P3&quot;</span>:<span class="keyword">lambda</span> x:np.where(x==<span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">                             <span class="string">&quot;P4&quot;</span>:<span class="keyword">lambda</span> x:np.where(x==<span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">                             <span class="string">&quot;F&quot;</span>:<span class="keyword">lambda</span> x:np.where(x==<span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">                         &#125;)</span><br><span class="line"></span><br><span class="line">test_data = pd.read_csv(filepath_or_buffer=test_file,</span><br><span class="line">                         sep=<span class="string">&quot;\t&quot;</span>,</span><br><span class="line">                         encoding=<span class="string">&quot;utf8&quot;</span>,</span><br><span class="line">                         converters=&#123;</span><br><span class="line">                             <span class="string">&quot;M1&quot;</span>:<span class="keyword">lambda</span> x:np.where(x==<span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">                             <span class="string">&quot;M2&quot;</span>:<span class="keyword">lambda</span> x:np.where(x==<span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">                             <span class="string">&quot;M3&quot;</span>:<span class="keyword">lambda</span> x:np.where(x==<span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">                             <span class="string">&quot;M4&quot;</span>:<span class="keyword">lambda</span> x:np.where(x==<span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">                             <span class="string">&quot;M5&quot;</span>:<span class="keyword">lambda</span> x:np.where(x==<span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">                             <span class="string">&quot;P1&quot;</span>:<span class="keyword">lambda</span> x:np.where(x==<span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">                             <span class="string">&quot;P2&quot;</span>:<span class="keyword">lambda</span> x:np.where(x==<span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">                             <span class="string">&quot;P3&quot;</span>:<span class="keyword">lambda</span> x:np.where(x==<span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">                             <span class="string">&quot;P4&quot;</span>:<span class="keyword">lambda</span> x:np.where(x==<span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">                             <span class="string">&quot;F&quot;</span>:<span class="keyword">lambda</span> x:np.where(x==<span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">                         &#125;)</span><br><span class="line">                         </span><br><span class="line">train_data[<span class="string">&#x27;Target&#x27;</span>] = train_data[<span class="string">&#x27;grade&#x27;</span>].apply(<span class="keyword">lambda</span> x:np.where(x==<span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">test_data[<span class="string">&#x27;Target&#x27;</span>] = test_data[<span class="string">&#x27;grade&#x27;</span>].apply(<span class="keyword">lambda</span> x:np.where(x==<span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extract Data</span></span><br><span class="line">features = <span class="built_in">list</span>(train_data.columns[:-<span class="number">2</span>])</span><br><span class="line">class_names = <span class="built_in">sorted</span>(train_data[<span class="string">&quot;grade&quot;</span>].unique(),reverse=<span class="literal">True</span>)</span><br><span class="line">train_X = train_data[features]</span><br><span class="line">train_Y = train_data[<span class="string">&quot;Target&quot;</span>]</span><br><span class="line"></span><br><span class="line">test_X = test_data[features]</span><br><span class="line">test_Y = test_data[<span class="string">&quot;Target&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Train Model</span></span><br><span class="line">dt = tree.DecisionTreeClassifier(criterion=<span class="string">&quot;gini&quot;</span>,splitter=<span class="string">&quot;best&quot;</span>,max_depth=<span class="number">3</span>,random_state=<span class="number">99</span>)</span><br><span class="line">dt.fit(train_X,train_Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prediction</span></span><br><span class="line">prediction = dt.predict(test_X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Evaluation</span></span><br><span class="line">score = accuracy_score(y_pred=prediction,y_true=test_Y)</span><br><span class="line">print(score)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Visualize DT</span></span><br><span class="line">dot_data = tree.export_graphviz(dt,out_file=<span class="literal">None</span>,feature_names=features,class_names=class_names,filled=<span class="literal">True</span>,rounded=<span class="literal">True</span>,special_characters=<span class="literal">True</span>)</span><br><span class="line">graph = graphviz.Source(dot_data)</span><br><span class="line">graph.render(<span class="string">&quot;Education&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Supervised Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习中的 Entropy</title>
      <link href="2020/11/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84-Entropy/"/>
      <url>2020/11/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84-Entropy/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Information-Entropy"><a href="#1-Information-Entropy" class="headerlink" title="1. Information Entropy"></a>1. Information Entropy</h3><p>信息熵通常用来描述整个随机分布所带来的<strong>信息量平均值</strong>, 更具统计特性. 信息熵也叫香农熵, 在机器学习中, 由于熵的计算是依据样本数据而来, 故也叫经验熵. 其公式定义如下:</p><script type="math/tex; mode=display">H(X)=-E_{x\sim p}[\log P(x)]=-\sum_{i=1}^nP(x_i)\log P(x_i)</script><p>从公式可以看出, 信息熵 $H(x)$ 是各项自信息的累加值, 由于每一项都是整正数, 故而<strong>随机变量取值个数越多, 状态数也就越多, 累加次数就越多, 信息熵就越大, 混乱程度就越大, 纯度越小</strong>. 越宽广的分布, 熵就越大. 可以通过数学证明, 当随机变量分布为均匀分布时即状态数最多时, 熵最大. <strong>熵代表了随机分布的混乱程度, 这一特性是所有基于熵的机器学习算法的核心思想</strong>.</p><p>推广到多维随机变量的联合分布, 其联合信息熵为:</p><script type="math/tex; mode=display">H(X,Y)=-\sum_{i=1}^n\sum_{j=1}^mP(x_i,y_i)\log P(x_i,y_i)</script><p><strong>注意事项:</strong></p><ul><li>熵只依赖于随机变量的分布, 与随机变量取值无关.</li><li>定义 $0\log0=0$ (因为可能出现某个取值概率为0的情况).</li><li>熵越大, 随机变量的不确定性就越大, 分布越混乱, 随机变量状态数越多.</li></ul><h3 id="2-Conditional-Entropy"><a href="#2-Conditional-Entropy" class="headerlink" title="2. Conditional Entropy"></a>2. Conditional Entropy</h3><p>条件熵 $H(Y|X)$ 表示在已知随机变量 $X$ 的条件下随机变量 $Y$ 的不确定性.</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}H(Y|X)=&\sum_{x}P(x)H(Y|X=x) \\=&\sum_{x}P(x)\sum_{y}P(y|x)\log P(y|x) \\=&\sum_{x,y}P(x,y)\log P(y|x)\end{aligned}\end{equation}</script><p>条件熵 $H(Y|X)$ 相当于联合熵 $H(X,Y)$ 减去单独的熵 $H(X)$, 即 $H(Y|X)=H(X,Y)-H(X)$. 举个例子, 比如环境温度是低还是高, 和我穿短袖还是外套这两个事件可以组成联合概率分布 $H(X,Y)$, 因为两个事件加起来的信息量肯定是大于单一事件的信息量的. 假设 $H(X)$ 对应着今天环境温度的信息量, 由于今天环境温度和今天我穿什么衣服这两个事件并不是独立分布的, 所以在已知今天环境温度的情况下, 我穿什么衣服的信息量或者说不确定性是被减少了. 当已知 $H(X)$这个信息量的时候, $H(X,Y)$ 剩下的信息量就是条件熵: $H(Y|X)=H(X,Y)-H(X)$</p><h3 id="3-Relative-Entropy"><a href="#3-Relative-Entropy" class="headerlink" title="3. Relative Entropy"></a>3. Relative Entropy</h3><blockquote><p>  相对熵也被称为 KL 散度.</p></blockquote><p>在我们介绍相对熵之前, 我们先试着思考一个问题, 我们为什么需要相对熵这么一个概念呢?</p><p>原因很简单, 因为我们希望测量我们训练出来的模型和实际数据的差别, 相对熵的目的就是为了评估和验证模型学习的效果. 也就是说相对熵是用来衡量两个概率分布的差值的, 我们用这个差值来衡量模型预测结果与真实数据的差距. 明白了这点之后, 我们来看相对熵的定义:</p><script type="math/tex; mode=display">D_{KL}(P||Q)=\sum_{i=1}^nP(x_i)\log\frac{P(x_i)}{Q(x_i)}</script><p>如果把 $\sum_{i=1}^nx_i$ 看成是一个事件的所有结果, 那么所有的 $P(x_i)$ 和 $Q(x_i)$ 就可以看成是两个关于事件 $X$ 的概率分布. 其中: $P(x_i)$ 是样本真实的分布, 而 $Q(x_i)$ 是我们模型产出的分布. KL 散度越小, 表示这两个分布越接近, 说明模型的效果越好.</p><p>光看上面的<strong>KL 散度</strong>公式可能会云里雾里, 不明白为什么能反应P和Q两个分布的相似度. 因为这个公式少了两个限制条件:</p><script type="math/tex; mode=display">\sum_{i=1}^nP(x_i)=1,\sum_{i=1}^nQ(x_i)=1</script><p>我们假设 $x_i$ 只有 0 和 1 两个取值, 也就是一个事件只有发生或者不发生. 我们再假设 $P(x=0)=P(x=1)=0.5$, 我们画一下 $P(x_i)\log(\frac{P(x_i)}{Q(x_i)})$ 的图像:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201112125109350.png" alt="image-20201112125109350" style="zoom:50%;" /></p><p>代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kl_function</span>(<span class="params">p_x,q_x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> p_x*np.log(p_x/q_x)</span><br><span class="line"></span><br><span class="line">p_x = <span class="number">0.5</span></span><br><span class="line">q_x = np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">kl_value = [kl_function(<span class="number">0.5</span>,i) <span class="keyword">for</span> i <span class="keyword">in</span> q_x]</span><br><span class="line"></span><br><span class="line">plt.plot(q_x,kl_value)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Q(x)&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Value of P(x)*log(P(x)/Q(x))&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>我们可以看到, 函数随着 $Q(x_i)$ 的递增而递减. 但是这只是一个 $x$ 的取值, 别忘了, 我们相对熵计算的是整个分布，那我们加上另一个x的取值会发生什么呢？</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201112125702135.png" alt="image-20201112125702135" style="zoom:50%;" /></p><p>代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kl_function</span>(<span class="params">p_x,q_x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> p_x*np.log(p_x/q_x)</span><br><span class="line"></span><br><span class="line">p_x = <span class="number">0.5</span></span><br><span class="line">q_x = np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">kl_value = [kl_function(p_x,i)+kl_function(<span class="number">1</span>-p_x,<span class="number">1</span>-i) <span class="keyword">for</span> i <span class="keyword">in</span> q_x]</span><br><span class="line"></span><br><span class="line">plt.plot(q_x,kl_value)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Q(x)&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;KL&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>从函数图像上, 我们很容易看出, 当 $Q(x)=0.5=P(x)$ 的时候, KL散度取最小值, 最小值为0. 我们对相对熵的计算公式做一个变形:</p><script type="math/tex; mode=display">D_{KL}(P||Q)=\sum_{i=1}^nP(x_i)\log\frac{P(x_i)}{Q(x_i)}=\sum_{i=1}^nP(x_i)\log P(x_i)-\sum_{i=1}^nP(x_i)\log Q(x_i)</script><p>这个式子的左边 $\sum_{i=1}^nP(x_i)\log(P(x_i))$ 其实就是 $-H(X)$, 对应于一个确定事件 $X$ 来说, 它的信息熵是确定的, 也就是说 $H(X)$ 是一个常数, $P(x_i)$ 也是常数, $\log$ 函数是一个凹函数, $-log$ 则是凸函数. 因此相对熵的计算公式是一个凸函数. </p><p>对于任何凸函数, 有 <strong>Jensen 不等式</strong>:</p><script type="math/tex; mode=display">f(E(x))\le E(f(x))</script><blockquote><p>  我们简单介绍一下凸凹函数</p><p>  <img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201102032450850.png" alt="image-20201102032450850" style="zoom:67%;" /></p><p>  左为凹函数: 满足 $f(\frac{x_1+x_2}{2})\gt\frac{f(x_1)+f(x_2)}{2}$;</p><p>  右为凸函数: 满足 $f(\frac{x_1+x_2}{2})\lt\frac{f(x_1)+f(x_2)}{2}$;</p></blockquote><p>我们可以利用 Jensen 不等式来证明: $D_{KL}\ge0$</p><p>首先我们对 KL 计算公式进行变形:</p><script type="math/tex; mode=display">D_{KL}=\sum_{i=1}^nP(x_i)\log\frac{P(x_i)}{Q(x_i)}=E(\log\frac{P(x_i)}{Q(x_i)})=E[-\log\frac{Q(x_i)}{P(x_i)}]</script><p>然后我们利用不等式:</p><script type="math/tex; mode=display">E[-\log\frac{Q(x_i)}{P(x_i)}]\ge-\log E[\frac{Q(x_i)}{P(x_i)}]=-\log\sum_{i=1}^nP(x_i)\frac{Q(x_i)}{P(x_i)}=-\log\sum_{i=1}^nQ(x_i)=0</script><p>所以KL散度是一个非负值, 但是为什么当P和Q相等时 (也就是真实模型和预测模型相等时), 能取到最小值呢? </p><p>我们令: </p><script type="math/tex; mode=display">C(P,P)=-\sum_{i=1}^nP(x_i)\log(P(x_i))</script><script type="math/tex; mode=display">C(P,Q)=-\sum_{i=1}^nP(x_i)\log(Q(x_i))</script><script type="math/tex; mode=display">C(P,P)-C(P,Q)=\sum_{i=1}^nP(x_i)\log(\frac{Q(x_i)}{P(x_i)})</script><p>我们探索 $C(P,P)-C(P,Q)$ 的正负性来判断 $P,Q$ 的关系. 因为 $\log(x)$ 是凹函数, 所以我们根据 Jensen 不等式, 可以得到:</p><script type="math/tex; mode=display">a_1\log(x_1)+a_2\log(x_2)+...+a_n\log(x_n)\le\log(a_1x_1+a_2x_2+...+a_nx_n),\quad(\sum_{i=1}^na_i=1)</script><p>我们将之代入 $\sum_{i=1}^nP(x_i)\log(\frac{Q(x_i)}{P(x_i)})$</p><p>$P(x_1)\log(\frac{Q(x_1)}{P(x_1)})+P(x_2)\log(\frac{Q(x_2)}{P(x_2)})+…+P(x_n)\log(\frac{Q(x_n)}{P(x_n)})\le\log(P(x_1)\frac{Q(x_1)}{P(x_1)}+P(x_2)\frac{Q(x_2)}{P(x_2)}+…+P(x_n)\frac{Q(x_n)}{P(x_n)})\le\log(Q(x_1)+Q(x_2)+…+Q(x_n))$</p><p>因此 $C(P,P)-C(P,Q)\le0$, 当且仅当 $P=Q$ 时等号成立.</p><h3 id="4-Cross-Entropy"><a href="#4-Cross-Entropy" class="headerlink" title="4. Cross Entropy"></a>4. Cross Entropy</h3><p>我们已经知道相对熵 (KL 散度)可以反映两个概率分布的距离情况. 由于P是样本已知的分布, 所以我们可以用KL散度反映Q这个模型产出的结果与P的距离. 距离越近, 往往说明模型的拟合效果越好, 能力越强.</p><p><strong>而 Cross Entropy 则只是KL散度去除掉了一个固定的定值的结果.</strong> </p><p>即 $C(P,Q)=-\sum_{i=1}^nP(x_i)\log(Q(x_i))$. KL散度能够反映P和Q分布的相似程度, 同样交叉熵也可以, 而且交叉熵的计算相比KL散度来说要更为精简一些.</p><p>比如我们只考虑二分类的场景, 那么 $C(P,Q)=-P(x=0)\log(Q(x=0))-P(x=1)\log(Q(x=1))$. 我们令 $P(x=0)=y,Q(x=0)=\hat{y}$.</p><p>所以上式可以变形为:</p><script type="math/tex; mode=display">C(P,Q)=-y\log(\hat{y})-(1-y)\log(1-\hat{y})</script><h3 id="5-Analysis"><a href="#5-Analysis" class="headerlink" title="5. Analysis"></a>5. Analysis</h3><p>当然, 到这里其实还没有结束. 仍然存在一个问题, 可以反映模型与真实分布距离的公式很多, 为什么我们训练模型的时候单单选择了交叉熵呢, 其他的公式不行吗? 为什么呢?</p><p>假设我们对模型: $\hat{y}=\sigma(\theta X)$ 选择 MSE(均方误差) 作为损失函数. </p><p>此时 $MSE=\frac{(\sigma(\theta X)-y)^2}{2}$</p><p>我们对它就关于 $\theta$ 的偏导:</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}MSE'=&(\sigma(\theta X)-y)\cdot\sigma'(\theta X)\cdot X \\=&0.98*2*\sigma(\theta X)\cdot(1-\sigma(\theta X)) \\=&0.04\end{aligned}\end{equation}</script><p>所以如果我们通过梯度下降来学习的话, $\theta_{next}=\theta-\alpha<em>0.04</em>\theta$.</p><p>这个式子看起来很正常, 但是隐藏了一个问题, 就是我们这样计算出来的梯度实在是太小了. 通过梯度下降去训练模型需要消耗大量的时间才能收敛.</p><p>如果我们将损失函数换成交叉熵呢?</p><p>我们回顾一下交叉熵求梯度之后的公式：</p><script type="math/tex; mode=display">\frac{\delta}{\delta\theta}J(\theta)=-(\hat{Y}-Y)\cdot X</script><p>我们带入上面具体的值, 可以算出来如果使用交叉上来训练, 我们算出来的梯度为1.96, 要比上面算出来的0.04大了太多了. 显然这样训练模型的收敛速度会快很多, 这也是为什么我们训练分类模型采用交叉熵作为损失函数的原因.</p><p>究其原因是因为如果我们使用MSE来训练模型的话, 在求梯度的过程当中免不了对sigmoid函数求导. 而正是因为sigmoid的导数值非常小, 才导致了我们梯度下降的速度如此缓慢. 那么为什么sigmoid函数的导数这么小呢? 我们来看下它的图像就知道了:</p><p><img src="https://cdn.jsdelivr.net/gh/alvisdeng/ImgHouse@main/image-20201112140643548.png" alt="image-20201112140643548" style="zoom:50%;" /></p><p>观察一下上面这个图像, 可以发现当x的绝对值大于4的时候, 也就是图像当中距离原点距离大于4的两侧, 函数图像就变得非常平缓. 而导数反应函数图像的切线的斜率, 显然这些区域的斜率都非常小, 而一开始参数稍微设置不合理, 很容易落到这些区间里. 那么通过梯度下降来迭代自然就会变得非常缓慢. 所以无论是机器学习还是深度学习, 我们一般都会少会对sigmoid函数进行梯度下降.</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习中常用的 Notation</title>
      <link href="2020/11/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84-Notation/"/>
      <url>2020/11/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84-Notation/</url>
      
        <content type="html"><![CDATA[<p>主要是介绍 Machine Learning 中常见的数学表达式, 有助于之后读论文的时候理解其中的步骤, 当然其他地方可能用的 Notation 会有不同的地方, 但万变不离其中. </p><blockquote><p>  Ok, Let’s enter the world of Machine Learning!!!</p></blockquote><p><img src="https://i.loli.net/2020/09/03/pg2GNTyUB7dFSw9.png" alt="10601_Notation_Guide-1"></p><p><img src="https://i.loli.net/2020/09/03/diEshmPI6RzfJBO.png" alt="10601_Notation_Guide-2"></p><p><img src="https://i.loli.net/2020/09/03/dDP6GOaQmhHUFuw.png" alt="10601_Notation_Guide-3"></p><p>注: 我在这里想解释一下其中的 <code>parameters</code> 和 <code>hyperparameters</code>:</p><ol><li><p><strong>model parameters</strong></p><p>模型参数是模型内部的配置变量, 其值可以根据数据进行估计.</p><ul><li>模型在进行预测时需要它们</li><li>它们的值定义了可使用的模型</li><li>他们是从数据估计或获悉的</li><li>它们通常不由编程者手动设置</li><li>他们通常被保存为学习模型的一部分</li></ul><p>在经典的机器学习文献中, 我们可以将模型看作假设, 将参数视为对特定数据集的量身打造的假设.</p></li><li><p><strong>model hyperparameters</strong></p><p>模型超参数是模型外部的配置, 其值无法从数据中估计.</p><ul><li>它们通常用于帮助估计模型参数</li><li>它们通常由人工指定</li><li>他们通常可以使用启发式设置</li><li>他们经常被调整为给定的预测建模问题</li></ul><p>我们虽然无法知道给定问题的模型超参数的最佳值, 但是我们可以使用经验法则, 在其他问题上使用复制值, 或通过反复试验来搜索最佳值. 模型超参数的一些例子包括:</p><ul><li>训练神经网络的学习速率</li><li>用于支持向量机的C和sigma超参数</li><li>K最近邻的K</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction to Pandas</title>
      <link href="2020/08/18/Introduction-to-Pandas/"/>
      <url>2020/08/18/Introduction-to-Pandas/</url>
      
        <content type="html"><![CDATA[<p>Pandas is a software library written for the Python programming language for data manipulation and analysis. In particular, it offers data structures and operations for manipulating numerical tables and time series.</p><h2 id="Topic-1-Data-Structure"><a href="#Topic-1-Data-Structure" class="headerlink" title="Topic 1 Data Structure"></a>Topic 1 Data Structure</h2><h3 id="1-1-Overview"><a href="#1-1-Overview" class="headerlink" title="1.1 Overview"></a>1.1 Overview</h3><p>Pandas包含以下三个<strong>数据结构</strong>: </p><ul><li>系列(<code>Series</code>)</li><li>数据帧(<code>DataFrame</code>)</li><li>面板(<code>Panel</code>)</li></ul><p>这些数据结构构建在<strong>Numpy</strong>数组之上，这意味着它们处理速度很快.</p><div class="table-container"><table><thead><tr><th style="text-align:center">数据结构</th><th style="text-align:center">维数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Series</td><td style="text-align:center">1</td><td style="text-align:center">一维数组, 大小<code>不</code>可变，由<strong>同种数据类型</strong>元素组成.</td></tr><tr><td style="text-align:center">DataFrame</td><td style="text-align:center">2</td><td style="text-align:center">二维数组, 大小<code>可变</code>的表格结构, 它含有一组有序的列, 每列可以是不同的数据类型（整型、字符串、 布尔值等）</td></tr><tr><td style="text-align:center">Panel</td><td style="text-align:center">3</td><td style="text-align:center">大小<code>可变</code>的三维数组</td></tr></tbody></table></div><p>可以简单理解为, 高维数据结构是低维数据结构的容器. 例如，<code>DataFrame</code>是<code>Series</code>的容器, <code>Panel</code>是<code>DataFrame</code>的容器.</p><h3 id="1-2-Series"><a href="#1-2-Series" class="headerlink" title="1.2 Series"></a>1.2 Series</h3><p>Series是由<strong>相同数据类型</strong>组成的一维数组. 有三个关键点:</p><ul><li>同种类型数据构成 (同 numpy 的 ndarray)</li><li>大小<code>不</code>可变</li><li>数据可变</li></ul><h3 id="1-3-DataFrame"><a href="#1-3-DataFrame" class="headerlink" title="1.3 DataFrame"></a>1.3 DataFrame</h3><p>数据帧 (<strong>DataFrame</strong>) 是大小可变的数据结构, 每列可以是不同的数据类型 (整型、字符串、布尔值等). 有三个关键点:</p><ul><li>可以由不同的数据类型构成</li><li>大小可变</li><li>数据可变</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">姓名</th><th style="text-align:center">年龄</th><th style="text-align:center">性别</th><th style="text-align:center">等级</th></tr></thead><tbody><tr><td style="text-align:center">Maxsu</td><td style="text-align:center">25</td><td style="text-align:center">男</td><td style="text-align:center">4.45</td></tr><tr><td style="text-align:center">Katie</td><td style="text-align:center">34</td><td style="text-align:center">女</td><td style="text-align:center">2.78</td></tr><tr><td style="text-align:center">Vina</td><td style="text-align:center">46</td><td style="text-align:center">女</td><td style="text-align:center">3.9</td></tr><tr><td style="text-align:center">Lia</td><td style="text-align:center">女</td><td style="text-align:center">女</td><td style="text-align:center">4.6</td></tr></tbody></table></div><p>上表表示某销售团队的绩效评级数据, 数据以行和列表示, 每列表示一个属性, 每行代表一个人. DataFrame 四列的数据类型分别为: 字符串, 整数, 字符串, 浮点型.</p><h3 id="1-4-Panel"><a href="#1-4-Panel" class="headerlink" title="1.4 Panel"></a>1.4 Panel</h3><p>面板(<strong>Panel</strong>)可以由不同的数据类型构成的三维数据结构, <code>Panel</code>是<code>DataFrame</code>的容器.</p><h2 id="Topic-2-Series"><a href="#Topic-2-Series" class="headerlink" title="Topic 2 Series"></a>Topic 2 Series</h2><p>序列 (<strong>Series</strong>) 是 pandas 中的一维数据结构，类似于 python 中的 list 和 <a href="https://facequant.com/2020/08/18/Introduction-to-Numpy/">Numpy</a> 中的 <code>ndarray</code> 对象,在 <code>Series</code> 中包含的数据类型可以是整数，浮点数，字符串，python对象等.</p><h3 id="2-1-Series-Creation"><a href="#2-1-Series-Creation" class="headerlink" title="2.1 Series Creation"></a>2.1 Series Creation</h3><p>Series 的构造函数如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pandas.Series(data, index, dtype, copy)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># data: 支持多种数据类型，如：ndarray, list ...</span></span><br><span class="line"><span class="comment"># index: 索引值必须是唯一的(set), 与data的长度相同, 默认为np.arange(n)</span></span><br><span class="line"><span class="comment"># dtype: 数据类型, 同 numpy 中介绍的数据类型</span></span><br><span class="line"><span class="comment"># copy: 是否复制数据, 默认为 False</span></span><br></pre></td></tr></table></figure><p><strong>[例 2.1] 创建一个空的 Series</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s = pd.Series()</span><br><span class="line">print(<span class="string">&#x27;空 Series:\n&#x27;</span>,s)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">空 Series:</span><br><span class="line"> Series([], dtype: float64)</span><br></pre></td></tr></table></figure><p><strong>[例 2.2] 从 ndarray 创建一个 Series</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">s = pd.Series(a)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0    a</span><br><span class="line">1    b</span><br><span class="line">2    c</span><br><span class="line">3    d</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure><p><strong>注:</strong></p><p>我们其实可以根据实际情况传入索引, 也就是左边那一列</p><p><strong>[例 2.3]</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">s = pd.Series(a,index=[<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>])</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">100    a</span><br><span class="line">101    b</span><br><span class="line">102    c</span><br><span class="line">103    d</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure><p><strong>[例 2.4] 从字典创建一个 Series</strong></p><p><code>key</code> 是 <code>index</code>, <code>value</code> 是 <code>Series</code> 的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">a = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line">s = pd.Series(a)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a    1</span><br><span class="line">b    2</span><br><span class="line">c    3</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p><strong>注:</strong></p><p>我们也可以传入索引</p><p><strong>[例 2.5]</strong></p><p>索引顺序保持不变, 缺少的元素使用NaN(不是数字)填充.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">a = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line">s = pd.Series(a,index=[<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b    2.0</span><br><span class="line">c    3.0</span><br><span class="line">d    NaN</span><br><span class="line">e    NaN</span><br><span class="line">a    1.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p><strong>[例 2.6] 从标量创建一个 Series</strong></p><p>如果数据是标量类型, 则<strong>必须提供索引</strong>. 重复该值以匹配索引的长度.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s = pd.Series(<span class="number">5</span>, index=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0    5</span><br><span class="line">1    5</span><br><span class="line">2    5</span><br><span class="line">3    5</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><h3 id="2-2-Reading-Series"><a href="#2-2-Reading-Series" class="headerlink" title="2.2 Reading Series"></a>2.2 Reading Series</h3><p>Series 中的数据可以使用类似于访问 <code>ndarray</code> 中的数据来访问.</p><p><strong>[例 2.7] 检索第一个元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">print(<span class="string">&#x27;获取第一个元素:\n&#x27;</span>,s[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取第一个元素:</span><br><span class="line"> 1</span><br></pre></td></tr></table></figure><p><strong>[例 2.8] 获取前三个元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">print(<span class="string">&#x27;获取前三个元素:&#x27;</span>)</span><br><span class="line">print(s[:<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获取前三个元素:</span><br><span class="line">a    1</span><br><span class="line">b    2</span><br><span class="line">c    3</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p>我们也能通过 <code>Series</code> 的 <code>index</code> 来访问其数据.</p><p><strong>[例 2.9] 使用 index 访问单个数据</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">print(<span class="string">&#x27;访问索引为 d 的元素:\n&#x27;</span>,s[<span class="string">&#x27;d&#x27;</span>])</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问索引为 d 的元素:</span><br><span class="line"> 4</span><br></pre></td></tr></table></figure><p><strong>[例 2.10] 使用索引访问多个元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">print(<span class="string">&#x27;使用索引访问多个元素:&#x27;</span>)</span><br><span class="line">print(s[[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]])</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用索引访问多个元素:</span><br><span class="line">a    1</span><br><span class="line">c    3</span><br><span class="line">d    4</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><h3 id="2-3-Properties-of-Series"><a href="#2-3-Properties-of-Series" class="headerlink" title="2.3 Properties of Series"></a>2.3 Properties of Series</h3><div class="table-container"><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>axes</code></td><td>返回 Series 的索引列表</td></tr><tr><td><code>dtype</code></td><td>返回 Series 的数据类型</td></tr><tr><td><code>empty</code></td><td>判断 Series 是否为空, 若为空, 返回 True</td></tr><tr><td><code>ndim</code></td><td>返回基础数据的维数</td></tr><tr><td><code>size</code></td><td>返回基础数据中的元素个数</td></tr><tr><td><code>values</code></td><td>将 Series 作为 <code>ndarray</code> 返回</td></tr><tr><td><code>head()</code></td><td>返回前 n 个元素</td></tr><tr><td><code>tail()</code></td><td>返回最后 n 个元素</td></tr></tbody></table></div><h4 id="2-3-1-Series-axes"><a href="#2-3-1-Series-axes" class="headerlink" title="2.3.1 Series.axes"></a>2.3.1 Series.axes</h4><p><strong>[例 2.11] 返回 Series 的索引列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">s = pd.Series(np.random.randn(<span class="number">4</span>))</span><br><span class="line">print(<span class="string">&#x27;数据的索引是:\n&#x27;</span>,s.axes)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据的索引是:</span><br><span class="line"> [RangeIndex(start&#x3D;0, stop&#x3D;4, step&#x3D;1)]</span><br></pre></td></tr></table></figure><h4 id="2-3-2-Series-empty"><a href="#2-3-2-Series-empty" class="headerlink" title="2.3.2 Series.empty"></a>2.3.2 Series.empty</h4><p><strong>[例 2.12] 查看 Series 是否为空</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">s = pd.Series(np.random.randn(<span class="number">4</span>))</span><br><span class="line">print(<span class="string">&#x27;数据为空?\n&#x27;</span>,s.empty)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据为空?</span><br><span class="line"> False</span><br></pre></td></tr></table></figure><h4 id="2-3-3-Series-ndim"><a href="#2-3-3-Series-ndim" class="headerlink" title="2.3.3 Series.ndim"></a>2.3.3 Series.ndim</h4><p><strong>[例 2.13] 返回数据的维数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">s = pd.Series(np.random.randn(<span class="number">4</span>))</span><br><span class="line">print(<span class="string">&#x27;数据的维数:\n&#x27;</span>,s.ndim)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据的维数:</span><br><span class="line"> 1</span><br></pre></td></tr></table></figure><h4 id="2-3-4-Series-size"><a href="#2-3-4-Series-size" class="headerlink" title="2.3.4 Series.size"></a>2.3.4 Series.size</h4><p><strong>[例 2.14] 查看 Series 中的元素个数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">s = pd.Series(np.random.randn(<span class="number">4</span>))</span><br><span class="line">print(<span class="string">&#x27;Series 包含的元素个数:\n&#x27;</span>,s.size)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Series 包含的元素个数:</span><br><span class="line"> 4</span><br></pre></td></tr></table></figure><h4 id="2-3-5-Series-values"><a href="#2-3-5-Series-values" class="headerlink" title="2.3.5 Series.values"></a>2.3.5 Series.values</h4><p><strong>[例 2.15] 将 Series 作为 ndarray 返回</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">s = pd.Series(np.random.randn(<span class="number">4</span>))</span><br><span class="line">print(<span class="string">&#x27;我们的数据是:\n&#x27;</span>,s)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;将数据转换成 ndarray.&#x27;</span>)</span><br><span class="line">a = s.values</span><br><span class="line">print(<span class="string">&#x27;数据类型是:\n&#x27;</span>,<span class="built_in">type</span>(a))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line"> 0    0.139829</span><br><span class="line">1   -0.858539</span><br><span class="line">2   -0.060587</span><br><span class="line">3    0.087893</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">将数据转换成 ndarray.</span><br><span class="line">数据类型是:</span><br><span class="line"> &lt;class &#39;numpy.ndarray&#39;&gt;</span><br></pre></td></tr></table></figure><h2 id="Topic-3-DataFrame"><a href="#Topic-3-DataFrame" class="headerlink" title="Topic 3 DataFrame"></a>Topic 3 DataFrame</h2><p><code>DataFrame</code> 是二维数据结构, 它包含一组有序的列, 每列可以是不同的数据类型, <code>DataFrame</code>既有行索引, 也有列索引, 它可以看作是<code>Series</code>组成的字典, 不过这些<code>Series</code>共用一个索引. 其包含以下几个功能特点:</p><ul><li>不同的列可以是不同的数据类型</li><li>大小可变</li><li>包含行索引和列索引</li><li>可以对行和列执行算术运算</li></ul><h3 id="3-1-DataFrame-Creation"><a href="#3-1-DataFrame-Creation" class="headerlink" title="3.1 DataFrame Creation"></a>3.1 DataFrame Creation</h3><p>DataFrame 的构造函数如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pandas.DataFrame(data, index, columns, dtype, copy)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># data: 支持多种数据类型，如:ndarray，series, lists, dict, constant 或另外一个 DataFrame</span></span><br><span class="line"><span class="comment"># index: 行标签, 如果没有传递索引值, 默认值为np.arange(n)</span></span><br><span class="line"><span class="comment"># columns: 列标签, 如果没有传递索引值, 默认值为np.arange(n)</span></span><br><span class="line"><span class="comment"># dtype: 每列的数据类型</span></span><br><span class="line"><span class="comment"># copy: 是否复制数据, 默认为 False</span></span><br></pre></td></tr></table></figure><p><strong>[例 3.1] 创建一个空的 DataFrame</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame()</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Empty DataFrame</span><br><span class="line">Columns: []</span><br><span class="line">Index: []</span><br></pre></td></tr></table></figure><p><strong>[例 3.2] 从一个二维列表创建 DataFrame</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">l = [[<span class="string">&#x27;Alex&#x27;</span>,<span class="number">10</span>],[<span class="string">&#x27;Bob&#x27;</span>,<span class="number">12</span>],[<span class="string">&#x27;Clarke&#x27;</span>,<span class="number">13</span>]]</span><br><span class="line">df = pd.DataFrame(l, columns=[<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     Name  Age</span><br><span class="line">0    Alex   10</span><br><span class="line">1     Bob   12</span><br><span class="line">2  Clarke   13</span><br></pre></td></tr></table></figure><p><strong>[例 3.3] 从一个 dict 创建 DataFrame</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;Name&#x27;</span>:[<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,<span class="string">&#x27;Steve&#x27;</span>,<span class="string">&#x27;Ricky&#x27;</span>],<span class="string">&#x27;Age&#x27;</span>:[<span class="number">28</span>,<span class="number">34</span>,<span class="number">29</span>,<span class="number">42</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data, index=[<span class="string">&#x27;1st&#x27;</span>,<span class="string">&#x27;2nd&#x27;</span>,<span class="string">&#x27;3rd&#x27;</span>,<span class="string">&#x27;4th&#x27;</span>])</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      Name  Age</span><br><span class="line">1st    Tom   28</span><br><span class="line">2nd   Jack   34</span><br><span class="line">3rd  Steve   29</span><br><span class="line">4th  Ricky   42</span><br></pre></td></tr></table></figure><p><strong>[例 3.4] 从 ndarray 创建 DataFrame</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="string">&#x27;Tom&#x27;</span>,<span class="number">28</span>],[<span class="string">&#x27;Jack&#x27;</span>,<span class="number">34</span>],[<span class="string">&#x27;Steve&#x27;</span>,<span class="number">29</span>],[<span class="string">&#x27;Ricky&#x27;</span>,<span class="number">42</span>]])</span><br><span class="line">df = pd.DataFrame(a, index=[<span class="string">&#x27;1st&#x27;</span>,<span class="string">&#x27;2nd&#x27;</span>,<span class="string">&#x27;3rd&#x27;</span>,<span class="string">&#x27;4th&#x27;</span>],columns=[<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      Name Age</span><br><span class="line">1st    Tom  28</span><br><span class="line">2nd   Jack  34</span><br><span class="line">3rd  Steve  29</span><br><span class="line">4th  Ricky  42</span><br></pre></td></tr></table></figure><p><strong>[例 3.5] 从 Series 字典来创建 DataFrame</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">      <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   one  two</span><br><span class="line">a  1.0    1</span><br><span class="line">b  2.0    2</span><br><span class="line">c  3.0    3</span><br><span class="line">d  NaN    4</span><br></pre></td></tr></table></figure><h3 id="3-2-DataFrame-Operations"><a href="#3-2-DataFrame-Operations" class="headerlink" title="3.2 DataFrame Operations"></a>3.2 DataFrame Operations</h3><h4 id="3-2-1-Reading-Data-from-Columns"><a href="#3-2-1-Reading-Data-from-Columns" class="headerlink" title="3.2.1 Reading Data from Columns"></a>3.2.1 Reading Data from Columns</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="string">&#x27;Tom&#x27;</span>,<span class="number">28</span>],[<span class="string">&#x27;Jack&#x27;</span>,<span class="number">34</span>],[<span class="string">&#x27;Steve&#x27;</span>,<span class="number">29</span>],[<span class="string">&#x27;Ricky&#x27;</span>,<span class="number">42</span>]])</span><br><span class="line">df = pd.DataFrame(a, index=[<span class="string">&#x27;1st&#x27;</span>,<span class="string">&#x27;2nd&#x27;</span>,<span class="string">&#x27;3rd&#x27;</span>,<span class="string">&#x27;4th&#x27;</span>],columns=[<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line">print(df[<span class="string">&#x27;Name&#x27;</span>])  <span class="comment"># 也可以是 print(df.Name)</span></span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1st      Tom</span><br><span class="line">2nd     Jack</span><br><span class="line">3rd    Steve</span><br><span class="line">4th    Ricky</span><br><span class="line">Name: Name, dtype: object</span><br></pre></td></tr></table></figure><h4 id="3-2-2-Reading-Data-from-Rows"><a href="#3-2-2-Reading-Data-from-Rows" class="headerlink" title="3.2.2 Reading Data from Rows"></a>3.2.2 Reading Data from Rows</h4><p>有两种方式读取行数据:</p><ul><li><p>使用 <code>DataFrame.loc[]</code> 依据行索引进行读取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="string">&#x27;Tom&#x27;</span>,<span class="number">28</span>],[<span class="string">&#x27;Jack&#x27;</span>,<span class="number">34</span>],[<span class="string">&#x27;Steve&#x27;</span>,<span class="number">29</span>],[<span class="string">&#x27;Ricky&#x27;</span>,<span class="number">42</span>]])</span><br><span class="line">df = pd.DataFrame(a, index=[<span class="string">&#x27;1st&#x27;</span>,<span class="string">&#x27;2nd&#x27;</span>,<span class="string">&#x27;3rd&#x27;</span>,<span class="string">&#x27;4th&#x27;</span>],columns=[<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;第三行的数据是:&#x27;</span>)</span><br><span class="line">print(df.loc[<span class="string">&#x27;3rd&#x27;</span>])</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第三行的数据是:</span><br><span class="line">Name    Steve</span><br><span class="line">Age        29</span><br><span class="line">Name: 3rd, dtype: object</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>DataFrame.iloc[]</code> 依据 row number 进行读取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="string">&#x27;Tom&#x27;</span>,<span class="number">28</span>],[<span class="string">&#x27;Jack&#x27;</span>,<span class="number">34</span>],[<span class="string">&#x27;Steve&#x27;</span>,<span class="number">29</span>],[<span class="string">&#x27;Ricky&#x27;</span>,<span class="number">42</span>]])</span><br><span class="line">df = pd.DataFrame(a, index=[<span class="string">&#x27;1st&#x27;</span>,<span class="string">&#x27;2nd&#x27;</span>,<span class="string">&#x27;3rd&#x27;</span>,<span class="string">&#x27;4th&#x27;</span>],columns=[<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;倒数两行的数据是:&#x27;</span>)</span><br><span class="line">print(df.iloc[-<span class="number">2</span>:])</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">倒数两行的数据是:</span><br><span class="line">      Name Age</span><br><span class="line">3rd  Steve  29</span><br><span class="line">4th  Ricky  42</span><br></pre></td></tr></table></figure><h4 id="3-2-3-Adding-and-Deleting-Columns"><a href="#3-2-3-Adding-and-Deleting-Columns" class="headerlink" title="3.2.3 Adding and Deleting Columns"></a>3.2.3 Adding and Deleting Columns</h4></li></ul><p><strong>添加列有两种方式:</strong></p><ul><li>传入新的 Series</li><li>利用现有列</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="string">&#x27;Tom&#x27;</span>,<span class="number">28</span>],[<span class="string">&#x27;Jack&#x27;</span>,<span class="number">34</span>],[<span class="string">&#x27;Steve&#x27;</span>,<span class="number">29</span>],[<span class="string">&#x27;Ricky&#x27;</span>,<span class="number">42</span>]])</span><br><span class="line">df = pd.DataFrame(a, index=[<span class="string">&#x27;1st&#x27;</span>,<span class="string">&#x27;2nd&#x27;</span>,<span class="string">&#x27;3rd&#x27;</span>,<span class="string">&#x27;4th&#x27;</span>],columns=[<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line">print(<span class="string">&#x27;原 DataFrame:&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;通过传入一个新的 Series 来增加新列:&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;Sex&#x27;</span>] = pd.Series([<span class="string">&#x27;Male&#x27;</span>,<span class="string">&#x27;Male&#x27;</span>,<span class="string">&#x27;Male&#x27;</span>,<span class="string">&#x27;Female&#x27;</span>],index=[<span class="string">&#x27;1st&#x27;</span>,<span class="string">&#x27;2nd&#x27;</span>,<span class="string">&#x27;3rd&#x27;</span>,<span class="string">&#x27;4th&#x27;</span>])</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;通过操作已有列来增加新列:&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;Name and Sex&#x27;</span>] = df[<span class="string">&#x27;Name&#x27;</span>] + df[<span class="string">&#x27;Sex&#x27;</span>]</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">原 DataFrame:</span><br><span class="line">      Name Age</span><br><span class="line">1st    Tom  28</span><br><span class="line">2nd   Jack  34</span><br><span class="line">3rd  Steve  29</span><br><span class="line">4th  Ricky  42</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过传入一个新的 Series 来增加新列:</span><br><span class="line">      Name Age     Sex</span><br><span class="line">1st    Tom  28    Male</span><br><span class="line">2nd   Jack  34    Male</span><br><span class="line">3rd  Steve  29    Male</span><br><span class="line">4th  Ricky  42  Female</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过操作已有列来增加新列:</span><br><span class="line">      Name Age     Sex Name and Sex</span><br><span class="line">1st    Tom  28    Male      TomMale</span><br><span class="line">2nd   Jack  34    Male     JackMale</span><br><span class="line">3rd  Steve  29    Male    SteveMale</span><br><span class="line">4th  Ricky  42  Female  RickyFemale</span><br></pre></td></tr></table></figure><p><strong>删除列有两种方式:</strong></p><ul><li>使用 <code>del</code> 关键字</li><li>使用 <code>DataFrame.pop()</code> 函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="string">&#x27;Tom&#x27;</span>,<span class="number">28</span>],[<span class="string">&#x27;Jack&#x27;</span>,<span class="number">34</span>],[<span class="string">&#x27;Steve&#x27;</span>,<span class="number">29</span>],[<span class="string">&#x27;Ricky&#x27;</span>,<span class="number">42</span>]])</span><br><span class="line">df = pd.DataFrame(a, index=[<span class="string">&#x27;1st&#x27;</span>,<span class="string">&#x27;2nd&#x27;</span>,<span class="string">&#x27;3rd&#x27;</span>,<span class="string">&#x27;4th&#x27;</span>],columns=[<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line">df[<span class="string">&#x27;Sex&#x27;</span>] = pd.Series([<span class="string">&#x27;Male&#x27;</span>,<span class="string">&#x27;Male&#x27;</span>,<span class="string">&#x27;Male&#x27;</span>,<span class="string">&#x27;Female&#x27;</span>],index=[<span class="string">&#x27;1st&#x27;</span>,<span class="string">&#x27;2nd&#x27;</span>,<span class="string">&#x27;3rd&#x27;</span>,<span class="string">&#x27;4th&#x27;</span>])</span><br><span class="line">print(<span class="string">&#x27;原 DataFrame:&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;使用 del 关键字:&#x27;</span>)</span><br><span class="line"><span class="keyword">del</span> df[<span class="string">&#x27;Sex&#x27;</span>]</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;使用 DataFrame.pop() 函数&#x27;</span>) <span class="comment"># 如你在 python 中学的 pop 函数一样, 这个函数会返回该列</span></span><br><span class="line">print(<span class="string">&#x27;返回列:&#x27;</span>)</span><br><span class="line">df.pop(<span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line">print()</span><br><span class="line">print(<span class="string">&#x27;修改之后的 DataFrame:&#x27;</span>)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">原 DataFrame:</span><br><span class="line">      Name Age     Sex</span><br><span class="line">1st    Tom  28    Male</span><br><span class="line">2nd   Jack  34    Male</span><br><span class="line">3rd  Steve  29    Male</span><br><span class="line">4th  Ricky  42  Female</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用 del 关键字:</span><br><span class="line">      Name Age</span><br><span class="line">1st    Tom  28</span><br><span class="line">2nd   Jack  34</span><br><span class="line">3rd  Steve  29</span><br><span class="line">4th  Ricky  42</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用 DataFrame.pop() 函数</span><br><span class="line">返回列:</span><br><span class="line">1st    28</span><br><span class="line">2nd    34</span><br><span class="line">3rd    29</span><br><span class="line">4th    42</span><br><span class="line">Name: Age, dtype: object</span><br><span class="line"></span><br><span class="line">修改之后的 DataFrame:</span><br><span class="line">      Name</span><br><span class="line">1st    Tom</span><br><span class="line">2nd   Jack</span><br><span class="line">3rd  Steve</span><br><span class="line">4th  Ricky</span><br></pre></td></tr></table></figure><h4 id="3-2-4-Adding-and-Deleting-Rows"><a href="#3-2-4-Adding-and-Deleting-Rows" class="headerlink" title="3.2.4 Adding and Deleting Rows"></a>3.2.4 Adding and Deleting Rows</h4><p><strong>添加行只有一种方式:</strong> <code>DataFrame.append(pandas.DataFrame)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df1 = pd.DataFrame([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],columns=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]],columns=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;df1:&#x27;</span>)</span><br><span class="line">print(df1)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;df2:&#x27;</span>)</span><br><span class="line">print(df2)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;将 df2 添加到 df1 之后:&#x27;</span>)</span><br><span class="line">print(df1.append(df2))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">df1:</span><br><span class="line">   a  b</span><br><span class="line">0  1  2</span><br><span class="line">1  3  4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">df2:</span><br><span class="line">   a  b</span><br><span class="line">0  5  6</span><br><span class="line">1  7  8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">将 df2 添加到 df1 之后:</span><br><span class="line">   a  b</span><br><span class="line">0  1  2</span><br><span class="line">1  3  4</span><br><span class="line">0  5  6</span><br><span class="line">1  7  8</span><br></pre></td></tr></table></figure><p><strong>使用索引标签从 DataFrame 中删除行. 如果标签重复, 则会删除多行.</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df1 = pd.DataFrame([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],columns=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]],columns=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line">df1 = df1.append(df2)</span><br><span class="line">print(<span class="string">&#x27;删除行标为 0 的行:&#x27;</span>)</span><br><span class="line">df1 = df1.drop(<span class="number">0</span>)</span><br><span class="line">print(df1)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">删除行标为 0 的行:</span><br><span class="line">   a  b</span><br><span class="line">1  3  4</span><br><span class="line">1  7  8</span><br></pre></td></tr></table></figure><h4 id="3-2-5-Reindexing-and-Renaming"><a href="#3-2-5-Reindexing-and-Renaming" class="headerlink" title="3.2.5 Reindexing and Renaming"></a>3.2.5 Reindexing and Renaming</h4><ol><li><p>DataFrame.reindex()</p><p><strong>我们首先看对 Series 重新索引</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"></span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">9</span>],index=[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;f&#x27;</span>])</span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(s)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;reindex 函数会对数据重新排序, 缺失值会有 NaN 填补:&#x27;</span>)</span><br><span class="line">s = s.reindex(index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>])</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line">d    1</span><br><span class="line">c    7</span><br><span class="line">a    3</span><br><span class="line">f    9</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">reindex 函数会对数据重新排序, 缺失值会有 NaN 填补:</span><br><span class="line">a    3.0</span><br><span class="line">b    NaN</span><br><span class="line">c    7.0</span><br><span class="line">d    1.0</span><br><span class="line">e    NaN</span><br><span class="line">f    9.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p><strong>和 <code>fillna()</code> 函数一样, reindex 可以选择重新索引时的数据插入方式来填补缺失值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s = pd.Series([<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;black&#x27;</span>],index=[<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>])</span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(s)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;reindex 之后数据是:&#x27;</span>)</span><br><span class="line">s = s.reindex(index=<span class="built_in">range</span>(<span class="number">6</span>),method=<span class="string">&#x27;ffill&#x27;</span>) <span class="comment"># 前向填充</span></span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line">0     blue</span><br><span class="line">2      red</span><br><span class="line">4    black</span><br><span class="line">dtype: object</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">reindex 之后数据是:</span><br><span class="line">0     blue</span><br><span class="line">1     blue</span><br><span class="line">2      red</span><br><span class="line">3      red</span><br><span class="line">4    black</span><br><span class="line">5    black</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure><p><strong>我们再来看一下对 DataFrame 的索引</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">s = pd.DataFrame(np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>), index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>], columns=[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;four&#x27;</span>])</span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>) </span><br><span class="line">print(s)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;使用 reindex 填充数据, 传入参数 fill_value 可以填充缺失值:&#x27;</span>)</span><br><span class="line">s = s.reindex(index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>],columns=[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>,<span class="string">&#x27;four&#x27;</span>],fill_value=<span class="number">100</span>)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line">   one  two  four</span><br><span class="line">a    0    1     2</span><br><span class="line">c    3    4     5</span><br><span class="line">d    6    7     8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用 reindex 填充数据, 传入参数 fill_value 可以填充缺失值:</span><br><span class="line">   one  two  three  four</span><br><span class="line">a    0    1    100     2</span><br><span class="line">b  100  100    100   100</span><br><span class="line">c    3    4    100     5</span><br><span class="line">d    6    7    100     8</span><br></pre></td></tr></table></figure></li><li><p>DataFrame.rename()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&quot;A&quot;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&quot;B&quot;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line">df.rename(columns=&#123;<span class="string">&quot;A&quot;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;B&quot;</span>: <span class="string">&quot;c&quot;</span>&#125;)</span><br><span class="line">   a  c</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">6</span></span><br><span class="line"></span><br><span class="line">df.rename(index=&#123;<span class="number">0</span>: <span class="string">&quot;x&quot;</span>, <span class="number">1</span>: <span class="string">&quot;y&quot;</span>, <span class="number">2</span>: <span class="string">&quot;z&quot;</span>&#125;)</span><br><span class="line">   A  B</span><br><span class="line">x  <span class="number">1</span>  <span class="number">4</span></span><br><span class="line">y  <span class="number">2</span>  <span class="number">5</span></span><br><span class="line">z  <span class="number">3</span>  <span class="number">6</span></span><br><span class="line"></span><br><span class="line">df.rename(<span class="built_in">str</span>.lower, axis=<span class="string">&#x27;columns&#x27;</span>)</span><br><span class="line">   a  b</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">6</span></span><br><span class="line"></span><br><span class="line">df.rename(&#123;<span class="number">1</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="number">4</span>&#125;, axis=<span class="string">&#x27;index&#x27;</span>)</span><br><span class="line">   A  B</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">4</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2</span>  <span class="number">5</span></span><br><span class="line"><span class="number">4</span>  <span class="number">3</span>  <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="3-3-Properties-of-DataFrame"><a href="#3-3-Properties-of-DataFrame" class="headerlink" title="3.3 Properties of DataFrame"></a>3.3 Properties of DataFrame</h3></li></ol><div class="table-container"><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>T</code></td><td>转置行和列</td></tr><tr><td><code>axes</code></td><td>返回 DataFrame 的行和列标签</td></tr><tr><td><code>dtype</code></td><td>返回 DataFrame 中每一列的数据类型</td></tr><tr><td><code>empty</code></td><td>若 DataFrame 为空, 则返回 <code>True</code></td></tr><tr><td><code>ndim</code></td><td>返回 DataFrame 维度的数量, 默认为 <code>2</code></td></tr><tr><td><code>shape</code></td><td>返回 DataFrame 的维度</td></tr><tr><td><code>size</code></td><td>返回 DataFrame 中元素的个数</td></tr><tr><td><code>values</code></td><td>将 DataFrame 中的数据以 <code>ndarray</code> 返回</td></tr><tr><td><code>head()</code></td><td>返回开头前 <code>n</code> 行</td></tr><tr><td><code>tail()</code></td><td>返回最后 <code>n</code> 行</td></tr></tbody></table></div><h4 id="3-3-1-DataFrame-T"><a href="#3-3-1-DataFrame-T" class="headerlink" title="3.3.1 DataFrame.T"></a>3.3.1 DataFrame.T</h4><p>返回<code>DataFrame</code>的转置, 行和列将交换:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;James&#x27;</span>,<span class="string">&#x27;Ricky&#x27;</span>,<span class="string">&#x27;Vin&#x27;</span>,<span class="string">&#x27;Steve&#x27;</span>,<span class="string">&#x27;Minsu&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;Age&#x27;</span>:pd.Series([<span class="number">25</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">23</span>,<span class="number">30</span>,<span class="number">29</span>,<span class="number">23</span>]),</span><br><span class="line">   <span class="string">&#x27;Rating&#x27;</span>:pd.Series([<span class="number">4.23</span>,<span class="number">3.24</span>,<span class="number">3.98</span>,<span class="number">2.56</span>,<span class="number">3.20</span>,<span class="number">4.6</span>,<span class="number">3.8</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line">print(<span class="string">&#x27;原数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;转置之后的数据是:&#x27;</span>)</span><br><span class="line">print(df.T)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">原数据是:</span><br><span class="line">    Name  Age  Rating</span><br><span class="line">0    Tom   25    4.23</span><br><span class="line">1  James   26    3.24</span><br><span class="line">2  Ricky   25    3.98</span><br><span class="line">3    Vin   23    2.56</span><br><span class="line">4  Steve   30    3.20</span><br><span class="line">5  Minsu   29    4.60</span><br><span class="line">6   Jack   23    3.80</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">转置之后的数据是:</span><br><span class="line">           0      1      2     3      4      5     6</span><br><span class="line">Name     Tom  James  Ricky   Vin  Steve  Minsu  Jack</span><br><span class="line">Age       25     26     25    23     30     29    23</span><br><span class="line">Rating  4.23   3.24   3.98  2.56    3.2    4.6   3.8</span><br></pre></td></tr></table></figure><h4 id="3-3-2-DataFrame-axes"><a href="#3-3-2-DataFrame-axes" class="headerlink" title="3.3.2 DataFrame.axes"></a>3.3.2 DataFrame.axes</h4><p>返回 <code>DataFrame</code> 的行轴标签和列轴标签列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;James&#x27;</span>,<span class="string">&#x27;Ricky&#x27;</span>,<span class="string">&#x27;Vin&#x27;</span>,<span class="string">&#x27;Steve&#x27;</span>,<span class="string">&#x27;Minsu&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;Age&#x27;</span>:pd.Series([<span class="number">25</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">23</span>,<span class="number">30</span>,<span class="number">29</span>,<span class="number">23</span>]),</span><br><span class="line">   <span class="string">&#x27;Rating&#x27;</span>:pd.Series([<span class="number">4.23</span>,<span class="number">3.24</span>,<span class="number">3.98</span>,<span class="number">2.56</span>,<span class="number">3.20</span>,<span class="number">4.6</span>,<span class="number">3.8</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line">print(<span class="string">&#x27;行标签和列标签是:&#x27;</span>)</span><br><span class="line">print(df.axes)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">行标签和列标签是:</span><br><span class="line">[RangeIndex(start&#x3D;0, stop&#x3D;7, step&#x3D;1), Index([&#39;Name&#39;, &#39;Age&#39;, &#39;Rating&#39;], dtype&#x3D;&#39;object&#39;)]</span><br></pre></td></tr></table></figure><h4 id="3-3-3-DataFrame-dtypes"><a href="#3-3-3-DataFrame-dtypes" class="headerlink" title="3.3.3 DataFrame.dtypes"></a>3.3.3 DataFrame.dtypes</h4><p>返回每列的数据类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;James&#x27;</span>,<span class="string">&#x27;Ricky&#x27;</span>,<span class="string">&#x27;Vin&#x27;</span>,<span class="string">&#x27;Steve&#x27;</span>,<span class="string">&#x27;Minsu&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;Age&#x27;</span>:pd.Series([<span class="number">25</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">23</span>,<span class="number">30</span>,<span class="number">29</span>,<span class="number">23</span>]),</span><br><span class="line">   <span class="string">&#x27;Rating&#x27;</span>:pd.Series([<span class="number">4.23</span>,<span class="number">3.24</span>,<span class="number">3.98</span>,<span class="number">2.56</span>,<span class="number">3.20</span>,<span class="number">4.6</span>,<span class="number">3.8</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line">print(<span class="string">&#x27;每列的数据类型:&#x27;</span>)</span><br><span class="line">print(df.dtypes)</span><br></pre></td></tr></table></figure><p>数据类型是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每列的数据类型:</span><br><span class="line">Name       object</span><br><span class="line">Age         int64</span><br><span class="line">Rating    float64</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure><h3 id="3-4-DataFrame-MultiIndex"><a href="#3-4-DataFrame-MultiIndex" class="headerlink" title="3.4 DataFrame MultiIndex"></a>3.4 DataFrame MultiIndex</h3><p><code>MultiIndex</code> 表示多级索引, 它是从Index继承过来的, 其中多级标签用<strong>元组对象</strong>来表示.</p><h4 id="3-4-1-MultiIndex-Creation"><a href="#3-4-1-MultiIndex-Creation" class="headerlink" title="3.4.1 MultiIndex Creation"></a>3.4.1 MultiIndex Creation</h4><p>我们主要使用 <code>pandas.MultiIndex.from_arrays()</code> 来创建多级索引.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">class1=[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">class2=[<span class="string">&quot;x1&quot;</span>,<span class="string">&quot;x2&quot;</span>,<span class="string">&quot;y1&quot;</span>,<span class="string">&quot;y2&quot;</span>,<span class="string">&#x27;y3&#x27;</span>]</span><br><span class="line">multi_index=pd.MultiIndex.from_arrays([class1,class2],names=[<span class="string">&quot;class1&quot;</span>,<span class="string">&quot;class2&quot;</span>])</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(np.random.randint(<span class="number">1</span>,<span class="number">10</span>,(<span class="number">5</span>,<span class="number">3</span>)),index=multi_index)</span><br><span class="line">df</span><br></pre></td></tr></table></figure><p>输出结果是:</p><p><img src="https://i.loli.net/2020/08/21/7GHsnroSXdzyfvV.png" alt="image-20200821172656280" style="zoom:50%;" /></p><blockquote><p>  <strong>Series和DataFrame的列名称属性就是columns, 他也可以是一个 <code>MultiIndex</code> 对象:</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">arrays = [[<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">multi_index = pd.MultiIndex.from_arrays(arrays,names=[<span class="string">&#x27;FirstLevel&#x27;</span>,<span class="string">&#x27;SecondLevel&#x27;</span>])</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">3</span>, <span class="number">8</span>), index=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>], columns=multi_index)</span><br><span class="line">df</span><br></pre></td></tr></table></figure><p>  输出结果是:</p><p>  <img src="https://i.loli.net/2020/08/23/ACMJFl8EWd7fvhN.png" alt="image-20200821173753159"></p></blockquote><h4 id="3-4-2-Use-of-MultiIndex"><a href="#3-4-2-Use-of-MultiIndex" class="headerlink" title="3.4.2 Use of MultiIndex"></a>3.4.2 Use of MultiIndex</h4><p><strong>我们再来看一下如何使用 MultiIndex 选择数据</strong></p><p><strong>首先, 获取FirstLevel是bar的所有数据:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;bar&#x27;</span>]</span><br></pre></td></tr></table></figure><p>输出结果是:</p><p><img src="https://i.loli.net/2020/08/21/XHK2ysD9a8RFvM5.png" alt="image-20200821173853310" style="zoom:50%;" /></p><p><strong>获取FirstLevel是bar, SecondLevel是one的所有数据:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;bar&#x27;</span>,<span class="string">&#x27;one&#x27;</span>] <span class="comment"># 也可以是 df[&#x27;bar&#x27;][&#x27;one&#x27;]</span></span><br></pre></td></tr></table></figure><p>输出结果是:</p><p><img src="https://i.loli.net/2020/08/21/hWNnX8Lufr1G6Ji.png" alt="image-20200821173956442" style="zoom:50%;" /></p><p><strong>如果要选择第二层的列名为one的所有数据, 我们需要借助xs方法:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.xs(<span class="string">&#x27;one&#x27;</span>,level=<span class="number">1</span>,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><p><img src="https://i.loli.net/2020/08/21/uYSspi8VErZhPvF.png" alt="image-20200821174211172" style="zoom:50%;" /></p><p><strong>或者使用名称代替数字:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.xs(<span class="string">&#x27;one&#x27;</span>, level=<span class="string">&#x27;SecondLevel&#x27;</span>, axis=<span class="string">&#x27;columns&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><p><img src="https://i.loli.net/2020/08/21/uYSspi8VErZhPvF.png" alt="image-20200821174211172" style="zoom:50%;" /></p><p><code>xs</code> 不仅可以用来选择列, 也可以用来选择行:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">class1=[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">class2=[<span class="string">&quot;x1&quot;</span>,<span class="string">&quot;x2&quot;</span>,<span class="string">&quot;y1&quot;</span>,<span class="string">&quot;y2&quot;</span>,<span class="string">&#x27;y3&#x27;</span>]</span><br><span class="line">multi_index=pd.MultiIndex.from_arrays([class1,class2],names=[<span class="string">&quot;class1&quot;</span>,<span class="string">&quot;class2&quot;</span>])</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(np.random.randint(<span class="number">1</span>,<span class="number">10</span>,(<span class="number">5</span>,<span class="number">3</span>)),index=multi_index)</span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">print(<span class="string">&#x27;选取结果是:&#x27;</span>)</span><br><span class="line">df.xs(<span class="string">&#x27;x1&#x27;</span>,level=<span class="number">1</span>,axis=<span class="string">&#x27;index&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><p><img src="https://i.loli.net/2020/08/21/jcughLPna6VAw5E.png" alt="image-20200821174735322" style="zoom:50%;" /></p><p><strong>注: 当然, 也可以使用我们学过的 <code>loc</code> 或者 <code>iloc</code> 函数.</strong></p><h3 id="3-5-DataFrame-Iteration"><a href="#3-5-DataFrame-Iteration" class="headerlink" title="3.5 DataFrame Iteration"></a>3.5 DataFrame Iteration</h3><p>我们可以直接迭代 <code>DataFrame</code> 和 <code>Series</code>:</p><ul><li><em>Series</em> - 值</li><li><em>DataFrame</em> - 列标签</li></ul><p>看个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">N=<span class="number">20</span></span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span>: pd.date_range(start=<span class="string">&#x27;2016-01-01&#x27;</span>,periods=N,freq=<span class="string">&#x27;D&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;x&#x27;</span>: np.linspace(<span class="number">0</span>,stop=N-<span class="number">1</span>,num=N),</span><br><span class="line">    <span class="string">&#x27;y&#x27;</span>: np.random.rand(N),</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>: np.random.choice([<span class="string">&#x27;Low&#x27;</span>,<span class="string">&#x27;Medium&#x27;</span>,<span class="string">&#x27;High&#x27;</span>],N).tolist(),</span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>: np.random.normal(<span class="number">100</span>, <span class="number">10</span>, size=(N)).tolist()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> df:</span><br><span class="line">    print(col)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">x</span><br><span class="line">y</span><br><span class="line">C</span><br><span class="line">D</span><br></pre></td></tr></table></figure><p>若我们要遍历 DataFrame 中的行, 我们使用以下函数:</p><ul><li><code>iteritems()</code> - 遍历每一列</li><li><code>iterrows()</code> - 遍历每一行</li><li><code>itertuples()</code></li></ul><h4 id="3-5-1-DataFrame-iteritems"><a href="#3-5-1-DataFrame-iteritems" class="headerlink" title="3.5.1 DataFrame.iteritems()"></a>3.5.1 DataFrame.iteritems()</h4><p><strong>列为 key, 列中的值为 value.</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">4</span>,<span class="number">3</span>), columns=[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>])</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> df.iteritems():</span><br><span class="line">    print(<span class="string">&#x27;列名:&#x27;</span>,k)</span><br><span class="line">    print(v)</span><br><span class="line">    print(<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">列名: A</span><br><span class="line">0    0.296866</span><br><span class="line">1   -0.148633</span><br><span class="line">2    1.621515</span><br><span class="line">3   -0.660666</span><br><span class="line">Name: A, dtype: float64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">列名: B</span><br><span class="line">0   -0.253393</span><br><span class="line">1    0.574725</span><br><span class="line">2    0.503636</span><br><span class="line">3    0.204850</span><br><span class="line">Name: B, dtype: float64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">列名: C</span><br><span class="line">0    1.317005</span><br><span class="line">1    0.346061</span><br><span class="line">2    0.358695</span><br><span class="line">3    0.341376</span><br><span class="line">Name: C, dtype: float64</span><br></pre></td></tr></table></figure><h4 id="3-5-2-DataFrame-iterrows"><a href="#3-5-2-DataFrame-iterrows" class="headerlink" title="3.5.2 DataFrame.iterrows()"></a>3.5.2 DataFrame.iterrows()</h4><p><strong>返回迭代器,产生每个索引值以及包含每行数据的序列.</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">4</span>,<span class="number">3</span>), columns=[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>])</span><br><span class="line"><span class="keyword">for</span> row_index, row <span class="keyword">in</span> df.iterrows():</span><br><span class="line">    print(<span class="string">&#x27;行 index 是:&#x27;</span>, row_index)</span><br><span class="line">    print(row)</span><br><span class="line">    print(<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[102]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">df &#x3D; pd.DataFrame(np.random.randn(4,3), columns&#x3D;[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;])</span><br><span class="line">for row_index, row in df.iterrows():</span><br><span class="line">    print(&#39;行 index 是:&#39;, row_index)</span><br><span class="line">    print(row)</span><br><span class="line">    print(&#39;\n&#39;)</span><br><span class="line">行 index 是: 0</span><br><span class="line">A   -0.831008</span><br><span class="line">B   -0.864205</span><br><span class="line">C    0.146520</span><br><span class="line">Name: 0, dtype: float64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">行 index 是: 1</span><br><span class="line">A   -0.991669</span><br><span class="line">B   -2.374277</span><br><span class="line">C   -0.356669</span><br><span class="line">Name: 1, dtype: float64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">行 index 是: 2</span><br><span class="line">A    2.209128</span><br><span class="line">B   -0.420584</span><br><span class="line">C    0.506585</span><br><span class="line">Name: 2, dtype: float64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">行 index 是: 3</span><br><span class="line">A   -1.058109</span><br><span class="line">B   -0.000286</span><br><span class="line">C    1.033392</span><br><span class="line">Name: 3, dtype: float64</span><br></pre></td></tr></table></figure><h4 id="3-5-3-DataFrame-itertuples"><a href="#3-5-3-DataFrame-itertuples" class="headerlink" title="3.5.3 DataFrame.itertuples()"></a>3.5.3 DataFrame.itertuples()</h4><p><code>itertuples()</code>方法将为<code>DataFrame</code>中的每一行返回一个产生一个命名元组的迭代器. 元组的第一个元素将是行的相应索引值, 而剩余的值是行值.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">4</span>,<span class="number">3</span>), columns=[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>])</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> df.itertuples():</span><br><span class="line">    print(row)</span><br><span class="line">    print(<span class="string">&#x27;行 index 是:&#x27;</span>, row[<span class="number">0</span>])</span><br><span class="line">    print(<span class="string">&#x27;行的值是:&#x27;</span>)</span><br><span class="line">    print(row[<span class="number">1</span>:])</span><br><span class="line">    print(<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Pandas(Index&#x3D;0, A&#x3D;-0.3540071641471044, B&#x3D;1.6031505884204515, C&#x3D;-0.4870924983750079)</span><br><span class="line">行 index 是: 0</span><br><span class="line">行的值是:</span><br><span class="line">(-0.3540071641471044, 1.6031505884204515, -0.4870924983750079)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Pandas(Index&#x3D;1, A&#x3D;0.5879313227987284, B&#x3D;-0.5026893763858423, C&#x3D;0.6591968909105315)</span><br><span class="line">行 index 是: 1</span><br><span class="line">行的值是:</span><br><span class="line">(0.5879313227987284, -0.5026893763858423, 0.6591968909105315)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Pandas(Index&#x3D;2, A&#x3D;-1.8100048151441157, B&#x3D;0.7800415414210258, C&#x3D;-0.47082706870345153)</span><br><span class="line">行 index 是: 2</span><br><span class="line">行的值是:</span><br><span class="line">(-1.8100048151441157, 0.7800415414210258, -0.47082706870345153)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Pandas(Index&#x3D;3, A&#x3D;0.22830697450955625, B&#x3D;-0.6997787075277464, C&#x3D;1.6736471725117756)</span><br><span class="line">行 index 是: 3</span><br><span class="line">行的值是:</span><br><span class="line">(0.22830697450955625, -0.6997787075277464, 1.6736471725117756)</span><br></pre></td></tr></table></figure><h3 id="3-6-Sorting-DataFrame"><a href="#3-6-Sorting-DataFrame" class="headerlink" title="3.6 Sorting DataFrame"></a>3.6 Sorting DataFrame</h3><p><em>Pandas</em>有两种排序方式, 它们分别是:</p><ul><li>按 index (可以是行, 也可以是列)</li><li>按 values</li></ul><p>我们先创建一个 DataFrame 用于之后的示例.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">10</span>,<span class="number">2</span>),index=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">7</span>],columns=[<span class="string">&#x27;col2&#x27;</span>,<span class="string">&#x27;col1&#x27;</span>])</span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line">       col2      col1</span><br><span class="line">1 -0.270190  0.970122</span><br><span class="line">4 -0.387794  0.023349</span><br><span class="line">6 -0.340047  0.412159</span><br><span class="line">2  0.473514  0.697203</span><br><span class="line">3 -1.062665  0.666765</span><br><span class="line">5 -0.157076  0.810648</span><br><span class="line">9  0.601996  0.700997</span><br><span class="line">8  1.305286  0.591112</span><br><span class="line">0  0.272618 -0.105529</span><br><span class="line">7 -2.122524 -0.613860</span><br></pre></td></tr></table></figure><h4 id="3-6-1-DataFrame-sort-index"><a href="#3-6-1-DataFrame-sort-index" class="headerlink" title="3.6.1 DataFrame.sort_index()"></a>3.6.1 DataFrame.sort_index()</h4><p>使用<code>sort_index()</code>方法, 通过传递<code>axis</code>参数和排序顺序, 可以对<code>DataFrame</code>进行排序. 默认情况下, 按照升序对行 index 进行排序.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">10</span>,<span class="number">2</span>),index=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">7</span>],columns=[<span class="string">&#x27;col2&#x27;</span>,<span class="string">&#x27;col1&#x27;</span>])</span><br><span class="line"></span><br><span class="line">asc_sorted_df = df.sort_index(axis=<span class="number">0</span>)</span><br><span class="line">desc_sorted_df = df.sort_index(axis=<span class="number">0</span>, ascending=<span class="literal">False</span>)</span><br><span class="line">print(<span class="string">&#x27;升序排序:&#x27;</span>)</span><br><span class="line">print(asc_sorted_df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;降序排序:&#x27;</span>)</span><br><span class="line">print(desc_sorted_df)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">升序排序:</span><br><span class="line">       col2      col1</span><br><span class="line">0  0.509889 -0.863155</span><br><span class="line">1  0.717766 -0.865105</span><br><span class="line">2 -1.465073  0.501439</span><br><span class="line">3 -0.891743 -0.772799</span><br><span class="line">4 -1.086885  0.241132</span><br><span class="line">5  0.104040  1.564791</span><br><span class="line">6 -1.271712  0.074772</span><br><span class="line">7  0.772256 -0.880302</span><br><span class="line">8 -0.361009 -0.391085</span><br><span class="line">9  0.255575  0.506795</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">降序排序:</span><br><span class="line">       col2      col1</span><br><span class="line">9  0.255575  0.506795</span><br><span class="line">8 -0.361009 -0.391085</span><br><span class="line">7  0.772256 -0.880302</span><br><span class="line">6 -1.271712  0.074772</span><br><span class="line">5  0.104040  1.564791</span><br><span class="line">4 -1.086885  0.241132</span><br><span class="line">3 -0.891743 -0.772799</span><br><span class="line">2 -1.465073  0.501439</span><br><span class="line">1  0.717766 -0.865105</span><br><span class="line">0  0.509889 -0.863155</span><br></pre></td></tr></table></figure><p><strong>我们再看一下按列排序的情况</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">10</span>,<span class="number">2</span>),index=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">7</span>],columns=[<span class="string">&#x27;col2&#x27;</span>,<span class="string">&#x27;col1&#x27;</span>])</span><br><span class="line"></span><br><span class="line">asc_sorted_df = df.sort_index(axis=<span class="number">1</span>)</span><br><span class="line">desc_sorted_df = df.sort_index(axis=<span class="number">1</span>, ascending=<span class="literal">False</span>)</span><br><span class="line">print(<span class="string">&#x27;升序排序:&#x27;</span>)</span><br><span class="line">print(asc_sorted_df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;降序排序:&#x27;</span>)</span><br><span class="line">print(desc_sorted_df)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">升序排序:</span><br><span class="line">       col1      col2</span><br><span class="line">1 -0.482662  1.857978</span><br><span class="line">4  1.008759  0.157484</span><br><span class="line">6  0.404661  0.084503</span><br><span class="line">2 -0.350703  0.340782</span><br><span class="line">3 -0.577663 -0.453446</span><br><span class="line">5  0.136501 -1.253516</span><br><span class="line">9  0.893234 -0.239606</span><br><span class="line">8  1.246226 -0.945827</span><br><span class="line">0  0.322587 -2.122998</span><br><span class="line">7 -2.055323  0.208008</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">降序排序:</span><br><span class="line">       col2      col1</span><br><span class="line">1  1.857978 -0.482662</span><br><span class="line">4  0.157484  1.008759</span><br><span class="line">6  0.084503  0.404661</span><br><span class="line">2  0.340782 -0.350703</span><br><span class="line">3 -0.453446 -0.577663</span><br><span class="line">5 -1.253516  0.136501</span><br><span class="line">9 -0.239606  0.893234</span><br><span class="line">8 -0.945827  1.246226</span><br><span class="line">0 -2.122998  0.322587</span><br><span class="line">7  0.208008 -2.055323</span><br></pre></td></tr></table></figure><h4 id="3-6-2-DataFrame-sort-values"><a href="#3-6-2-DataFrame-sort-values" class="headerlink" title="3.6.2 DataFrame.sort_values()"></a>3.6.2 DataFrame.sort_values()</h4><p><code>sort_values()</code>是按值排序的方法. 它接受一个<code>by</code>参数, 它将使用要与其排序值的<code>DataFrame</code>的列名称.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">10</span>,<span class="number">2</span>),index=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">7</span>],columns=[<span class="string">&#x27;col2&#x27;</span>,<span class="string">&#x27;col1&#x27;</span>])</span><br><span class="line"></span><br><span class="line">sorted_df = df.sort_index(axis=<span class="number">1</span>).sort_values(by=[<span class="string">&#x27;col1&#x27;</span>,<span class="string">&#x27;col2&#x27;</span>],kind=<span class="string">&#x27;mergesort&#x27;</span>,ascending=<span class="literal">False</span>)</span><br><span class="line">print(<span class="string">&#x27;排序结果是:&#x27;</span>)</span><br><span class="line">print(sorted_df)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">排序结果是:</span><br><span class="line">       col1      col2</span><br><span class="line">2  1.643330  0.634745</span><br><span class="line">7  1.424638 -0.712359</span><br><span class="line">8  1.091883  0.342883</span><br><span class="line">4  1.047769 -0.215468</span><br><span class="line">5  0.432504 -3.370203</span><br><span class="line">9  0.134519  0.829283</span><br><span class="line">6 -0.001631 -1.385783</span><br><span class="line">3 -0.775563  0.302277</span><br><span class="line">0 -1.370623 -0.091588</span><br><span class="line">1 -1.941154 -0.107553</span><br></pre></td></tr></table></figure><h3 id="3-7-Date-Function"><a href="#3-7-Date-Function" class="headerlink" title="3.7 Date Function"></a>3.7 Date Function</h3><p>日期功能扩展了时间序列, 在财务数据分析中起主要作用. 在处理日期数据的同时, 我们经常会遇到以下情况:</p><ul><li>生成日期序列</li><li>将日期序列转换为不同的频率</li></ul><h4 id="3-7-1-pandas-date-range"><a href="#3-7-1-pandas-date-range" class="headerlink" title="3.7.1 pandas.date_range()"></a>3.7.1 pandas.date_range()</h4><p><strong>通过指定周期和频率, 使用<code>date.range()</code>函数就可以创建日期序列. 默认情况下, 范围的频率是天.</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">datelist = pd.date_range(<span class="string">&#x27;2020/11/21&#x27;</span>,periods=<span class="number">5</span>)</span><br><span class="line">print(datelist)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DatetimeIndex([&#39;2020-11-21&#39;, &#39;2020-11-22&#39;, &#39;2020-11-23&#39;, &#39;2020-11-24&#39;,</span><br><span class="line">               &#39;2020-11-25&#39;],</span><br><span class="line">              dtype&#x3D;&#39;datetime64[ns]&#39;, freq&#x3D;&#39;D&#39;)</span><br></pre></td></tr></table></figure><p><strong>我们可以更改日期频率为月</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">datelist = pd.date_range(<span class="string">&#x27;2020/11/21&#x27;</span>,periods=<span class="number">5</span>, freq=<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">print(datelist)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DatetimeIndex([&#39;2020-11-30&#39;, &#39;2020-12-31&#39;, &#39;2021-01-31&#39;, &#39;2021-02-28&#39;,</span><br><span class="line">               &#39;2021-03-31&#39;],</span><br><span class="line">              dtype&#x3D;&#39;datetime64[ns]&#39;, freq&#x3D;&#39;M&#39;)</span><br></pre></td></tr></table></figure><h4 id="3-7-2-pandas-bdate-range"><a href="#3-7-2-pandas-bdate-range" class="headerlink" title="3.7.2 pandas.bdate_range()"></a>3.7.2 pandas.bdate_range()</h4><p><code>bdate_range()</code>用来表示商业日期范围, 不同于<code>date_range()</code>, 它不包括星期六和星期天.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">start = pd.datetime(<span class="number">2020</span>,<span class="number">8</span>,<span class="number">21</span>)</span><br><span class="line">end = pd.datetime(<span class="number">2020</span>,<span class="number">8</span>,<span class="number">29</span>)</span><br><span class="line">datelist = pd.bdate_range(start,end)</span><br><span class="line">print(datelist)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DatetimeIndex([&#39;2020-08-21&#39;, &#39;2020-08-24&#39;, &#39;2020-08-25&#39;, &#39;2020-08-26&#39;,</span><br><span class="line">               &#39;2020-08-27&#39;, &#39;2020-08-28&#39;],</span><br><span class="line">              dtype&#x3D;&#39;datetime64[ns]&#39;, freq&#x3D;&#39;B&#39;)</span><br></pre></td></tr></table></figure><p><strong>参数 <code>freq</code> 可以有以下选择:</strong></p><p><img src="https://i.loli.net/2020/08/21/OIkd4VeKgPZnRAM.png" alt="image-20200821192822274" style="zoom:50%;" /></p><h4 id="3-7-3-pandas-Timedelta"><a href="#3-7-3-pandas-Timedelta" class="headerlink" title="3.7.3 pandas.Timedelta()"></a>3.7.3 pandas.Timedelta()</h4><p>时间差(Timedelta)是时间上的差异, 以不同的单位来表示. 例如：日, 小时, 分钟, 秒. 它们可以是正值, 也可以是负值.<br>可以使用各种参数创建<code>Timedelta</code>对象, 如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">timediff = pd.Timedelta(<span class="string">&#x27;2 days 2 hours 15 minues 30 seconds&#x27;</span>)</span><br><span class="line">print(timediff)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 days 02:15:30</span><br></pre></td></tr></table></figure><p>以在Series/DataFrames上执行运算操作, 并通过在 <code>datetime64 [ns]</code> 系列或在时间戳上减法操作来构造 <code>timedelta64 [ns]</code> 系列.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s = pd.Series(pd.date_range(<span class="string">&#x27;2012-1-1&#x27;</span>, periods=<span class="number">3</span>, freq=<span class="string">&#x27;D&#x27;</span>))</span><br><span class="line">tdiff = pd.Series([pd.Timedelta(days=i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)])</span><br><span class="line">df = pd.DataFrame(<span class="built_in">dict</span>(A=s,B=tdiff))</span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;A+B&#x27;</span>] = df[<span class="string">&#x27;A&#x27;</span>] + df[<span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">df[<span class="string">&#x27;A-B&#x27;</span>] = df[<span class="string">&#x27;A&#x27;</span>] - df[<span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">print(<span class="string">&#x27;修改后的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line">           A      B</span><br><span class="line">0 2012-01-01 0 days</span><br><span class="line">1 2012-01-02 1 days</span><br><span class="line">2 2012-01-03 2 days</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改后的数据是:</span><br><span class="line">           A      B        A+B        A-B</span><br><span class="line">0 2012-01-01 0 days 2012-01-01 2012-01-01</span><br><span class="line">1 2012-01-02 1 days 2012-01-03 2012-01-01</span><br><span class="line">2 2012-01-03 2 days 2012-01-05 2012-01-01</span><br></pre></td></tr></table></figure><h3 id="3-8-Categorical-Data"><a href="#3-8-Categorical-Data" class="headerlink" title="3.8 Categorical Data"></a>3.8 Categorical Data</h3><p><strong>分类数据 (Categorical Data)</strong> 用于表示统计学里<strong>有限且唯一性数据集</strong>, 例如描述个人信息的性别一般就男和女两个数据常用’m’和’f’来描述, 有时也能对应编码映射为0和1. 血型A、B、O和AB型等选择可以映射为0、1、2、3这四个数字分别代表各个血型. Pandas 里直接就有 categorical 类型, 可以有效地对数据进行分组进行相应的汇总统计工作.</p><h4 id="3-8-1-Object-Creation"><a href="#3-8-1-Object-Creation" class="headerlink" title="3.8.1 Object Creation"></a>3.8.1 Object Creation</h4><p>分类对象可以通过多种方式创建:</p><ol><li><p>通过在<code>pandas</code>对象创建中将<code>dtype</code>指定为<code>“category”</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s = pd.Series([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>], dtype=<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0    a</span><br><span class="line">1    b</span><br><span class="line">2    c</span><br><span class="line">3    d</span><br><span class="line">dtype: category</span><br><span class="line">Categories (4, object): [a, b, c, d]</span><br></pre></td></tr></table></figure></li><li><p>使用标准 <strong>Pandas</strong> 分类构造函数: <code>pandas.Categorical()</code>. 我们可以创建一个类别对象, 语法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pandas.Categorical(values, categories, ordered)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># values: 传入的数据</span></span><br><span class="line"><span class="comment"># categories: 数据的分类, 在类别中不存在的任何值将被视为NaN</span></span><br><span class="line"><span class="comment"># ordered: bool, 是否进行逻辑排序, 按 categories 里面的顺序从小到达</span></span><br></pre></td></tr></table></figure><p>看个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">cat = pd.Categorical(values=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>],categories=[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>],ordered=<span class="literal">True</span>)</span><br><span class="line">print(cat)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[a, b, c, d, NaN]</span><br><span class="line">Categories (4, object): [d &lt; b &lt; c &lt; a]</span><br></pre></td></tr></table></figure><h4 id="3-8-2-Reading-Categorical-Data"><a href="#3-8-2-Reading-Categorical-Data" class="headerlink" title="3.8.2 Reading Categorical Data"></a>3.8.2 Reading Categorical Data</h4></li></ol><p><strong>我们可以对分类数据使用 <code>.describe()</code> , 得到各类数据出现的次数和频率</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">cat = pd.Categorical([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>],categories=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>],ordered=<span class="literal">False</span>)</span><br><span class="line">cat.describe()</span><br></pre></td></tr></table></figure><p>输出结果是:</p><p><img src="https://i.loli.net/2020/08/23/TaMvgte5uJ3qQDY.png" alt="image-20200823164719200" style="zoom:50%;" /></p><p><strong>我们可以使用 <code>.categories</code> 访问对象的类别, 以及使用 <code>.ordered</code> 看数据是否有排序.</strong></p><p><strong>我们还能使用 <code>Categorical.categories</code> 来修改对象的类别</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">cat = pd.Categorical([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>],categories=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>],ordered=<span class="literal">False</span>)</span><br><span class="line">print(<span class="string">&#x27;我们的原数据是:&#x27;</span>)</span><br><span class="line">print(cat)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;修改数据类别&#x27;</span>)</span><br><span class="line">cat.categories = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;e&#x27;</span>]  <span class="comment"># 原来的 b 变成 c, c 变成 e</span></span><br><span class="line">print(cat)</span><br></pre></td></tr></table></figure><p>输出结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">我们的原数据是:</span><br><span class="line">[a, c, a, b, c, b, a]</span><br><span class="line">Categories (3, object): [a, b, c]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改数据类别</span><br><span class="line">[a, e, a, c, e, c, a]</span><br><span class="line">Categories (3, object): [a, c, e]</span><br></pre></td></tr></table></figure><h4 id="3-8-3-Categorical-Data-Operations"><a href="#3-8-3-Categorical-Data-Operations" class="headerlink" title="3.8.3 Categorical Data Operations"></a>3.8.3 Categorical Data Operations</h4><ol><li><p>Adding Categories</p><p>使用<code>Categorical.add.categories()</code>方法, 可以追加新的类别.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s = pd.Series([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>],dtype=<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line">s = s.cat.add_categories([<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">print(s.cat.categories)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], dtype&#x3D;&#39;object&#39;)</span><br></pre></td></tr></table></figure></li><li><p>Removing Categories</p><p>使用<code>Categorical.remove_categories()</code>方法, 可以删除不需要的类别.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">s = pd.Series([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>],dtype=<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;我们原数据是:&#x27;</span>)</span><br><span class="line">print(s)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;移除类别后:&#x27;</span>)</span><br><span class="line">print(s.cat.remove_categories([<span class="string">&#x27;a&#x27;</span>]))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">我们原数据是:</span><br><span class="line">0    a</span><br><span class="line">1    b</span><br><span class="line">2    c</span><br><span class="line">3    a</span><br><span class="line">dtype: category</span><br><span class="line">Categories (3, object): [a, b, c]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">移除类别后:</span><br><span class="line">0    NaN</span><br><span class="line">1      b</span><br><span class="line">2      c</span><br><span class="line">3    NaN</span><br><span class="line">dtype: category</span><br><span class="line">Categories (2, object): [b, c]</span><br></pre></td></tr></table></figure><h2 id="Topic-4-Statistics-Functions"><a href="#Topic-4-Statistics-Functions" class="headerlink" title="Topic 4 Statistics Functions"></a>Topic 4 Statistics Functions</h2></li></ol><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>count()</code></td><td>每一列或行的非空数据的数量</td></tr><tr><td><code>sum()</code></td><td>每一列或行的所有值之和</td></tr><tr><td><code>mean()</code></td><td>每一列或行的所有值的平均值</td></tr><tr><td><code>median()</code></td><td>每一列或行的所有值的中位数</td></tr><tr><td><code>mode()</code></td><td>每一列或行中出现次数最多的数据</td></tr><tr><td><code>std()</code></td><td>每一列或行的标准差</td></tr><tr><td><code>min()</code></td><td>每一列或行的所有值中的最小值</td></tr><tr><td><code>max()</code></td><td>每一列或行的所有值中的最大值</td></tr><tr><td><code>abs()</code></td><td>取绝对值, 只适用于所有数值元素.</td></tr><tr><td><code>prod()</code></td><td>每一列或行的数组元素的乘积</td></tr><tr><td><code>cumsum()</code></td><td>累计总和</td></tr><tr><td><code>cumprod()</code></td><td>累计乘积, 只适用于所有数值元素.</td></tr><tr><td><code>var()</code></td><td>方差</td></tr><tr><td><code>skew()</code></td><td>偏差</td></tr><tr><td><code>kurt()</code></td><td>峰度</td></tr><tr><td><code>quantile()</code></td><td>分位数</td></tr><tr><td><code>cov()</code></td><td>协方差</td></tr><tr><td><code>corr()</code></td><td>相关系数</td></tr></tbody></table></div><h3 id="4-1-DataFrame-count"><a href="#4-1-DataFrame-count" class="headerlink" title="4.1 DataFrame.count()"></a>4.1 DataFrame.count()</h3><p>每一列非空数据的数量, 用法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DataFrame.count(self, axis=<span class="number">0</span>, numeric_only=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># axis: 0 竖直, 1 水平</span></span><br><span class="line"><span class="comment"># numeric_only: 是否只计算数据类型为数值的数据</span></span><br></pre></td></tr></table></figure><p>看个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;James&#x27;</span>,<span class="string">&#x27;Ricky&#x27;</span>,<span class="string">&#x27;Vin&#x27;</span>,<span class="string">&#x27;Steve&#x27;</span>,<span class="string">&#x27;Minsu&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Lee&#x27;</span>,<span class="string">&#x27;David&#x27;</span>,<span class="string">&#x27;Gasper&#x27;</span>,<span class="string">&#x27;Betina&#x27;</span>,<span class="string">&#x27;Andres&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;Age&#x27;</span>:pd.Series([<span class="number">25</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">23</span>,<span class="number">30</span>,<span class="number">29</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">51</span>,<span class="number">46</span>]),</span><br><span class="line">   <span class="string">&#x27;Rating&#x27;</span>:pd.Series([<span class="number">4.23</span>,<span class="number">3.24</span>,<span class="number">3.98</span>,<span class="number">2.56</span>,<span class="number">3.20</span>,<span class="number">4.6</span>,<span class="number">3.8</span>,<span class="number">3.78</span>,<span class="number">2.98</span>,<span class="number">4.80</span>,<span class="number">4.10</span>,<span class="number">3.65</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;非空行的数量:&#x27;</span>)</span><br><span class="line">print(df.count())</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line">      Name  Age  Rating</span><br><span class="line">0      Tom   25    4.23</span><br><span class="line">1    James   26    3.24</span><br><span class="line">2    Ricky   25    3.98</span><br><span class="line">3      Vin   23    2.56</span><br><span class="line">4    Steve   30    3.20</span><br><span class="line">5    Minsu   29    4.60</span><br><span class="line">6     Jack   23    3.80</span><br><span class="line">7      Lee   34    3.78</span><br><span class="line">8    David   40    2.98</span><br><span class="line">9   Gasper   30    4.80</span><br><span class="line">10  Betina   51    4.10</span><br><span class="line">11  Andres   46    3.65</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">非空行的数量:</span><br><span class="line">Name      12</span><br><span class="line">Age       12</span><br><span class="line">Rating    12</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><h3 id="4-2-DataFrame-sum"><a href="#4-2-DataFrame-sum" class="headerlink" title="4.2 DataFrame.sum()"></a>4.2 DataFrame.sum()</h3><p>返回行或列的数据之和, 用法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DataFrame.<span class="built_in">sum</span>(self,axis=<span class="literal">None</span>,skipna=<span class="literal">None</span>,numeric_only=<span class="literal">None</span>,min_count=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># axis: 指明沿什么轴计算, 可看我的 numpy 笔记的 Topic 3. 0 是竖直, 1 是水平</span></span><br><span class="line"><span class="comment"># skipna: 是否跳过空数据, 默认为 True</span></span><br><span class="line"><span class="comment"># numeric_only: 是否只计算 int 或 float 的和, 默认为 False</span></span><br><span class="line"><span class="comment"># min_count: 默认为 0, 若该列的有效数据量低于这个值, 则不计算该列的和</span></span><br></pre></td></tr></table></figure><p>看个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;James&#x27;</span>,<span class="string">&#x27;Ricky&#x27;</span>,<span class="string">&#x27;Vin&#x27;</span>,<span class="string">&#x27;Steve&#x27;</span>,<span class="string">&#x27;Minsu&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Lee&#x27;</span>,<span class="string">&#x27;David&#x27;</span>,<span class="string">&#x27;Gasper&#x27;</span>,<span class="string">&#x27;Betina&#x27;</span>,<span class="string">&#x27;Andres&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;Age&#x27;</span>:pd.Series([<span class="number">25</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">23</span>,<span class="number">30</span>,<span class="number">29</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">51</span>,<span class="number">46</span>]),</span><br><span class="line">   <span class="string">&#x27;Rating&#x27;</span>:pd.Series([<span class="number">4.23</span>,<span class="number">3.24</span>,<span class="number">3.98</span>,<span class="number">2.56</span>,<span class="number">3.20</span>,<span class="number">4.6</span>,<span class="number">3.8</span>,<span class="number">3.78</span>,<span class="number">2.98</span>,<span class="number">4.80</span>,<span class="number">4.10</span>,<span class="number">3.65</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;数据类型是数值的列之和:&#x27;</span>)</span><br><span class="line">print(df.<span class="built_in">sum</span>(numeric_only=<span class="literal">True</span>,axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line">      Name  Age  Rating</span><br><span class="line">0      Tom   25    4.23</span><br><span class="line">1    James   26    3.24</span><br><span class="line">2    Ricky   25    3.98</span><br><span class="line">3      Vin   23    2.56</span><br><span class="line">4    Steve   30    3.20</span><br><span class="line">5    Minsu   29    4.60</span><br><span class="line">6     Jack   23    3.80</span><br><span class="line">7      Lee   34    3.78</span><br><span class="line">8    David   40    2.98</span><br><span class="line">9   Gasper   30    4.80</span><br><span class="line">10  Betina   51    4.10</span><br><span class="line">11  Andres   46    3.65</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数据类型是数值的列之和:</span><br><span class="line">Age       382.00</span><br><span class="line">Rating     44.92</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><h3 id="4-3-DataFrame-mean"><a href="#4-3-DataFrame-mean" class="headerlink" title="4.3 DataFrame.mean()"></a>4.3 DataFrame.mean()</h3><p>返回数据的平均值, 用法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataFrame.mean(axis=<span class="literal">None</span>,skipna=<span class="literal">None</span>,numeric_only=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><code>DataFrame.median()</code>, <code>DataFrame.std()</code>, <code>DataFrame.min()</code> , <code>DataFrame.max()</code> 以及 <code>DataFrame.prod()</code> …. 的用法与之相同, 我就不再赘述了.</p><p>看个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;James&#x27;</span>,<span class="string">&#x27;Ricky&#x27;</span>,<span class="string">&#x27;Vin&#x27;</span>,<span class="string">&#x27;Steve&#x27;</span>,<span class="string">&#x27;Minsu&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Lee&#x27;</span>,<span class="string">&#x27;David&#x27;</span>,<span class="string">&#x27;Gasper&#x27;</span>,<span class="string">&#x27;Betina&#x27;</span>,<span class="string">&#x27;Andres&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;Age&#x27;</span>:pd.Series([<span class="number">25</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">23</span>,<span class="number">30</span>,<span class="number">29</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">51</span>,<span class="number">46</span>]),</span><br><span class="line">   <span class="string">&#x27;Rating&#x27;</span>:pd.Series([<span class="number">4.23</span>,<span class="number">3.24</span>,<span class="number">3.98</span>,<span class="number">2.56</span>,<span class="number">3.20</span>,<span class="number">4.6</span>,<span class="number">3.8</span>,<span class="number">3.78</span>,<span class="number">2.98</span>,<span class="number">4.80</span>,<span class="number">4.10</span>,<span class="number">3.65</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;每列的平均值是:&#x27;</span>)</span><br><span class="line">print(df.mean())</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line">      Name  Age  Rating</span><br><span class="line">0      Tom   25    4.23</span><br><span class="line">1    James   26    3.24</span><br><span class="line">2    Ricky   25    3.98</span><br><span class="line">3      Vin   23    2.56</span><br><span class="line">4    Steve   30    3.20</span><br><span class="line">5    Minsu   29    4.60</span><br><span class="line">6     Jack   23    3.80</span><br><span class="line">7      Lee   34    3.78</span><br><span class="line">8    David   40    2.98</span><br><span class="line">9   Gasper   30    4.80</span><br><span class="line">10  Betina   51    4.10</span><br><span class="line">11  Andres   46    3.65</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">每列的平均值是:</span><br><span class="line">Age       31.833333</span><br><span class="line">Rating     3.743333</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><h3 id="4-4-DataFrame-mode"><a href="#4-4-DataFrame-mode" class="headerlink" title="4.4 DataFrame.mode()"></a>4.4 DataFrame.mode()</h3><p>每一列或行中出现次数最多的数据, 用法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DataFrame.mode(self, axis=<span class="number">0</span>, numeric_only=<span class="literal">False</span>, dropna=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># axis: 0 获取各列的 mode, 1 获取各行的 mode</span></span><br><span class="line"><span class="comment"># numeric_only: 若为 True, 那么只适用于数字列</span></span><br><span class="line"><span class="comment"># dropna: 是否考虑 na 值</span></span><br></pre></td></tr></table></figure><p>看个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame([(<span class="string">&#x27;bird&#x27;</span>, <span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">                   (<span class="string">&#x27;mammal&#x27;</span>, <span class="number">4</span>, np.nan),</span><br><span class="line">                   (<span class="string">&#x27;arthropod&#x27;</span>, <span class="number">8</span>, <span class="number">0</span>),</span><br><span class="line">                   (<span class="string">&#x27;bird&#x27;</span>, <span class="number">2</span>, np.nan)],</span><br><span class="line">                  index=(<span class="string">&#x27;falcon&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;spider&#x27;</span>, <span class="string">&#x27;ostrich&#x27;</span>),</span><br><span class="line">                  columns=(<span class="string">&#x27;species&#x27;</span>, <span class="string">&#x27;legs&#x27;</span>, <span class="string">&#x27;wings&#x27;</span>))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;dropna 情况下, 每列的 mode:&#x27;</span>)</span><br><span class="line">print(df.mode())</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;不 dropna 的情况下, 每列的 mode:&#x27;</span>)</span><br><span class="line">print(df.mode(dropna=<span class="literal">False</span>))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line">           species  legs  wings</span><br><span class="line">falcon        bird     2    2.0</span><br><span class="line">horse       mammal     4    NaN</span><br><span class="line">spider   arthropod     8    0.0</span><br><span class="line">ostrich       bird     2    NaN</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dropna 情况下, 每列的 mode:</span><br><span class="line">  species  legs  wings</span><br><span class="line">0    bird   2.0    0.0</span><br><span class="line">1     NaN   NaN    2.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">不 dropna 的情况下, 每列的 mode:</span><br><span class="line">  species  legs  wings</span><br><span class="line">0    bird     2    NaN</span><br></pre></td></tr></table></figure><h3 id="4-5-DataFrame-abs"><a href="#4-5-DataFrame-abs" class="headerlink" title="4.5 DataFrame.abs()"></a>4.5 DataFrame.abs()</h3><p>返回一个包含每个元素绝对值的<code>Series</code>/<code>DataFrame</code>. 此函数只适用于所有数值元素.</p><p>看个列子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>],<span class="string">&#x27;b&#x27;</span>: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>],<span class="string">&#x27;c&#x27;</span>: [<span class="number">100</span>, <span class="number">50</span>, -<span class="number">30</span>, -<span class="number">50</span>]&#125;)</span><br><span class="line">      </span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;取绝对值之后的数据:&#x27;</span>)</span><br><span class="line">print(df.<span class="built_in">abs</span>())</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line">   a   b    c</span><br><span class="line">0  4  10  100</span><br><span class="line">1  5  20   50</span><br><span class="line">2  6  30  -30</span><br><span class="line">3  7  40  -50</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">取绝对值之后的数据:</span><br><span class="line">   a   b    c</span><br><span class="line">0  4  10  100</span><br><span class="line">1  5  20   50</span><br><span class="line">2  6  30   30</span><br><span class="line">3  7  40   50</span><br></pre></td></tr></table></figure><h3 id="4-6-DataFrame-cumsum-amp-DataFrame-cumprod"><a href="#4-6-DataFrame-cumsum-amp-DataFrame-cumprod" class="headerlink" title="4.6 DataFrame.cumsum() &amp; DataFrame.cumprod()"></a>4.6 DataFrame.cumsum() &amp; DataFrame.cumprod()</h3><p>返回DataFrame或Series轴上的累计和/积</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>],<span class="string">&#x27;b&#x27;</span>: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>],<span class="string">&#x27;c&#x27;</span>: [<span class="number">100</span>, <span class="number">50</span>, -<span class="number">30</span>, -<span class="number">50</span>]&#125;)</span><br><span class="line">      </span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;沿轴 0 累计的和:&#x27;</span>)</span><br><span class="line">print(df.cumsum())</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;沿轴 0 累计的积:&#x27;</span>)</span><br><span class="line">print(df.cumprod())</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line">   a   b    c</span><br><span class="line">0  4  10  100</span><br><span class="line">1  5  20   50</span><br><span class="line">2  6  30  -30</span><br><span class="line">3  7  40  -50</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">沿轴 0 累计的和:</span><br><span class="line">    a    b    c</span><br><span class="line">0   4   10  100</span><br><span class="line">1   9   30  150</span><br><span class="line">2  15   60  120</span><br><span class="line">3  22  100   70</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">沿轴 0 累计的积:</span><br><span class="line">     a       b        c</span><br><span class="line">0    4      10      100</span><br><span class="line">1   20     200     5000</span><br><span class="line">2  120    6000  -150000</span><br><span class="line">3  840  240000  7500000</span><br></pre></td></tr></table></figure><h3 id="4-7-DataFrame-describe"><a href="#4-7-DataFrame-describe" class="headerlink" title="4.7 DataFrame.describe()"></a>4.7 DataFrame.describe()</h3><p>描述性统计归纳总计</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;Name&#x27;</span>:pd.Series([<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;James&#x27;</span>,<span class="string">&#x27;Ricky&#x27;</span>,<span class="string">&#x27;Vin&#x27;</span>,<span class="string">&#x27;Steve&#x27;</span>,<span class="string">&#x27;Minsu&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Lee&#x27;</span>,<span class="string">&#x27;David&#x27;</span>,<span class="string">&#x27;Gasper&#x27;</span>,<span class="string">&#x27;Betina&#x27;</span>,<span class="string">&#x27;Andres&#x27;</span>]),</span><br><span class="line">   <span class="string">&#x27;Age&#x27;</span>:pd.Series([<span class="number">25</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">23</span>,<span class="number">30</span>,<span class="number">29</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">51</span>,<span class="number">46</span>]),</span><br><span class="line">   <span class="string">&#x27;Rating&#x27;</span>:pd.Series([<span class="number">4.23</span>,<span class="number">3.24</span>,<span class="number">3.98</span>,<span class="number">2.56</span>,<span class="number">3.20</span>,<span class="number">4.6</span>,<span class="number">3.8</span>,<span class="number">3.78</span>,<span class="number">2.98</span>,<span class="number">4.80</span>,<span class="number">4.10</span>,<span class="number">3.65</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"></span><br><span class="line">print(df.describe())</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">             Age     Rating</span><br><span class="line">count  12.000000  12.000000</span><br><span class="line">mean   31.833333   3.743333</span><br><span class="line">std     9.232682   0.661628</span><br><span class="line">min    23.000000   2.560000</span><br><span class="line">25%    25.000000   3.230000</span><br><span class="line">50%    29.500000   3.790000</span><br><span class="line">75%    35.500000   4.132500</span><br><span class="line">max    51.000000   4.800000</span><br></pre></td></tr></table></figure><h3 id="4-8-DataFrame-pct-change"><a href="#4-8-DataFrame-pct-change" class="headerlink" title="4.8 DataFrame.pct_change()"></a>4.8 DataFrame.pct_change()</h3><p>Series, DatFrames和Panel都有<code>pct_change()</code>函数, 此函数将每个元素与其前一个元素进行比较, 并计算变化百分比.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span> (s.pct_change())</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">5</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span> (df.pct_change())</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0         NaN</span><br><span class="line">1    1.000000</span><br><span class="line">2    0.500000</span><br><span class="line">3    0.333333</span><br><span class="line">4    0.250000</span><br><span class="line">5   -0.200000</span><br><span class="line">dtype: float64</span><br><span class="line">          0           1</span><br><span class="line">0       NaN         NaN</span><br><span class="line">1  0.384032   -0.996141</span><br><span class="line">2 -1.736876  679.793981</span><br><span class="line">3  1.063848   -0.441469</span><br><span class="line">4 -1.060066   -1.576158</span><br></pre></td></tr></table></figure><h3 id="4-9-DataFrame-sample"><a href="#4-9-DataFrame-sample" class="headerlink" title="4.9 DataFrame.sample()"></a>4.9 DataFrame.sample()</h3><p>从对象轴返回随机的项目样本, 用法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DataFrame.sample(n=<span class="literal">None</span>,axis=<span class="literal">None</span>,frac=<span class="literal">None</span>,replace=<span class="literal">False</span>,weights=<span class="literal">None</span>,random_state=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># n: 想要取得的样本数, 不能和 frac 一起使用, 若 frac=None, 则 n 默认值为 1</span></span><br><span class="line"><span class="comment"># axis: 沿什么轴抽样</span></span><br><span class="line"><span class="comment"># frac: 取百分之几的数据, 不能与 n 一起使用</span></span><br><span class="line"><span class="comment"># replace: bool, 默认为 False. 允许或不允许对同一行进行多次抽样</span></span><br><span class="line"><span class="comment"># weights: 默认的 None 将导致相等的概率权重.</span></span><br><span class="line"><span class="comment"># random_state: 实现重现性</span></span><br></pre></td></tr></table></figure><p>看个例子:</p><p>选取数据的 200% 作为样本, 且允许随机抽样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;num_legs&#x27;</span>: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>],</span><br><span class="line">                 <span class="string">&#x27;num_wings&#x27;</span>: [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                 <span class="string">&#x27;num_specimen_seen&#x27;</span>: [<span class="number">10</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>]&#125;,</span><br><span class="line">                 index=[<span class="string">&#x27;falcon&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;spider&#x27;</span>, <span class="string">&#x27;fish&#x27;</span>])</span><br><span class="line"></span><br><span class="line">sample = df.sample(frac=<span class="number">2</span>, replace=<span class="literal">True</span>, random_state=<span class="number">1</span>)</span><br><span class="line">print(<span class="string">&#x27;我们的样本是:&#x27;</span>)</span><br><span class="line">print(sample)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我们的样本是:</span><br><span class="line">        num_legs  num_wings  num_specimen_seen</span><br><span class="line">dog            4          0                  2</span><br><span class="line">fish           0          0                  8</span><br><span class="line">falcon         2          2                 10</span><br><span class="line">falcon         2          2                 10</span><br><span class="line">fish           0          0                  8</span><br><span class="line">dog            4          0                  2</span><br><span class="line">fish           0          0                  8</span><br><span class="line">dog            4          0                  2</span><br></pre></td></tr></table></figure><p>使用DataFrame列作为权重. num_specimen_seen列中值较大的行更可能被采样.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;num_legs&#x27;</span>: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>],</span><br><span class="line">                 <span class="string">&#x27;num_wings&#x27;</span>: [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                 <span class="string">&#x27;num_specimen_seen&#x27;</span>: [<span class="number">10</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>]&#125;,</span><br><span class="line">                 index=[<span class="string">&#x27;falcon&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;spider&#x27;</span>, <span class="string">&#x27;fish&#x27;</span>])</span><br><span class="line"></span><br><span class="line">sample = df.sample(frac=<span class="number">2</span>, replace=<span class="literal">True</span>, weights=<span class="string">&#x27;num_specimen_seen&#x27;</span>, random_state=<span class="number">1</span>)</span><br><span class="line">print(<span class="string">&#x27;我们的样本是:&#x27;</span>)</span><br><span class="line">print(sample)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我们的样本是:</span><br><span class="line">        num_legs  num_wings  num_specimen_seen</span><br><span class="line">falcon         2          2                 10</span><br><span class="line">fish           0          0                  8</span><br><span class="line">falcon         2          2                 10</span><br><span class="line">falcon         2          2                 10</span><br><span class="line">falcon         2          2                 10</span><br><span class="line">falcon         2          2                 10</span><br><span class="line">falcon         2          2                 10</span><br><span class="line">falcon         2          2                 10</span><br></pre></td></tr></table></figure><h2 id="Topic-5-Data-Cleaning"><a href="#Topic-5-Data-Cleaning" class="headerlink" title="Topic 5 Data Cleaning"></a>Topic 5 Data Cleaning</h2><p><strong>我们先构造一个包含确实数据的 <code>DataFrame</code>:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = np.arange(<span class="number">10</span>,<span class="number">38</span>).reshape(<span class="number">7</span>,<span class="number">4</span>)</span><br><span class="line">rows = <span class="string">&#x27;cake make fake sake wake lake take&#x27;</span>.split()</span><br><span class="line">cols = <span class="built_in">list</span>(<span class="string">&#x27;abcd&#x27;</span>)</span><br><span class="line">df = pd.DataFrame(data=data, index=rows, columns=cols)</span><br><span class="line">df[<span class="string">&#x27;e&#x27;</span>] = np.nan</span><br><span class="line">df[<span class="string">&#x27;f&#x27;</span>] = np.nan</span><br><span class="line">df.at[<span class="string">&#x27;make&#x27;</span>,<span class="string">&#x27;e&#x27;</span>] = <span class="number">100</span></span><br><span class="line">df.at[<span class="string">&#x27;wake&#x27;</span>,<span class="string">&#x27;e&#x27;</span>] = <span class="number">300</span></span><br><span class="line">df.loc[<span class="string">&#x27;jake&#x27;</span>] =  np.nan</span><br><span class="line">df.at[<span class="string">&#x27;jake&#x27;</span>,<span class="string">&#x27;c&#x27;</span>] = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line">         a     b      c     d      e   f</span><br><span class="line">cake  10.0  11.0   12.0  13.0    NaN NaN</span><br><span class="line">make  14.0  15.0   16.0  17.0  100.0 NaN</span><br><span class="line">fake  18.0  19.0   20.0  21.0    NaN NaN</span><br><span class="line">sake  22.0  23.0   24.0  25.0    NaN NaN</span><br><span class="line">wake  26.0  27.0   28.0  29.0  300.0 NaN</span><br><span class="line">lake  30.0  31.0   32.0  33.0    NaN NaN</span><br><span class="line">take  34.0  35.0   36.0  37.0    NaN NaN</span><br><span class="line">jake   NaN   NaN  200.0   NaN    NaN NaN</span><br></pre></td></tr></table></figure><p><strong>然后, 我们看一下那些列有 NaN 数据:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = np.arange(<span class="number">10</span>,<span class="number">38</span>).reshape(<span class="number">7</span>,<span class="number">4</span>)</span><br><span class="line">rows = <span class="string">&#x27;cake make fake sake wake lake take&#x27;</span>.split()</span><br><span class="line">cols = <span class="built_in">list</span>(<span class="string">&#x27;abcd&#x27;</span>)</span><br><span class="line">df = pd.DataFrame(data=data, index=rows, columns=cols)</span><br><span class="line">df[<span class="string">&#x27;e&#x27;</span>] = np.nan</span><br><span class="line">df[<span class="string">&#x27;f&#x27;</span>] = np.nan</span><br><span class="line">df.at[<span class="string">&#x27;make&#x27;</span>,<span class="string">&#x27;e&#x27;</span>] = <span class="number">100</span></span><br><span class="line">df.at[<span class="string">&#x27;wake&#x27;</span>,<span class="string">&#x27;e&#x27;</span>] = <span class="number">300</span></span><br><span class="line">df.loc[<span class="string">&#x27;jake&#x27;</span>] =  np.nan</span><br><span class="line">df.at[<span class="string">&#x27;jake&#x27;</span>,<span class="string">&#x27;c&#x27;</span>] = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;每一列含空数据的情况:&#x27;</span>)</span><br><span class="line">print(df.isnull().<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">每一列含空数据的情况:</span><br><span class="line">a    1</span><br><span class="line">b    1</span><br><span class="line">c    0</span><br><span class="line">d    1</span><br><span class="line">e    6</span><br><span class="line">f    8</span><br></pre></td></tr></table></figure><h3 id="5-1-Deleting-NaN-Data"><a href="#5-1-Deleting-NaN-Data" class="headerlink" title="5.1 Deleting NaN Data"></a>5.1 Deleting NaN Data</h3><p><strong>我们主要使用 <code>dropna()</code> 函数来删除 NaN 数据, 看个例子:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = np.arange(<span class="number">10</span>,<span class="number">38</span>).reshape(<span class="number">7</span>,<span class="number">4</span>)</span><br><span class="line">rows = <span class="string">&#x27;cake make fake sake wake lake take&#x27;</span>.split()</span><br><span class="line">cols = <span class="built_in">list</span>(<span class="string">&#x27;abcd&#x27;</span>)</span><br><span class="line">df = pd.DataFrame(data=data, index=rows, columns=cols)</span><br><span class="line">df[<span class="string">&#x27;e&#x27;</span>] = np.nan</span><br><span class="line">df[<span class="string">&#x27;f&#x27;</span>] = np.nan</span><br><span class="line">df.at[<span class="string">&#x27;make&#x27;</span>,<span class="string">&#x27;e&#x27;</span>] = <span class="number">100</span></span><br><span class="line">df.at[<span class="string">&#x27;wake&#x27;</span>,<span class="string">&#x27;e&#x27;</span>] = <span class="number">300</span></span><br><span class="line">df.loc[<span class="string">&#x27;jake&#x27;</span>] =  np.nan</span><br><span class="line">df.at[<span class="string">&#x27;jake&#x27;</span>,<span class="string">&#x27;c&#x27;</span>] = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">df2 = df.dropna()</span><br><span class="line">print(<span class="string">&#x27;删除含 NaN 的行之后的数据:&#x27;</span>)</span><br><span class="line">print(df2)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line">         a     b      c     d      e   f</span><br><span class="line">cake  10.0  11.0   12.0  13.0    NaN NaN</span><br><span class="line">make  14.0  15.0   16.0  17.0  100.0 NaN</span><br><span class="line">fake  18.0  19.0   20.0  21.0    NaN NaN</span><br><span class="line">sake  22.0  23.0   24.0  25.0    NaN NaN</span><br><span class="line">wake  26.0  27.0   28.0  29.0  300.0 NaN</span><br><span class="line">lake  30.0  31.0   32.0  33.0    NaN NaN</span><br><span class="line">take  34.0  35.0   36.0  37.0    NaN NaN</span><br><span class="line">jake   NaN   NaN  200.0   NaN    NaN NaN</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">删除含 NaN 的行之后的数据:</span><br><span class="line">Empty DataFrame</span><br><span class="line">Columns: [a, b, c, d, e, f]</span><br><span class="line">Index: []</span><br></pre></td></tr></table></figure><p><strong>所有数据都没有了… 这样不是很好, 我们设置 <code>thresh</code> 来设定删除阈值, 看个例子:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = np.arange(<span class="number">10</span>,<span class="number">38</span>).reshape(<span class="number">7</span>,<span class="number">4</span>)</span><br><span class="line">rows = <span class="string">&#x27;cake make fake sake wake lake take&#x27;</span>.split()</span><br><span class="line">cols = <span class="built_in">list</span>(<span class="string">&#x27;abcd&#x27;</span>)</span><br><span class="line">df = pd.DataFrame(data=data, index=rows, columns=cols)</span><br><span class="line">df[<span class="string">&#x27;e&#x27;</span>] = np.nan</span><br><span class="line">df[<span class="string">&#x27;f&#x27;</span>] = np.nan</span><br><span class="line">df.at[<span class="string">&#x27;make&#x27;</span>,<span class="string">&#x27;e&#x27;</span>] = <span class="number">100</span></span><br><span class="line">df.at[<span class="string">&#x27;wake&#x27;</span>,<span class="string">&#x27;e&#x27;</span>] = <span class="number">300</span></span><br><span class="line">df.loc[<span class="string">&#x27;jake&#x27;</span>] =  np.nan</span><br><span class="line">df.at[<span class="string">&#x27;jake&#x27;</span>,<span class="string">&#x27;c&#x27;</span>] = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;列上至少有两个非 NaN 的列留下:&#x27;</span>)</span><br><span class="line">df2 = df.dropna(axis=<span class="string">&#x27;columns&#x27;</span>, thresh=<span class="number">2</span>)</span><br><span class="line">print(df2)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line">         a     b      c     d      e   f</span><br><span class="line">cake  10.0  11.0   12.0  13.0    NaN NaN</span><br><span class="line">make  14.0  15.0   16.0  17.0  100.0 NaN</span><br><span class="line">fake  18.0  19.0   20.0  21.0    NaN NaN</span><br><span class="line">sake  22.0  23.0   24.0  25.0    NaN NaN</span><br><span class="line">wake  26.0  27.0   28.0  29.0  300.0 NaN</span><br><span class="line">lake  30.0  31.0   32.0  33.0    NaN NaN</span><br><span class="line">take  34.0  35.0   36.0  37.0    NaN NaN</span><br><span class="line">jake   NaN   NaN  200.0   NaN    NaN NaN</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">列上至少有两个非 NaN 的列留下:</span><br><span class="line">         a     b      c     d      e</span><br><span class="line">cake  10.0  11.0   12.0  13.0    NaN</span><br><span class="line">make  14.0  15.0   16.0  17.0  100.0</span><br><span class="line">fake  18.0  19.0   20.0  21.0    NaN</span><br><span class="line">sake  22.0  23.0   24.0  25.0    NaN</span><br><span class="line">wake  26.0  27.0   28.0  29.0  300.0</span><br><span class="line">lake  30.0  31.0   32.0  33.0    NaN</span><br><span class="line">take  34.0  35.0   36.0  37.0    NaN</span><br><span class="line">jake   NaN   NaN  200.0   NaN    NaN</span><br></pre></td></tr></table></figure><h3 id="5-2-Filling-NaN-Data"><a href="#5-2-Filling-NaN-Data" class="headerlink" title="5.2 Filling NaN Data"></a>5.2 Filling NaN Data</h3><p>我们主要是用 <code>DataFrame.fillna()</code> 函数对缺失值进行填充, 有这么几种方法:</p><ul><li><p>使用 0 (或任意值) 填充缺失值</p><p><code>df.fillna(0)</code></p></li><li><p>用一个字符串来代替缺失值</p><p><code>df.fillna(&#39;missing&#39;)</code></p></li><li><p>用前一个数据代替缺失值</p><p><code>df.fillna(method=&#39;pad&#39;)</code></p></li><li><p>用后一个数据替代缺失值, 我们可以设置 limit 参数来限制替代缺失值的次数</p><p><code>df.fillna(method=&#39;bfill&#39;, limit=2)</code></p></li><li><p>我们还可以使用描述性统计量来代替缺失值</p><p><code>df.fillna(df.mean())</code></p><p>我们还可以指定某一列的描述性统计量来填充所有缺失值</p><p><code>df.fillna(df.mean()[&#39;e&#39;])</code></p></li></ul><h3 id="5-3-Deleting-Duplicated-Data"><a href="#5-3-Deleting-Duplicated-Data" class="headerlink" title="5.3 Deleting Duplicated Data"></a>5.3 Deleting Duplicated Data</h3><p>我们可以首先使用 <code>DataFrame.duplicated()</code> 来查看 DataFrame 中是否存在重复的数据. 然后再使用 <code>DataFrame.drop_duplicates()</code> 来移除重复数据. 看个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">fruit = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pearl&quot;</span>, <span class="string">&quot;watermelon&quot;</span>] * <span class="number">4</span></span><br><span class="line">price = [<span class="number">2.50</span>, <span class="number">3.00</span>, <span class="number">2.75</span>] * <span class="number">4</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&quot;fruit&quot;</span>: fruit, <span class="string">&quot;price&quot;</span> : price&#125;)</span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;查看数据重复情况:&#x27;</span>, df.duplicated().<span class="built_in">sum</span>())</span><br><span class="line">print(df.duplicated())</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;移除重复数据:&#x27;</span>)</span><br><span class="line">print(df.drop_duplicates())</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line">         fruit  price</span><br><span class="line">0        apple   2.50</span><br><span class="line">1        pearl   3.00</span><br><span class="line">2   watermelon   2.75</span><br><span class="line">3        apple   2.50</span><br><span class="line">4        pearl   3.00</span><br><span class="line">5   watermelon   2.75</span><br><span class="line">6        apple   2.50</span><br><span class="line">7        pearl   3.00</span><br><span class="line">8   watermelon   2.75</span><br><span class="line">9        apple   2.50</span><br><span class="line">10       pearl   3.00</span><br><span class="line">11  watermelon   2.75</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看数据重复情况: 9</span><br><span class="line">0     False</span><br><span class="line">1     False</span><br><span class="line">2     False</span><br><span class="line">3      True</span><br><span class="line">4      True</span><br><span class="line">5      True</span><br><span class="line">6      True</span><br><span class="line">7      True</span><br><span class="line">8      True</span><br><span class="line">9      True</span><br><span class="line">10     True</span><br><span class="line">11     True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">移除重复数据:</span><br><span class="line">        fruit  price</span><br><span class="line">0       apple   2.50</span><br><span class="line">1       pearl   3.00</span><br><span class="line">2  watermelon   2.75</span><br></pre></td></tr></table></figure><h3 id="5-4-Transform-Data"><a href="#5-4-Transform-Data" class="headerlink" title="5.4 Transform Data"></a>5.4 Transform Data</h3><p><code>DataFrame</code> 里的数据未必是原始数据, 例如采集时设定了一些协议, 1代表某某、2代表另一个事务或内容, 那么当开发者得到这些协议后的编码, 需要做一些数据上的变换, 以便真实的反映数据本身.</p><h4 id="5-4-1-Series-map"><a href="#5-4-1-Series-map" class="headerlink" title="5.4.1 Series.map()"></a>5.4.1 Series.map()</h4><p><code>map()</code> 是一个 Series 的函数，DataFrame结构中没有map(). <code>map()</code> 将一个自定义函数应用于 Series 结构中的每个元素(elements). 我们看个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span> : [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;key2&#x27;</span> : [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;data1&#x27;</span> : np.arange(<span class="number">5</span>),</span><br><span class="line">                   <span class="string">&#x27;data2&#x27;</span> : np.arange(<span class="number">5</span>,<span class="number">10</span>)&#125;)</span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;我们现在用map来对列 data1 改成保留小数点后三位&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;data1&#x27;</span>] = df[<span class="string">&#x27;data1&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="string">&#x27;%.3f&#x27;</span>%x)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;用map把key1的a改成c，b改成d&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;key1&#x27;</span>] = df[<span class="string">&#x27;key1&#x27;</span>].<span class="built_in">map</span>(&#123;<span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;d&#x27;</span>&#125;)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;修改后的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line">  key1 key2  data1  data2</span><br><span class="line">0    a  one      0      5</span><br><span class="line">1    a  two      1      6</span><br><span class="line">2    b  one      2      7</span><br><span class="line">3    b  two      3      8</span><br><span class="line">4    a  one      4      9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们现在用map来对列 data1 改成保留小数点后三位</span><br><span class="line">用map把key1的a改成c，b改成d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改后的数据是:</span><br><span class="line">  key1 key2  data1  data2</span><br><span class="line">0    c  one  0.000      5</span><br><span class="line">1    c  two  1.000      6</span><br><span class="line">2    d  one  2.000      7</span><br><span class="line">3    d  two  3.000      8</span><br><span class="line">4    c  one  4.000      9</span><br></pre></td></tr></table></figure><h4 id="5-4-2-DataFrame-replace"><a href="#5-4-2-DataFrame-replace" class="headerlink" title="5.4.2 DataFrame.replace()"></a>5.4.2 DataFrame.replace()</h4><p>之前我们将的 <code>fillna()</code> 函数可以将NaN数据填充为0,这里的replace函数可以将数据替换成其他数据. replace函数的使用方式有很多, 可以一对一的替换也可一对多的替换数据. 用法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DataFrame.replace(self, to_replace=<span class="literal">None</span>, value=<span class="literal">None</span>, inplace=<span class="literal">False</span>, limit=<span class="literal">None</span>, regex=<span class="literal">False</span>, method=<span class="string">&#x27;pad&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># to_replace: 将要被替换的值, 可以是 str, regex, dict 以及 list. 若是 dict, 那么 value 参数应该设置为 None. </span></span><br><span class="line"><span class="comment"># value: 用于替换 to_replace 中匹配到的值</span></span><br><span class="line"><span class="comment"># inplace: 是否修改原 DataFrame, 默认为 False, 也就是返回一个新的 DataFrame</span></span><br><span class="line"><span class="comment"># method: 要使用这个 to_replace 必须是标量, 而且 value 设置为 None. method 有以下几个选项: &#x27;mad&#x27;, &#x27;bfill&#x27;, &#x27;ffill&#x27;, &#x27;None&#x27;</span></span><br><span class="line"><span class="comment"># limit: 向后或向前填充的数量</span></span><br></pre></td></tr></table></figure><p>我们看一个正则表达式的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>: [<span class="string">&#x27;bat&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bait&#x27;</span>],</span><br><span class="line">                    <span class="string">&#x27;B&#x27;</span>: [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;xyz&#x27;</span>]&#125;)</span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;替换后的数据是:&#x27;</span>)</span><br><span class="line">df1 = df.replace(to_replace=<span class="string">r&#x27;^ba.$&#x27;</span>,value=<span class="string">&#x27;new&#x27;</span>,regex=<span class="literal">True</span>)</span><br><span class="line">print(df1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面这三种方式也是一样的效果</span></span><br><span class="line">df1 = df.replace(regex=<span class="string">r&#x27;^ba.$&#x27;</span>, value=<span class="string">&#x27;new&#x27;</span>)</span><br><span class="line">df1 = df.replace(regex=&#123;<span class="string">r&#x27;^ba.$&#x27;</span>: <span class="string">&#x27;new&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>: <span class="string">&#x27;xyz&#x27;</span>&#125;)</span><br><span class="line">df1 = df.replace(regex=[<span class="string">r&#x27;^ba.$&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>], value=<span class="string">&#x27;new&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line">      A    B</span><br><span class="line">0   bat  abc</span><br><span class="line">1   foo  bar</span><br><span class="line">2  bait  xyz</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">替换后的数据是:</span><br><span class="line">      A    B</span><br><span class="line">0   new  abc</span><br><span class="line">1   foo  new</span><br><span class="line">2  bait  xyz</span><br></pre></td></tr></table></figure><h4 id="5-4-3-DataFrame-apply"><a href="#5-4-3-DataFrame-apply" class="headerlink" title="5.4.3 DataFrame.apply()"></a>5.4.3 DataFrame.apply()</h4><p><code>apply()</code> 将一个函数作用于DataFrame中的每个行或者列, 看个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span> : [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;key2&#x27;</span> : [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;data1&#x27;</span> : np.arange(<span class="number">5</span>),</span><br><span class="line">                   <span class="string">&#x27;data2&#x27;</span> : np.arange(<span class="number">5</span>,<span class="number">10</span>)&#125;)</span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;使用 apply() 求每列的和&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;使用 apply() 对列 data1, data2 进行相加&#x27;</span>)</span><br><span class="line"></span><br><span class="line">df.loc[<span class="string">&#x27;total&#x27;</span>] = df[[<span class="string">&#x27;data1&#x27;</span>,<span class="string">&#x27;data2&#x27;</span>]].apply(<span class="keyword">lambda</span> x: x.<span class="built_in">sum</span>(), axis=<span class="number">0</span>)</span><br><span class="line">df[<span class="string">&#x27;total&#x27;</span>] = df[[<span class="string">&#x27;data1&#x27;</span>,<span class="string">&#x27;data2&#x27;</span>]].apply(<span class="keyword">lambda</span> x: x.<span class="built_in">sum</span>(), axis=<span class="number">1</span>)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;修改之后的数据:&#x27;</span>)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line">  key1 key2  data1  data2</span><br><span class="line">0    a  one      0      5</span><br><span class="line">1    a  two      1      6</span><br><span class="line">2    b  one      2      7</span><br><span class="line">3    b  two      3      8</span><br><span class="line">4    a  one      4      9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用 apply() 求每列的和</span><br><span class="line">使用 apply() 对列 data1, data2 进行相加</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改之后的数据:</span><br><span class="line">      key1 key2  data1  data2  total</span><br><span class="line">0        a  one    0.0    5.0    5.0</span><br><span class="line">1        a  two    1.0    6.0    7.0</span><br><span class="line">2        b  one    2.0    7.0    9.0</span><br><span class="line">3        b  two    3.0    8.0   11.0</span><br><span class="line">4        a  one    4.0    9.0   13.0</span><br><span class="line">total  NaN  NaN   10.0   35.0   45.0</span><br></pre></td></tr></table></figure><h4 id="5-4-5-DataFrame-applymap"><a href="#5-4-5-DataFrame-applymap" class="headerlink" title="5.4.5 DataFrame.applymap()"></a>5.4.5 DataFrame.applymap()</h4><p>将函数作用于 DataFrame 中的所有元素(elements), 看个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span> : [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;key2&#x27;</span> : [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;data1&#x27;</span> : np.arange(<span class="number">5</span>),</span><br><span class="line">                   <span class="string">&#x27;data2&#x27;</span> : np.arange(<span class="number">5</span>,<span class="number">10</span>)&#125;)</span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addA</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span> + <span class="built_in">str</span>(x)</span><br><span class="line"></span><br><span class="line">df2 = df.applymap(addA)</span><br><span class="line">print(<span class="string">&#x27;修改后的数据是:&#x27;</span>)</span><br><span class="line">print(df2)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line">  key1 key2  data1  data2</span><br><span class="line">0    a  one      0      5</span><br><span class="line">1    a  two      1      6</span><br><span class="line">2    b  one      2      7</span><br><span class="line">3    b  two      3      8</span><br><span class="line">4    a  one      4      9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改后的数据是:</span><br><span class="line">  key1  key2 data1 data2</span><br><span class="line">0   Aa  Aone    A0    A5</span><br><span class="line">1   Aa  Atwo    A1    A6</span><br><span class="line">2   Ab  Aone    A2    A7</span><br><span class="line">3   Ab  Atwo    A3    A8</span><br><span class="line">4   Aa  Aone    A4    A9</span><br></pre></td></tr></table></figure><h3 id="5-5-Data-Concatenation"><a href="#5-5-Data-Concatenation" class="headerlink" title="5.5 Data Concatenation"></a>5.5 Data Concatenation</h3><p>这里主要有两个函数: </p><ul><li><code>DataFrame.concat()</code></li><li><code>DataFrame.merge()</code></li></ul><h4 id="5-5-1-pandas-concat"><a href="#5-5-1-pandas-concat" class="headerlink" title="5.5.1 pandas.concat()"></a>5.5.1 pandas.concat()</h4><p><code>concat()</code> 函数的用法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pandas.concat(objs, axis=<span class="number">0</span>, join=<span class="string">&#x27;outer&#x27;</span>, join_axes=<span class="literal">None</span>, ignore_index=<span class="literal">False</span>, keys=<span class="literal">None</span>, names=<span class="literal">None</span>, verify_integrity=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># objs: series, dataframe或者是panel构成的序列list</span></span><br><span class="line"><span class="comment"># axis: 需要合并链接的轴，0是行, 1是列</span></span><br><span class="line"><span class="comment"># join: 连接方式 inner(交集) 或者 outer(并集)</span></span><br><span class="line"><span class="comment"># keys: 用于指明数据分别来自哪个 DataFrame</span></span><br><span class="line"><span class="comment"># join_axes: 以哪张表的行 index 为基准</span></span><br><span class="line"><span class="comment"># ignore_index: 如果两个表的index都没有实际含义, 使用ignore_index参数. 合并的两个表就根据列字段对齐, 然后合并, 最后再重新整理一个新的index</span></span><br></pre></td></tr></table></figure><p><strong>我们竖直拼接的例子</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>:[<span class="string">&#x27;A0&#x27;</span>,<span class="string">&#x27;A1&#x27;</span>,<span class="string">&#x27;A2&#x27;</span>,<span class="string">&#x27;A3&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;B&#x27;</span>:[<span class="string">&#x27;B0&#x27;</span>,<span class="string">&#x27;B1&#x27;</span>,<span class="string">&#x27;B2&#x27;</span>,<span class="string">&#x27;B3&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;C&#x27;</span>:[<span class="string">&#x27;C0&#x27;</span>,<span class="string">&#x27;C1&#x27;</span>,<span class="string">&#x27;C2&#x27;</span>,<span class="string">&#x27;C3&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;D&#x27;</span>:[<span class="string">&#x27;D0&#x27;</span>,<span class="string">&#x27;D1&#x27;</span>,<span class="string">&#x27;D2&#x27;</span>,<span class="string">&#x27;D3&#x27;</span>]&#125;, index=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>:[<span class="string">&#x27;A4&#x27;</span>,<span class="string">&#x27;A5&#x27;</span>,<span class="string">&#x27;A6&#x27;</span>,<span class="string">&#x27;A7&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;B&#x27;</span>:[<span class="string">&#x27;B4&#x27;</span>,<span class="string">&#x27;B5&#x27;</span>,<span class="string">&#x27;B6&#x27;</span>,<span class="string">&#x27;B7&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;C&#x27;</span>:[<span class="string">&#x27;C4&#x27;</span>,<span class="string">&#x27;C5&#x27;</span>,<span class="string">&#x27;C6&#x27;</span>,<span class="string">&#x27;C7&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;D&#x27;</span>:[<span class="string">&#x27;D4&#x27;</span>,<span class="string">&#x27;D5&#x27;</span>,<span class="string">&#x27;D6&#x27;</span>,<span class="string">&#x27;D7&#x27;</span>]&#125;, index=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]) </span><br><span class="line"></span><br><span class="line">df3 = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>:[<span class="string">&#x27;A8&#x27;</span>,<span class="string">&#x27;A9&#x27;</span>,<span class="string">&#x27;A10&#x27;</span>,<span class="string">&#x27;A11&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;B&#x27;</span>:[<span class="string">&#x27;B8&#x27;</span>,<span class="string">&#x27;B9&#x27;</span>,<span class="string">&#x27;B10&#x27;</span>,<span class="string">&#x27;B11&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;C&#x27;</span>:[<span class="string">&#x27;C8&#x27;</span>,<span class="string">&#x27;C9&#x27;</span>,<span class="string">&#x27;C10&#x27;</span>,<span class="string">&#x27;C11&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;D&#x27;</span>:[<span class="string">&#x27;D8&#x27;</span>,<span class="string">&#x27;D9&#x27;</span>,<span class="string">&#x27;D10&#x27;</span>,<span class="string">&#x27;D11&#x27;</span>]&#125;, index=[<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]) </span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;我们的三个 DataFrame 分别是:&#x27;</span>)</span><br><span class="line">print(df1)</span><br><span class="line">print()</span><br><span class="line">print(df2)</span><br><span class="line">print()</span><br><span class="line">print(df3)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;我们竖直拼接三个 DataFrame, 并指明其来源:&#x27;</span>)</span><br><span class="line">print(pd.concat([df1,df2,df3], axis=<span class="number">0</span>, keys=[<span class="string">&#x27;df1&#x27;</span>,<span class="string">&#x27;df2&#x27;</span>,<span class="string">&#x27;df3&#x27;</span>]))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">我们的三个 DataFrame 分别是:</span><br><span class="line">    A   B   C   D</span><br><span class="line">0  A0  B0  C0  D0</span><br><span class="line">1  A1  B1  C1  D1</span><br><span class="line">2  A2  B2  C2  D2</span><br><span class="line">3  A3  B3  C3  D3</span><br><span class="line"></span><br><span class="line">    A   B   C   D</span><br><span class="line">4  A4  B4  C4  D4</span><br><span class="line">5  A5  B5  C5  D5</span><br><span class="line">6  A6  B6  C6  D6</span><br><span class="line">7  A7  B7  C7  D7</span><br><span class="line"></span><br><span class="line">      A    B    C    D</span><br><span class="line">8    A8   B8   C8   D8</span><br><span class="line">9    A9   B9   C9   D9</span><br><span class="line">10  A10  B10  C10  D10</span><br><span class="line">11  A11  B11  C11  D11</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们竖直拼接三个 DataFrame, 并指明其来源:</span><br><span class="line">          A    B    C    D</span><br><span class="line">df1 0    A0   B0   C0   D0</span><br><span class="line">    1    A1   B1   C1   D1</span><br><span class="line">    2    A2   B2   C2   D2</span><br><span class="line">    3    A3   B3   C3   D3</span><br><span class="line">df2 4    A4   B4   C4   D4</span><br><span class="line">    5    A5   B5   C5   D5</span><br><span class="line">    6    A6   B6   C6   D6</span><br><span class="line">    7    A7   B7   C7   D7</span><br><span class="line">df3 8    A8   B8   C8   D8</span><br><span class="line">    9    A9   B9   C9   D9</span><br><span class="line">    10  A10  B10  C10  D10</span><br><span class="line">    11  A11  B11  C11  D11</span><br></pre></td></tr></table></figure><p><strong>我们看一个水平拼接的例子</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>:[<span class="string">&#x27;A0&#x27;</span>,<span class="string">&#x27;A1&#x27;</span>,<span class="string">&#x27;A2&#x27;</span>,<span class="string">&#x27;A3&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;B&#x27;</span>:[<span class="string">&#x27;B0&#x27;</span>,<span class="string">&#x27;B1&#x27;</span>,<span class="string">&#x27;B2&#x27;</span>,<span class="string">&#x27;B3&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;C&#x27;</span>:[<span class="string">&#x27;C0&#x27;</span>,<span class="string">&#x27;C1&#x27;</span>,<span class="string">&#x27;C2&#x27;</span>,<span class="string">&#x27;C3&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;D&#x27;</span>:[<span class="string">&#x27;D0&#x27;</span>,<span class="string">&#x27;D1&#x27;</span>,<span class="string">&#x27;D2&#x27;</span>,<span class="string">&#x27;D3&#x27;</span>]&#125;, index=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">&#x27;A1&#x27;</span>:[<span class="string">&#x27;A4&#x27;</span>,<span class="string">&#x27;A5&#x27;</span>,<span class="string">&#x27;A6&#x27;</span>,<span class="string">&#x27;A7&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;B2&#x27;</span>:[<span class="string">&#x27;B4&#x27;</span>,<span class="string">&#x27;B5&#x27;</span>,<span class="string">&#x27;B6&#x27;</span>,<span class="string">&#x27;B7&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;C2&#x27;</span>:[<span class="string">&#x27;C4&#x27;</span>,<span class="string">&#x27;C5&#x27;</span>,<span class="string">&#x27;C6&#x27;</span>,<span class="string">&#x27;C7&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;D2&#x27;</span>:[<span class="string">&#x27;D4&#x27;</span>,<span class="string">&#x27;D5&#x27;</span>,<span class="string">&#x27;D6&#x27;</span>,<span class="string">&#x27;D7&#x27;</span>]&#125;, index=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) </span><br><span class="line"></span><br><span class="line">df3 = pd.DataFrame(&#123;<span class="string">&#x27;A3&#x27;</span>:[<span class="string">&#x27;A8&#x27;</span>,<span class="string">&#x27;A9&#x27;</span>,<span class="string">&#x27;A10&#x27;</span>,<span class="string">&#x27;A11&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;B3&#x27;</span>:[<span class="string">&#x27;B8&#x27;</span>,<span class="string">&#x27;B9&#x27;</span>,<span class="string">&#x27;B10&#x27;</span>,<span class="string">&#x27;B11&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;C3&#x27;</span>:[<span class="string">&#x27;C8&#x27;</span>,<span class="string">&#x27;C9&#x27;</span>,<span class="string">&#x27;C10&#x27;</span>,<span class="string">&#x27;C11&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;D3&#x27;</span>:[<span class="string">&#x27;D8&#x27;</span>,<span class="string">&#x27;D9&#x27;</span>,<span class="string">&#x27;D10&#x27;</span>,<span class="string">&#x27;D11&#x27;</span>]&#125;, index=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) </span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;我们的三个 DataFrame 分别是:&#x27;</span>)</span><br><span class="line">print(df1)</span><br><span class="line">print()</span><br><span class="line">print(df2)</span><br><span class="line">print()</span><br><span class="line">print(df3)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;我们水平拼接三个 DataFrame, 并指明其来源:&#x27;</span>)</span><br><span class="line">print(pd.concat([df1,df2,df3], axis=<span class="number">1</span>, keys=[<span class="string">&#x27;df1&#x27;</span>,<span class="string">&#x27;df2&#x27;</span>,<span class="string">&#x27;df3&#x27;</span>]))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">我们的三个 DataFrame 分别是:</span><br><span class="line">    A   B   C   D</span><br><span class="line">0  A0  B0  C0  D0</span><br><span class="line">1  A1  B1  C1  D1</span><br><span class="line">2  A2  B2  C2  D2</span><br><span class="line">3  A3  B3  C3  D3</span><br><span class="line"></span><br><span class="line">   A1  B2  C2  D2</span><br><span class="line">0  A4  B4  C4  D4</span><br><span class="line">1  A5  B5  C5  D5</span><br><span class="line">2  A6  B6  C6  D6</span><br><span class="line">3  A7  B7  C7  D7</span><br><span class="line"></span><br><span class="line">    A3   B3   C3   D3</span><br><span class="line">0   A8   B8   C8   D8</span><br><span class="line">1   A9   B9   C9   D9</span><br><span class="line">2  A10  B10  C10  D10</span><br><span class="line">3  A11  B11  C11  D11</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们水平拼接三个 DataFrame, 并指明其来源:</span><br><span class="line">  df1             df2              df3</span><br><span class="line">    A   B   C   D  A1  B2  C2  D2   A3   B3   C3   D3</span><br><span class="line">0  A0  B0  C0  D0  A4  B4  C4  D4   A8   B8   C8   D8</span><br><span class="line">1  A1  B1  C1  D1  A5  B5  C5  D5   A9   B9   C9   D9</span><br><span class="line">2  A2  B2  C2  D2  A6  B6  C6  D6  A10  B10  C10  D10</span><br><span class="line">3  A3  B3  C3  D3  A7  B7  C7  D7  A11  B11  C11  D11</span><br></pre></td></tr></table></figure><h4 id="5-5-2-pandas-merge"><a href="#5-5-2-pandas-merge" class="headerlink" title="5.5.2 pandas.merge()"></a>5.5.2 pandas.merge()</h4><p>concat函数可以实现内外连接, 而pandas的merge函数可以真正实现数据库的内外连接, 且外连接还可以有左右连接的特性. 用法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pandas.merge(left, right, how=<span class="string">&#x27;inner&#x27;</span>, on=<span class="literal">None</span>, left_on=<span class="literal">None</span>, right_on=<span class="literal">None</span>, left_index=<span class="literal">False</span>, right_index=<span class="literal">False</span>, sort=<span class="literal">True</span>, suffixes=(<span class="string">&#x27;_x&#x27;</span>,<span class="string">&#x27;_y&#x27;</span>), copy=<span class="literal">True</span>, indicator=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># left: 拼接的左侧DataFrame对象</span></span><br><span class="line"><span class="comment"># right: 拼接的右侧DataFrame对象</span></span><br><span class="line"><span class="comment"># on: 要加入的列或索引级别名称. 必须在左侧和右侧DataFrame对象中找到. 如果未传递且left_index和right_index为False, 则DataFrame中的列的交集将被推断为连接键.</span></span><br><span class="line"><span class="comment"># left_on: 左侧DataFrame中的列或索引级别用作键.</span></span><br><span class="line"><span class="comment"># right_on: 右侧DataFrame中的列或索引级别用作键.</span></span><br><span class="line"><span class="comment"># left_index: 如果为True，则使用左侧DataFrame中的索引（行标签）作为其连接键.</span></span><br><span class="line"><span class="comment"># right_index: 与left_index功能相似.</span></span><br><span class="line"><span class="comment"># how: One of &#x27;left&#x27;, &#x27;right&#x27;, &#x27;outer&#x27;, &#x27;inner&#x27;. 默认inner. inner是取交集，outer取并集.</span></span><br><span class="line"><span class="comment"># copy: 始终从传递的DataFrame对象复制数据 (默认为True), 即使不需要重建索引也是如此.</span></span><br></pre></td></tr></table></figure><p><strong>我们看一个简单的例子</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">left = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K2&#x27;</span>, <span class="string">&#x27;K3&#x27;</span>],</span><br><span class="line">                       <span class="string">&#x27;A&#x27;</span>: [<span class="string">&#x27;A0&#x27;</span>, <span class="string">&#x27;A1&#x27;</span>, <span class="string">&#x27;A2&#x27;</span>, <span class="string">&#x27;A3&#x27;</span>],</span><br><span class="line">                       <span class="string">&#x27;B&#x27;</span>: [<span class="string">&#x27;B0&#x27;</span>, <span class="string">&#x27;B1&#x27;</span>, <span class="string">&#x27;B2&#x27;</span>, <span class="string">&#x27;B3&#x27;</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K2&#x27;</span>, <span class="string">&#x27;K3&#x27;</span>],</span><br><span class="line">                        <span class="string">&#x27;C&#x27;</span>: [<span class="string">&#x27;C0&#x27;</span>, <span class="string">&#x27;C1&#x27;</span>, <span class="string">&#x27;C2&#x27;</span>, <span class="string">&#x27;C3&#x27;</span>],</span><br><span class="line">                        <span class="string">&#x27;D&#x27;</span>: [<span class="string">&#x27;D0&#x27;</span>, <span class="string">&#x27;D1&#x27;</span>, <span class="string">&#x27;D2&#x27;</span>, <span class="string">&#x27;D3&#x27;</span>]&#125;)</span><br><span class="line">result = pd.merge(left, right, on=<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;左表是:&#x27;</span>)</span><br><span class="line">print(left)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;右表示:&#x27;</span>)</span><br><span class="line">print(right)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;拼接结果是:&#x27;</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">左表是:</span><br><span class="line">  key   A   B</span><br><span class="line">0  K0  A0  B0</span><br><span class="line">1  K1  A1  B1</span><br><span class="line">2  K2  A2  B2</span><br><span class="line">3  K3  A3  B3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">右表是:</span><br><span class="line">  key   C   D</span><br><span class="line">0  K0  C0  D0</span><br><span class="line">1  K1  C1  D1</span><br><span class="line">2  K2  C2  D2</span><br><span class="line">3  K3  C3  D3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">拼接结果是:</span><br><span class="line">  key   A   B   C   D</span><br><span class="line">0  K0  A0  B0  C0  D0</span><br><span class="line">1  K1  A1  B1  C1  D1</span><br><span class="line">2  K2  A2  B2  C2  D2</span><br><span class="line">3  K3  A3  B3  C3  D3</span><br></pre></td></tr></table></figure><p><strong>传入的 on 也可以是列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">left = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K2&#x27;</span>],</span><br><span class="line">                      <span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>],</span><br><span class="line">                         <span class="string">&#x27;A&#x27;</span>: [<span class="string">&#x27;A0&#x27;</span>, <span class="string">&#x27;A1&#x27;</span>, <span class="string">&#x27;A2&#x27;</span>, <span class="string">&#x27;A3&#x27;</span>],</span><br><span class="line">                         <span class="string">&#x27;B&#x27;</span>: [<span class="string">&#x27;B0&#x27;</span>, <span class="string">&#x27;B1&#x27;</span>, <span class="string">&#x27;B2&#x27;</span>, <span class="string">&#x27;B3&#x27;</span>]&#125;)</span><br><span class="line"></span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K2&#x27;</span>],</span><br><span class="line">                      <span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>],</span><br><span class="line">                         <span class="string">&#x27;C&#x27;</span>: [<span class="string">&#x27;C0&#x27;</span>, <span class="string">&#x27;C1&#x27;</span>, <span class="string">&#x27;C2&#x27;</span>, <span class="string">&#x27;C3&#x27;</span>],</span><br><span class="line">                         <span class="string">&#x27;D&#x27;</span>: [<span class="string">&#x27;D0&#x27;</span>, <span class="string">&#x27;D1&#x27;</span>, <span class="string">&#x27;D2&#x27;</span>, <span class="string">&#x27;D3&#x27;</span>]&#125;)</span><br><span class="line">result = pd.merge(left, right, on=[<span class="string">&#x27;key1&#x27;</span>,<span class="string">&#x27;key2&#x27;</span>])</span><br><span class="line">print(<span class="string">&#x27;左表是:&#x27;</span>)</span><br><span class="line">print(left)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;右表是:&#x27;</span>)</span><br><span class="line">print(right)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;拼接结果是:&#x27;</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">左表是:</span><br><span class="line">  key1 key2   A   B</span><br><span class="line">0   K0   K0  A0  B0</span><br><span class="line">1   K0   K1  A1  B1</span><br><span class="line">2   K1   K0  A2  B2</span><br><span class="line">3   K2   K1  A3  B3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">右表是:</span><br><span class="line">  key1 key2   C   D</span><br><span class="line">0   K0   K0  C0  D0</span><br><span class="line">1   K1   K0  C1  D1</span><br><span class="line">2   K1   K0  C2  D2</span><br><span class="line">3   K2   K0  C3  D3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">拼接结果是:</span><br><span class="line">  key1 key2   A   B   C   D</span><br><span class="line">0   K0   K0  A0  B0  C0  D0</span><br><span class="line">1   K1   K0  A2  B2  C1  D1</span><br><span class="line">2   K1   K0  A2  B2  C2  D2</span><br></pre></td></tr></table></figure><p><strong>左外连接</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">left = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K2&#x27;</span>],</span><br><span class="line">                      <span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>],</span><br><span class="line">                         <span class="string">&#x27;A&#x27;</span>: [<span class="string">&#x27;A0&#x27;</span>, <span class="string">&#x27;A1&#x27;</span>, <span class="string">&#x27;A2&#x27;</span>, <span class="string">&#x27;A3&#x27;</span>],</span><br><span class="line">                         <span class="string">&#x27;B&#x27;</span>: [<span class="string">&#x27;B0&#x27;</span>, <span class="string">&#x27;B1&#x27;</span>, <span class="string">&#x27;B2&#x27;</span>, <span class="string">&#x27;B3&#x27;</span>]&#125;)</span><br><span class="line"></span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K2&#x27;</span>],</span><br><span class="line">                      <span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>],</span><br><span class="line">                         <span class="string">&#x27;C&#x27;</span>: [<span class="string">&#x27;C0&#x27;</span>, <span class="string">&#x27;C1&#x27;</span>, <span class="string">&#x27;C2&#x27;</span>, <span class="string">&#x27;C3&#x27;</span>],</span><br><span class="line">                         <span class="string">&#x27;D&#x27;</span>: [<span class="string">&#x27;D0&#x27;</span>, <span class="string">&#x27;D1&#x27;</span>, <span class="string">&#x27;D2&#x27;</span>, <span class="string">&#x27;D3&#x27;</span>]&#125;)</span><br><span class="line">result = pd.merge(left, right, how=<span class="string">&#x27;left&#x27;</span>, on=[<span class="string">&#x27;key1&#x27;</span>,<span class="string">&#x27;key2&#x27;</span>])</span><br><span class="line">print(<span class="string">&#x27;左表是:&#x27;</span>)</span><br><span class="line">print(left)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;右表是:&#x27;</span>)</span><br><span class="line">print(right)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;拼接结果是:&#x27;</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">左表是:</span><br><span class="line">  key1 key2   A   B</span><br><span class="line">0   K0   K0  A0  B0</span><br><span class="line">1   K0   K1  A1  B1</span><br><span class="line">2   K1   K0  A2  B2</span><br><span class="line">3   K2   K1  A3  B3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">右表是:</span><br><span class="line">  key1 key2   C   D</span><br><span class="line">0   K0   K0  C0  D0</span><br><span class="line">1   K1   K0  C1  D1</span><br><span class="line">2   K1   K0  C2  D2</span><br><span class="line">3   K2   K0  C3  D3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">拼接结果是:</span><br><span class="line">  key1 key2   A   B    C    D</span><br><span class="line">0   K0   K0  A0  B0   C0   D0</span><br><span class="line">1   K0   K1  A1  B1  NaN  NaN</span><br><span class="line">2   K1   K0  A2  B2   C1   D1</span><br><span class="line">3   K1   K0  A2  B2   C2   D2</span><br><span class="line">4   K2   K1  A3  B3  NaN  NaN</span><br></pre></td></tr></table></figure><h3 id="5-6-Reforming-Data"><a href="#5-6-Reforming-Data" class="headerlink" title="5.6 Reforming Data"></a>5.6 Reforming Data</h3><h4 id="5-6-1-DataFrame-pivot"><a href="#5-6-1-DataFrame-pivot" class="headerlink" title="5.6.1 DataFrame.pivot()"></a>5.6.1 DataFrame.pivot()</h4><p>返回按给定索引/列以及制定的<strong>列值</strong>的重新构造的 <code>pivot table</code>. 如果作为 <code>columns</code> 的列具有重复值, 那么在使用 <code>pivot</code> 函数的时候就会报错, 此时我们需要使用<code>DataFrame.pivot_table</code>.</p><p><code>DataFrame.pivot()</code> 的用法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DataFrame.pivot(self, index=<span class="literal">None</span>, columns=<span class="literal">None</span>, values=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># index: 用于制作新 frame 索引的列. 如果为None, 则使用现有索引.</span></span><br><span class="line"><span class="comment"># columns: 用于制作新 frame columns的列.</span></span><br><span class="line"><span class="comment"># values: 用于填充新frame值的列. 如果未指定, 将使用所有剩余的列, 并且结果将具有按层次结构索引的列.</span></span><br></pre></td></tr></table></figure><p><strong>看个例子</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;foo&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>,</span><br><span class="line">                            <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">                     <span class="string">&#x27;bar&#x27;</span>: [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>],</span><br><span class="line">                     <span class="string">&#x27;baz&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">                     <span class="string">&#x27;zoo&#x27;</span>: [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;t&#x27;</span>]&#125;)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;使用 pivot 函数:&#x27;</span>)</span><br><span class="line">print(df.pivot(index=<span class="string">&#x27;foo&#x27;</span>, columns=<span class="string">&#x27;bar&#x27;</span>))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line">   foo bar  baz zoo</span><br><span class="line">0  one   A    1   x</span><br><span class="line">1  one   B    2   y</span><br><span class="line">2  one   C    3   z</span><br><span class="line">3  two   A    4   q</span><br><span class="line">4  two   B    5   w</span><br><span class="line">5  two   C    6   t</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用 pivot 函数:</span><br><span class="line">    baz       zoo</span><br><span class="line">bar   A  B  C   A  B  C</span><br><span class="line">foo</span><br><span class="line">one   1  2  3   x  y  z</span><br><span class="line">two   4  5  6   q  w  t</span><br></pre></td></tr></table></figure><h4 id="5-6-2-DataFrame-pivot-table"><a href="#5-6-2-DataFrame-pivot-table" class="headerlink" title="5.6.2 DataFrame.pivot_table()"></a>5.6.2 DataFrame.pivot_table()</h4><p>与 <code>pivot</code> 相比，该方法可以汇总多个重复条目的数据. 我们可以用均值、中位数或者其他汇总函数来计算重复条目的数值. <code>pivot_table</code> 方法需要传递一个新的参数 <code>aggfunc</code>, 该参数用于指明转换时所需的汇总函数. 我们看个图解:</p><p><img src="https://i.loli.net/2020/08/21/bKMwTRQqtrDHfEs.png" alt="image-20200820012507360"></p><p><strong>该函数的用法如下</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DataFrame.pivot_table(self, index=<span class="literal">None</span>, columns=<span class="literal">None</span>, values=<span class="literal">None</span>, aggfunc=<span class="string">&#x27;mean&#x27;</span>, fill_value=<span class="literal">None</span>, margins=<span class="literal">False</span>, dropna=<span class="literal">True</span>, margins_name=<span class="string">&#x27;All&#x27;</span>, observed=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># index: 用于制作新 pivot table 索引的列. 如果为None, 则使用现有索引.</span></span><br><span class="line"><span class="comment"># columns: 用于制作新 pivot table columns的列.</span></span><br><span class="line"><span class="comment"># values: 要汇总的列</span></span><br><span class="line"><span class="comment"># aggfunc: 如何处理重复数据</span></span><br><span class="line"><span class="comment"># fill_value: 替换缺失值</span></span><br><span class="line"><span class="comment"># margins: 添加行/列小计和总计</span></span><br></pre></td></tr></table></figure><p><strong>我们来看一个 NBA 的例子, 先读取数据</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;James_Harden.csv&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><p>输出结果是:</p><p><img src="https://i.loli.net/2020/08/20/Xj364nqTMADB1dl.png" alt="image-20200820190107889" style="zoom:50%;" /></p><p><strong>然后我们看一下哈登对阵每个队伍的情况</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.pivot_table(index=<span class="string">u&#x27;对手&#x27;</span>).head()</span><br></pre></td></tr></table></figure><p>输出结果是:</p><p><img src="https://i.loli.net/2020/08/20/FYWljmPbdVKo691.png" alt="image-20200820190455915" style="zoom:50%;" /></p><p><strong>让我们继续深入, 不同对手以及主客场情况下的得分概况</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.pivot_table(index=[<span class="string">u&#x27;对手&#x27;</span>,<span class="string">u&#x27;主客场&#x27;</span>])</span><br></pre></td></tr></table></figure><p>输出结果是:</p><p><img src="https://i.loli.net/2020/08/20/FV64UcYhI2MtfvQ.png" alt="image-20200820190654432" style="zoom:50%;" /></p><blockquote><p>看完上面几个操作, Index就是层次字段, 要通过透视表获取什么信息就按照相应的顺序设置字段，所以在进行pivot之前你也需要足够了解你的数据.</p></blockquote><p><strong>当我们未设置 <code>aggfunc</code> 时, 它默认 <code>aggfunc=&#39;mean&#39;</code> 计算均值. 我们还想要获得james harden在主客场和不同胜负情况下的总得分、总篮板、总助攻概况</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.pivot_table(index=[<span class="string">u&#x27;主客场&#x27;</span>,<span class="string">u&#x27;胜负&#x27;</span>],values=[<span class="string">u&#x27;得分&#x27;</span>,<span class="string">u&#x27;助攻&#x27;</span>,<span class="string">u&#x27;篮板&#x27;</span>],aggfunc=[np.<span class="built_in">sum</span>,np.mean])</span><br></pre></td></tr></table></figure><p>输出结果是:</p><p><img src="https://i.loli.net/2020/08/20/Iy7rDxTM2ERGjBl.png" alt="image-20200820191134830" style="zoom:50%;" /></p><blockquote><p>  Columns类似Index可以设置列层次字段, 它不是一个必要参数, 作为一种分割数据的可选方式.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.pivot_table(index=[<span class="string">u&#x27;主客场&#x27;</span>],columns=[<span class="string">u&#x27;对手&#x27;</span>],values=[<span class="string">u&#x27;得分&#x27;</span>],aggfunc=[np.<span class="built_in">sum</span>],fill_value=<span class="number">0</span>,margins=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><p><img src="https://i.loli.net/2020/08/20/9I8QvYmnkU2bVAz.png" alt="image-20200820191513716" style="zoom:50%;" /></p><blockquote><p>  最后看一个综合的例子</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.pivot_table(index=[<span class="string">u&#x27;对手&#x27;</span>,<span class="string">u&#x27;胜负&#x27;</span>],columns=[<span class="string">u&#x27;主客场&#x27;</span>],values=[<span class="string">u&#x27;得分&#x27;</span>,<span class="string">u&#x27;助攻&#x27;</span>,<span class="string">u&#x27;篮板&#x27;</span>],aggfunc=[np.mean],fill_value=<span class="number">0</span>).head()</span><br></pre></td></tr></table></figure><p>输出结果是:</p><p><img src="https://i.loli.net/2020/08/20/4tmsjNbiXU8Twgx.png" alt="image-20200820191913922" style="zoom:50%;" /></p><h3 id="5-7-Aggregating-Data"><a href="#5-7-Aggregating-Data" class="headerlink" title="5.7 Aggregating Data"></a>5.7 Aggregating Data</h3><h4 id="5-7-1-DataFrame-groupby"><a href="#5-7-1-DataFrame-groupby" class="headerlink" title="5.7.1 DataFrame.groupby()"></a>5.7.1 DataFrame.groupby()</h4><p>在SQL语言里有group by功能，在Pandas里有groupby函数与之功能相对应. DataFrame数据对象经groupby()之后返回的结果是一个 <code>DataFrameGroupBy</code> 对象, 而不是一个 <code>DataFrame</code> 或者 <code>Series</code> 对象, 所以, 它们中的一些方法或者函数是无法直接调用的, 需要按照 <code>GroupBy</code> 对象中具有的函数和方法进行调用.</p><ul><li><code>ngroups</code> 反应的是分组的个数</li><li><code>groups</code> 类似 dict 结构</li><li><code>size()</code> 则是可以返回所有分组的数据个数.</li><li><code>count()</code> 可以统计分组后各列数据项个数</li><li><code>get_group()</code> 可以返回指定组的数据信息</li><li><code>discribe()</code> 可以返回分组后的数据的统计数据</li></ul><p><strong>我们创建一个 DataFrame</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">name = [<span class="string">&#x27;Alen&#x27;</span>,<span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;Cidy&#x27;</span>,<span class="string">&#x27;Daniel&#x27;</span>,<span class="string">&#x27;Ellen&#x27;</span>,<span class="string">&#x27;Frankie&#x27;</span>,<span class="string">&#x27;Gate&#x27;</span>,<span class="string">&#x27;Hebe&#x27;</span>]</span><br><span class="line">gender = [<span class="string">&#x27;Male&#x27;</span>,<span class="string">&#x27;Male&#x27;</span>,<span class="string">&#x27;Female&#x27;</span>,<span class="string">&#x27;Male&#x27;</span>,<span class="string">&#x27;Female&#x27;</span>,<span class="string">&#x27;Male&#x27;</span>,<span class="string">&#x27;Male&#x27;</span>,<span class="string">&#x27;Female&#x27;</span>]</span><br><span class="line">age = [<span class="number">18</span>,<span class="number">19</span>,<span class="number">18</span>,<span class="number">20</span>,<span class="number">17</span>,<span class="number">21</span>,<span class="number">20</span>,<span class="number">22</span>]</span><br><span class="line">score = [<span class="number">80</span>,<span class="number">90</span>,<span class="number">93</span>,<span class="number">87</span>,<span class="number">96</span>,<span class="number">100</span>,<span class="number">88</span>,<span class="number">98</span>]</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(data=&#123;<span class="string">&#x27;Name&#x27;</span>:name,<span class="string">&#x27;Gender&#x27;</span>:gender,<span class="string">&#x27;Age&#x27;</span>:age,<span class="string">&#x27;Score&#x27;</span>:score&#125;)</span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line">      Name  Gender  Age  Score</span><br><span class="line">0     Alen    Male   18     80</span><br><span class="line">1      Bob    Male   19     90</span><br><span class="line">2     Cidy  Female   18     93</span><br><span class="line">3   Daniel    Male   20     87</span><br><span class="line">4    Ellen  Female   17     96</span><br><span class="line">5  Frankie    Male   21    100</span><br><span class="line">6     Gate    Male   20     88</span><br><span class="line">7     Hebe  Female   22     98</span><br></pre></td></tr></table></figure><p><strong>我们使用 <code>groupby()</code> 函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grouped = df.groupby(<span class="string">&#x27;Gender&#x27;</span>)</span><br><span class="line">print(<span class="built_in">type</span>(grouped))</span><br><span class="line">print(grouped)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#39;pandas.core.groupby.generic.DataFrameGroupBy&#39;&gt;</span><br><span class="line">&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x7fb650d31490&gt;</span><br></pre></td></tr></table></figure><p><strong>分组时, 不仅仅可以指定一个列名, 也可以指定多个列名</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">grouped = df.groupby(<span class="string">&#x27;Gender&#x27;</span>)</span><br><span class="line">grouped_muti = df.groupby([<span class="string">&#x27;Gender&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"></span><br><span class="line">print(grouped.size())</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(grouped_muti.size())</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Gender</span><br><span class="line">Female    3</span><br><span class="line">Male      5</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Gender  Age</span><br><span class="line">Female  17     1</span><br><span class="line">        18     1</span><br><span class="line">        22     1</span><br><span class="line">Male    18     1</span><br><span class="line">        19     1</span><br><span class="line">        20     2</span><br><span class="line">        21     1</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><p><strong>指定多个列名个单个列名后的区别在于, 分组的索引 (index) 将一个是单个主键, 另一个则是一个元组的形式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = grouped.get_group(<span class="string">&#x27;Female&#x27;</span>)</span><br><span class="line">b = grouped_muti.get_group((<span class="string">&#x27;Female&#x27;</span>,<span class="number">17</span>))</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Name  Age  Score</span><br><span class="line">2   Cidy   18     93</span><br><span class="line">4  Ellen   17     96</span><br><span class="line">7   Hebe   22     98</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Name  Gender  Age  Score</span><br><span class="line">4  Ellen  Female   17     96</span><br></pre></td></tr></table></figure><blockquote><p>  注: 通过调用<code>get_group()</code>函数可以返回一个按照分组得到的<code>DataFrame</code>对象, 所以接下来的使用就可以按照·DataFrame·对象来使用. 如果想让这个<code>DataFrame</code>对象的索引重新定义可以通过:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(grouped.get_group(<span class="string">&#x27;Female&#x27;</span>).reset_index())</span><br></pre></td></tr></table></figure><p>  输出结果是:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   index   Name  Age  Score</span><br><span class="line">0      2   Cidy   18     93</span><br><span class="line">1      4  Ellen   17     96</span><br><span class="line">2      7   Hebe   22     98</span><br></pre></td></tr></table></figure><h4 id="5-7-2-DataFrame-agg"><a href="#5-7-2-DataFrame-agg" class="headerlink" title="5.7.2 DataFrame.agg()"></a>5.7.2 DataFrame.agg()</h4></blockquote><p>在对数据进行分组之后, 可以对分组后的数据进行聚合处理统计. 用法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DataFrame.agg(func, axis=<span class="number">0</span>, *args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># func: 用于聚合数据的函数</span></span><br><span class="line"><span class="comment">#- 字符串函数名称</span></span><br><span class="line"><span class="comment">#- 函数</span></span><br><span class="line"><span class="comment">#  - 函数列表</span></span><br><span class="line"><span class="comment">#  - 列名称:函数或函数列表的字典</span></span><br><span class="line"><span class="comment"># axis: 0--&gt;竖直, 1--&gt;水平</span></span><br></pre></td></tr></table></figure><p><strong>看个例子, 求 age 和 score 的 mean 和 sum</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">name = [<span class="string">&#x27;Alen&#x27;</span>,<span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;Cidy&#x27;</span>,<span class="string">&#x27;Daniel&#x27;</span>,<span class="string">&#x27;Ellen&#x27;</span>,<span class="string">&#x27;Frankie&#x27;</span>,<span class="string">&#x27;Gate&#x27;</span>,<span class="string">&#x27;Hebe&#x27;</span>]</span><br><span class="line">gender = [<span class="string">&#x27;Male&#x27;</span>,<span class="string">&#x27;Male&#x27;</span>,<span class="string">&#x27;Female&#x27;</span>,<span class="string">&#x27;Male&#x27;</span>,<span class="string">&#x27;Female&#x27;</span>,<span class="string">&#x27;Male&#x27;</span>,<span class="string">&#x27;Male&#x27;</span>,<span class="string">&#x27;Female&#x27;</span>]</span><br><span class="line">age = [<span class="number">18</span>,<span class="number">19</span>,<span class="number">18</span>,<span class="number">20</span>,<span class="number">17</span>,<span class="number">21</span>,<span class="number">20</span>,<span class="number">22</span>]</span><br><span class="line">score = [<span class="number">80</span>,<span class="number">90</span>,<span class="number">93</span>,<span class="number">87</span>,<span class="number">96</span>,<span class="number">100</span>,<span class="number">88</span>,<span class="number">98</span>]</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(data=&#123;<span class="string">&#x27;Name&#x27;</span>:name,<span class="string">&#x27;Gender&#x27;</span>:gender,<span class="string">&#x27;Age&#x27;</span>:age,<span class="string">&#x27;Score&#x27;</span>:score&#125;)</span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;使用 agg 函数:&#x27;</span>)</span><br><span class="line">print(df.agg(&#123;<span class="string">&#x27;Age&#x27;</span>:[<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;mean&#x27;</span>],<span class="string">&#x27;Score&#x27;</span>:[<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;mean&#x27;</span>]&#125;))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;我们也可以使用自定义的 lambda 函数:&#x27;</span>)</span><br><span class="line">get_max = <span class="keyword">lambda</span> x: x.sort_values(ascending=<span class="literal">False</span>).iloc[<span class="number">0</span>]</span><br><span class="line">get_max.__name__ = <span class="string">&#x27;get_max&#x27;</span></span><br><span class="line">print(df.agg(&#123;<span class="string">&#x27;Age&#x27;</span>:[get_max],<span class="string">&#x27;Score&#x27;</span>:[get_max]&#125;))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">我们的数据是:</span><br><span class="line">      Name  Gender  Age  Score</span><br><span class="line">0     Alen    Male   18     80</span><br><span class="line">1      Bob    Male   19     90</span><br><span class="line">2     Cidy  Female   18     93</span><br><span class="line">3   Daniel    Male   20     87</span><br><span class="line">4    Ellen  Female   17     96</span><br><span class="line">5  Frankie    Male   21    100</span><br><span class="line">6     Gate    Male   20     88</span><br><span class="line">7     Hebe  Female   22     98</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用 agg 函数:</span><br><span class="line">          Age  Score</span><br><span class="line">sum   155.000  732.0</span><br><span class="line">mean   19.375   91.5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们也可以使用自定义的 lambda 函数:</span><br><span class="line">         Age  Score</span><br><span class="line">get_max   22    100</span><br></pre></td></tr></table></figure><h4 id="5-7-3-DataFrame-transform"><a href="#5-7-3-DataFrame-transform" class="headerlink" title="5.7.3 DataFrame.transform()"></a>5.7.3 DataFrame.transform()</h4><p>调用<code>func</code>自己产生一个改变值的和自己的相同的轴长度的<code>DataFrame</code>. </p><p>直接看例子:</p><p>假设我们有下面的<a href="https://github.com/chris1610/pbpython/blob/master/data/sales_transactions.xlsx?raw=true">销售数据</a>, 有三个不同的 <strong>订单id</strong>  (10001, 10005和10006), 每个 订单id又含有多个产品.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.read_excel(<span class="string">&#x27;sales_transactions.xlsx&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;我们的数据是:&#x27;</span>)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><p><img src="https://i.loli.net/2020/08/21/PkKfqbH9TBmvGtl.png" alt="image-20200821153859613" style="zoom:50%;" /></p><p><strong>我们现在要求解的问题是: 每个订单中各个单品费用分布及占比</strong>. <strong>例如订单10001总价$576.12，细分一下:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B1-20000 &#x3D; $235.83 or 40.9%</span><br><span class="line">S1-27722 &#x3D; $232.32 or 40.3%</span><br><span class="line">B1-86481 &#x3D; $107.97 or 18.7%</span><br></pre></td></tr></table></figure><p><strong>解决这个问题用两种方式:</strong></p><p>第一种新建 DataFrame 然后 merge 两个 DataFrame. 代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">order_total = df.groupby(<span class="string">&#x27;order&#x27;</span>)[<span class="string">&quot;ext price&quot;</span>].<span class="built_in">sum</span>().rename(<span class="string">&quot;Order_Total&quot;</span>).reset_index()</span><br><span class="line"></span><br><span class="line">df_1 = df.merge(order_total)</span><br><span class="line">df_1[<span class="string">&quot;Percent_of_Order&quot;</span>] = df_1[<span class="string">&quot;ext price&quot;</span>] / df_1[<span class="string">&quot;Order_Total&quot;</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;新建的 DataFrame 是:&#x27;</span>)</span><br><span class="line">print(order_total)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;我们的结果是:&#x27;</span>)</span><br><span class="line">print(df_1)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><blockquote><p>  <strong>新建的 DataFrame 是:</strong></p><p>  <img src="https://i.loli.net/2020/08/21/py6zmaZlnShGP7U.png" alt="image-20200821163934164" style="zoom:50%;" /></p><p>  <strong>我们的结果是:</strong></p><p>  <img src="https://i.loli.net/2020/08/21/wThdLUcA9VDusrq.png" alt="image-20200821163951790" style="zoom:50%;" /></p></blockquote><p>第二种就是使用 <code>DataFrame.transform()</code> 这个函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.read_excel(<span class="string">&#x27;sales_transactions.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line">df[<span class="string">&quot;Percent_of_Order&quot;</span>] = df[<span class="string">&quot;ext price&quot;</span>] / df.groupby(<span class="string">&#x27;order&#x27;</span>)[<span class="string">&quot;ext price&quot;</span>].transform(<span class="string">&#x27;sum&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;我们的结果是:&#x27;</span>)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><blockquote><p>  <strong>我们的结果是:</strong></p><p>  <img src="https://i.loli.net/2020/08/21/glw2KidqnrxBJES.png" alt="image-20200821164332003" style="zoom:50%;" /></p></blockquote><h2 id="Topic-6-Pandas-IO"><a href="#Topic-6-Pandas-IO" class="headerlink" title="Topic 6 Pandas IO"></a>Topic 6 Pandas IO</h2><p>平时工作中, 我们会接触到不同的数据文件, 比如很常见的excel文件(后缀名为xls和xlsx), csv、txt等文本文件, json文件以及sql文件等等. pandas读取这些数据文件的方法如表格所示:</p><div class="table-container"><table><thead><tr><th>读取方法</th><th>描述</th><th>写入方法</th></tr></thead><tbody><tr><td><code>read_csv</code></td><td>读取 csv 文件, 逗号是默认分隔符</td><td><code>to_csv</code></td></tr><tr><td><code>read_table</code></td><td>读取通用分隔符分割的数据文件, 默认为制表符 <code>\t</code></td><td><code>to_csv</code></td></tr><tr><td><code>read_excel</code></td><td>读取 <code>xls</code> 或者 <code>xlsx</code> 表格文件</td><td><code>to_excel</code></td></tr><tr><td><code>read_json</code></td><td>读取 <code>json</code> 文件</td><td><code>to_json</code></td></tr><tr><td><code>read_sql</code></td><td>从 SQL 请求读取或者读取数据库中的表</td><td><code>to_sql</code></td></tr><tr><td><code>read_sql_table</code></td><td>读取数据库中的表</td><td><code>to_sql</code></td></tr><tr><td><code>read_sql_query</code></td><td>从 SQL 请求读取数据</td><td><code>to_sql</code></td></tr></tbody></table></div><h3 id="6-1-pandas-read-csv"><a href="#6-1-pandas-read-csv" class="headerlink" title="6.1 pandas.read_csv()"></a>6.1 pandas.read_csv()</h3><p><strong>read_csv()方法用来读取 csv格式的数据文件, read_table()方法则是读取通用分隔符分隔的数据文件</strong>, 它们的参数相同, 语法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pandas.read_csv(filepath_or_buffer, sep=<span class="string">&#x27;,&#x27;</span>, delimiter=<span class="literal">None</span>, header=<span class="string">&#x27;infer&#x27;</span>, names=<span class="literal">None</span>, index_col=<span class="literal">None</span>, usecols=<span class="literal">None</span>, skiprows=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># filepath_or_buffer: str, 表示文件所在位置的字符串, URL等.</span></span><br><span class="line"><span class="comment"># sep: str, 表示分隔符, 分隔符号可以有多个, 比如分隔符为&quot;+,+&quot;三个符号, 则sep = &#x27;+,+&#x27;, 即正则表达式. read_csv默认分隔符为&quot;,&quot;, read_table默认为制表符&quot;\t&quot;</span></span><br><span class="line"><span class="comment"># delimitter: sep的别名</span></span><br><span class="line"><span class="comment"># header: int, 表示列名的行号. 如果没有传递列名, 则header = 0, 列名为文件的第一行. 如果显式传递了列名, 则header = None</span></span><br><span class="line"><span class="comment"># names: 指定列名</span></span><br><span class="line"><span class="comment"># index_col: int,sequence或False. 表示索引列的位置, 取值为sequence则代表多重索引</span></span><br><span class="line"><span class="comment"># usecols: array, 指定读取的列</span></span><br><span class="line"><span class="comment"># skiprows: 从文件开头算, 需要跳过的行数</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction to Numpy</title>
      <link href="2020/08/18/Introduction-to-Numpy/"/>
      <url>2020/08/18/Introduction-to-Numpy/</url>
      
        <content type="html"><![CDATA[<p>NumPy is the fundamental package for scientific computing in Python. It is a Python library that provides a multidimensional array object, various derived objects (such as masked arrays and matrices), and an assortment of routines for fast operations on arrays, including mathematical, logical, shape manipulation, sorting, selecting, I/O, discrete Fourier transforms, basic linear algebra, basic statistical operations, random simulation and much more.</p><h2 id="Topic-1-Ndarray"><a href="#Topic-1-Ndarray" class="headerlink" title="Topic 1 Ndarray"></a>Topic 1 Ndarray</h2><p>NumPy 最重要的一个特点是其 N 维数组对象 ndarray, 它是<strong>一系列同类型数据</strong>的集合, 以 0 下标为开始进行集合中元素的索引. ndarray 有两个个重点:</p><ul><li>ndarray 对象是用于<strong>存放同类型元素</strong>的多维数组. </li><li>ndarray 中的<strong>每个元素</strong>在<strong>内存</strong>中都有<strong>相同存储大小的区域</strong>. </li></ul><blockquote><p>  创建一个 ndarray 只需要调用 Numpy 的 array 函数即可:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.array(<span class="built_in">object</span>, dtype=<span class="literal">None</span>, copy=<span class="literal">True</span>, order=<span class="literal">None</span>, subok=<span class="literal">False</span>, ndmin=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>  <strong>参数说明:</strong></p><ul><li>object: 数组或嵌套的数列</li><li>dtype: 数组元素的数据类型, 可选</li><li>copy: 对象是否需要复制, 可选</li><li>order: 创建数组的样式, C 为行方向, F 为列方向, A 为任意方向 (默认)</li><li>subok: 默认返回一个与基类类型一致的数组</li><li>ndmin: 指定生成数组的最小维度</li></ul></blockquote><p>我们看几个实例:</p><p><strong>[例 1.1] 创建一维数组</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3]</span><br></pre></td></tr></table></figure><p><strong>[例 1.2] 创建二维数组</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[1,2]</span><br><span class="line"> [3,4]]</span><br></pre></td></tr></table></figure><p><strong>[例 1.3] 指定最小维度</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],ndmin=<span class="number">2</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[1,2,3,4,5]]</span><br></pre></td></tr></table></figure><p><strong>[例 1.4] 指定数据类型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],dtype=<span class="built_in">complex</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1.+0.j 2.+0.j 3.+0.j]</span><br></pre></td></tr></table></figure><h2 id="Topic-2-Data-Type"><a href="#Topic-2-Data-Type" class="headerlink" title="Topic 2 Data Type"></a>Topic 2 Data Type</h2><p>在这里我假设你已经有了一定的 python 的基础. Numpy 支持比 Python 更多种类的数组数据类型. 本节主要是介绍一下 Numpy 里面常用的数据类型.</p><div class="table-container"><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>bool_</td><td>布尔型数据类型 (True 或者 False)</td></tr><tr><td>int_</td><td>默认的整数类型</td></tr><tr><td>intc</td><td>与 C 的 int 类型一样, 一般是 int32 或 int 64</td></tr><tr><td>intp</td><td>用于索引的整数类型 (类似于 C 的 ssize_t, 一般情况下仍然是 int32 或 int64)</td></tr><tr><td>int8</td><td>字节 ($-2^7\ to\ 2^7-1$)</td></tr><tr><td>int16</td><td>整数 ($-2^{15}\ to\ 2^{15}-1$)</td></tr><tr><td>int32</td><td>整数 ($-2^{31}\ to\ 2^{31}-1$)</td></tr><tr><td>int64</td><td>整数 ($-2^{63}\ to\ 2^{63}-1$)</td></tr><tr><td>uint8</td><td>无符号整数 ($2^8-1$)</td></tr><tr><td>uint16</td><td>无符号整数 ($2^{16}-1$)</td></tr><tr><td>uint32</td><td>无符号整数 ($2^{32}-1$)</td></tr><tr><td>uint64</td><td>无符号整数 ($2^{64}-1$)</td></tr><tr><td>float_</td><td>float64 类型的简写</td></tr><tr><td>float16</td><td>半精度浮点数, 包括: 1 个符号位, 5 个指数位, 10 个尾数位   — 见注[1]和[2]</td></tr><tr><td>float32</td><td>单精度浮点数, 包括: 1 个符号位, 8 个指数位, 23 个尾数位</td></tr><tr><td>float64</td><td>双精度浮点数, 包括: 1 个符号位, 11 个指数位, 52 个尾数位</td></tr><tr><td>complex_</td><td>complex128 类型的简写, 即 128 位复数</td></tr><tr><td>complex64</td><td>复数, 表示双 32 位浮点数 (实数部分和虚数部分)</td></tr><tr><td>complex128</td><td>复数, 表示双 64 位浮点数 (实数部分和虚数部分)</td></tr></tbody></table></div><p><strong>注:</strong></p><p>[1] 所有数字以二进制存储, 每个数字对应的二进制分为三段: 符号位、指数位、尾数位. 其中<strong>符号位</strong>是二进制表示中的第一位, 0 表示正数, 1 表示负数. <strong>指数位</strong>决定了数字的范围. <strong>尾数位</strong>决定了数字的精度.</p><p>[2] 半精度是英伟达在2002年搞出来的, 双精度和单精度是为了计算, 而半精度更多是为了降低数据传输和存储成本. </p><p><strong>数据类型对象 (dtype)</strong> 是用来描述与数组对应的内存区域如何使用, 这依赖如下几个方面:</p><ul><li>数据的类型 (整数, 浮点数或者 Python 对象)</li><li>数据的大小 (例如, 整数使用多少个字节存储)</li><li>数据的字节顺序 (小端法或大端法)</li><li>在结构化类型的情况下, 字段的名称、每个字段的数据类型和每个字段所取的内存块的部分</li></ul><p>字节顺序是通过对数据类型预先设定”&lt;”或”&gt;”来决定的. “&lt;”意味着小端法(最小值存储在最小的地址, 即低位组放在最前面). “&gt;”意味着大端法 (最重要的字节存储在最小的地址, 即高位组放在最前面).</p><p>dtype 对象是使用以下语法构造的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.dtype(<span class="built_in">object</span>, align, copy)</span><br></pre></td></tr></table></figure><ul><li>object: 要转换为的数据类型对象</li><li>align: 如果为 true, 填充字段使其类似 C 的结构体</li><li>copy: 复制 dtype 对象, 如果为 false, 则是对内置数据类型对象的引用</li></ul><p>我们接下来看几个实例:</p><p><strong>[例 2.1] 使用标量类型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">dt = np.dtype(np.int32)</span><br><span class="line">print(dt)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int32</span><br></pre></td></tr></table></figure><p><strong>[例 2.2] 使用缩写</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">dt = np.dtype(<span class="string">&#x27;i4&#x27;</span>)</span><br><span class="line">print(dt)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int32</span><br></pre></td></tr></table></figure><p><strong>[例 2.3] 指定字节顺序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">dt = np.dtype(<span class="string">&#x27;&lt;i4&#x27;</span>)</span><br><span class="line">print(dt)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int32</span><br></pre></td></tr></table></figure><p><strong>[例 2.4] 创建结构化数据类型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">dt = np.dtype([(<span class="string">&#x27;age&#x27;</span>, np.int8)])</span><br><span class="line">print(dt)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(&#39;age&#39;, &#39;i1&#39;)]</span><br></pre></td></tr></table></figure><p><strong>[例 2.5] 将数据类型应用于 ndarray 对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">dt = np.dtype([(<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;i1&#x27;</span>)])</span><br><span class="line">a = np.array([(<span class="number">10</span>,),(<span class="number">20</span>,),(<span class="number">30</span>,)], dtype=dt)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(10,) (20,) (30,)]</span><br></pre></td></tr></table></figure><p><strong>[例 2.6] 类型字段名可以用于存取实际的 age 列</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">dt = np.dtype([(<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;i1&#x27;</span>)])</span><br><span class="line">a = np.array([(<span class="number">10</span>,),(<span class="number">20</span>,),(<span class="number">30</span>,)], dtype=dt)</span><br><span class="line">print(a[<span class="string">&#x27;age&#x27;</span>])</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[10 20 30]</span><br></pre></td></tr></table></figure><p><strong>[例 2.7] 定义一个结构化数据类型 student, 包含字符串字段 name, 整数字段 age, 及浮点字段 marks, 并将这个 dtype 应用到 ndarray 对象.</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">student = np.dtype([(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;S20&#x27;</span>),(<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;i1&#x27;</span>),(<span class="string">&#x27;marks&#x27;</span>,<span class="string">&#x27;f4&#x27;</span>)])</span><br><span class="line">a = np.array([(<span class="string">&#x27;abc&#x27;</span>,<span class="number">21</span>,<span class="number">50</span>),(<span class="string">&#x27;xyz&#x27;</span>,<span class="number">18</span>,<span class="number">75</span>)], dtype=student)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(b&#39;abc&#39;, 21, 50.) (b&#39;xyz&#39;, 18, 75.)]</span><br></pre></td></tr></table></figure><p><strong>注: <code>S</code> 后面的数字是表示字符串的长度, 超出会被截断.</strong></p><p>每个内建类型都有一个唯一定义它的字符代码, 如下:</p><div class="table-container"><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">对应类型</th></tr></thead><tbody><tr><td style="text-align:left">b</td><td style="text-align:left">布尔型</td></tr><tr><td style="text-align:left">i</td><td style="text-align:left">(有符号) 整型</td></tr><tr><td style="text-align:left">u</td><td style="text-align:left">无符号整型 integer</td></tr><tr><td style="text-align:left">f</td><td style="text-align:left">浮点型</td></tr><tr><td style="text-align:left">c</td><td style="text-align:left">复数浮点型</td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">timedelta（时间间隔）</td></tr><tr><td style="text-align:left">M</td><td style="text-align:left">datetime（日期时间）</td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">(Python) 对象</td></tr><tr><td style="text-align:left">S, a</td><td style="text-align:left">(byte-)字符串</td></tr><tr><td style="text-align:left">U</td><td style="text-align:left">Unicode</td></tr><tr><td style="text-align:left">V</td><td style="text-align:left">原始数据 (void)</td></tr></tbody></table></div><h2 id="Topic-3-Properties-of-Ndarray"><a href="#Topic-3-Properties-of-Ndarray" class="headerlink" title="Topic 3 Properties of Ndarray"></a>Topic 3 Properties of Ndarray</h2><p>Numpy 数组的维数称为秩 (rank), 秩就是轴的数量, 一维数组的秩是 1, 二维数组的秩为 2, 以此类推. 在 Numpy中,每一个线性的数组称为是一个轴 (axis), 也就是维度 (dimensions). 比如说,二维数组相当于是两个一维数组, 其中第一个一维数组中每个元素又是一个一维数组. 所以一维数组就是 Numpy 中的轴 (axis), 第一个轴相当于是底层数组, 第二个轴是底层数组里的数组. 而轴的数量——秩, 就是数组的维数. </p><p>很多时候可以声明 axis. axis=0, 表示沿着第 0 轴进行操作, 即对每一列进行操作. axis=1, 表示沿着第1轴进行操作, 即对每一行进行操作. Numpy 的数组中比较重要 ndarray 对象属性有:</p><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">ndarray.ndim</td><td style="text-align:left">秩，即轴的数量或维度的数量</td></tr><tr><td style="text-align:left">ndarray.shape</td><td style="text-align:left">数组的维度，对于矩阵，n 行 m 列</td></tr><tr><td style="text-align:left">ndarray.size</td><td style="text-align:left">数组元素的总个数，相当于 .shape 中 n*m 的值</td></tr><tr><td style="text-align:left">ndarray.dtype</td><td style="text-align:left">ndarray 对象的元素类型</td></tr><tr><td style="text-align:left">ndarray.itemsize</td><td style="text-align:left">ndarray 对象中每个元素的大小，以字节为单位</td></tr><tr><td style="text-align:left">ndarray.flags</td><td style="text-align:left">ndarray 对象的内存信息</td></tr><tr><td style="text-align:left">ndarray.real</td><td style="text-align:left">ndarray元素的实部</td></tr><tr><td style="text-align:left">ndarray.imag</td><td style="text-align:left">ndarray 元素的虚部</td></tr><tr><td style="text-align:left">ndarray.data</td><td style="text-align:left">包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。</td></tr></tbody></table></div><p>我们来看几个例子:</p><p><strong>[例 3.1] 使用 ndarray.ndim 返回数组的维数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">24</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(a.ndim)</span><br><span class="line"></span><br><span class="line">b = a.reshape(<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">print(b)</span><br><span class="line">print(b.ndim)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">[[[ 0  1  2]</span><br><span class="line">  [ 3  4  5]</span><br><span class="line">  [ 6  7  8]</span><br><span class="line">  [ 9 10 11]]</span><br><span class="line"></span><br><span class="line"> [[12 13 14]</span><br><span class="line">  [15 16 17]</span><br><span class="line">  [18 19 20]</span><br><span class="line">  [21 22 23]]]</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>[例 3.2] 使用 ndarray.shape 来获取数组的维度, 返回一个元组, 这个元组的长度就是维度的数目, 即 ndim 属性 (秩). 比如, 一个二维数组, 其维度表示”行数”和”列数”.</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">print(a.shape)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(2,3)</span><br></pre></td></tr></table></figure><p>调整数组大小</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]) </span><br><span class="line">a.shape = (<span class="number">3</span>,<span class="number">2</span>)  </span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[1 2]</span><br><span class="line"> [3 4]</span><br><span class="line"> [5 6]]</span><br></pre></td></tr></table></figure><p><strong>[例 3.3] 使用 ndarray.size 来获取数组中的元素个数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]) </span><br><span class="line">print(a.size)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="Topic-4-Array-Creation"><a href="#Topic-4-Array-Creation" class="headerlink" title="Topic 4 Array Creation"></a>Topic 4 Array Creation</h2><p>ndarray 数组除了可以使用底层 ndarray 构造器来创建外, 也可以通过以下几种方式来创建.</p><h3 id="4-1-numpy-empty"><a href="#4-1-numpy-empty" class="headerlink" title="4.1 numpy.empty"></a>4.1 numpy.empty</h3><p>numpy.empty 方法用来创建一个指定形状 (shape), 数据类型 (dtype) 且未初始化(随机值)的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">numpy.empty(shape, dtype=float64, order=<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># shape: 数组形状, 可以是 list 也可以是 tuple</span></span><br><span class="line"><span class="comment"># dtype: 数据类型, 默认为 float64</span></span><br><span class="line"><span class="comment"># order: 有&quot;C&quot;和&quot;F&quot;两个选项,分别代表, 行优先和列优先, 在计算机内存中的存储元素的顺序.</span></span><br></pre></td></tr></table></figure><p><strong>[例 4.1]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.empty([<span class="number">3</span>,<span class="number">3</span>],dtype=np.int8)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[  0   0   0]</span><br><span class="line"> [  0   0   0]</span><br><span class="line"> [  0 -80   0]]</span><br></pre></td></tr></table></figure><h3 id="4-2-numpy-zeros"><a href="#4-2-numpy-zeros" class="headerlink" title="4.2 numpy.zeros"></a>4.2 numpy.zeros</h3><p>创建指定大小的数组, 数组元素以 0 来填充:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.zeros(shape, dtype=float64, order=<span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>[例 4.2]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.zeros([<span class="number">3</span>,<span class="number">3</span>], dtype=<span class="string">&#x27;f8&#x27;</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[0. 0. 0.]</span><br><span class="line"> [0. 0. 0.]</span><br><span class="line"> [0. 0. 0.]]</span><br></pre></td></tr></table></figure><h3 id="4-3-numpy-ones"><a href="#4-3-numpy-ones" class="headerlink" title="4.3 numpy.ones"></a>4.3 numpy.ones</h3><p>创建指定形状的数组, 数组元素以 1 来填充:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.ones(shape, dtype=float64, order=<span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>[例 4.3]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.ones([<span class="number">3</span>,<span class="number">3</span>], dtype=<span class="string">&#x27;i2&#x27;</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[1 1 1]</span><br><span class="line"> [1 1 1]</span><br><span class="line"> [1 1 1]]</span><br></pre></td></tr></table></figure><h3 id="4-4-numpy-eye"><a href="#4-4-numpy-eye" class="headerlink" title="4.4 numpy.eye"></a>4.4 numpy.eye</h3><p>创建单位矩阵</p><p><strong>[例 4.4]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.eye(<span class="number">5</span>, dtype=<span class="string">&#x27;i8&#x27;</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[1 0 0 0 0]</span><br><span class="line"> [0 1 0 0 0]</span><br><span class="line"> [0 0 1 0 0]</span><br><span class="line"> [0 0 0 1 0]</span><br><span class="line"> [0 0 0 0 1]]</span><br></pre></td></tr></table></figure><h3 id="4-5-numpy-random-randn"><a href="#4-5-numpy-random-randn" class="headerlink" title="4.5 numpy.random.randn"></a>4.5 numpy.random.randn</h3><p>创建标准正态分布随机数组:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.randn(d0, d1, d2, ...)</span><br></pre></td></tr></table></figure><p><strong>[例 4.5]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.random.randn(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[-1.49392311  0.88590821 -0.44375056]</span><br><span class="line"> [-0.19250296 -0.72078554  0.65790911]</span><br><span class="line"> [-0.03507985 -0.2863142  -0.73509595]]</span><br></pre></td></tr></table></figure><h3 id="4-6-numpy-random-rand"><a href="#4-6-numpy-random-rand" class="headerlink" title="4.6 numpy.random.rand"></a>4.6 numpy.random.rand</h3><p>创建元素位于 [0, 1) 的随机数组</p><p><strong>[例 4.6]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.random.rand(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[0.06404836 0.47933279 0.7514547 ]</span><br><span class="line"> [0.51344134 0.36646154 0.68031114]</span><br><span class="line"> [0.31175219 0.53322371 0.26923007]]</span><br></pre></td></tr></table></figure><h3 id="4-7-numpy-random-randint"><a href="#4-7-numpy-random-randint" class="headerlink" title="4.7 numpy.random.randint"></a>4.7 numpy.random.randint</h3><p>利用 <code>randint(low, high, size)</code> 创建一个整数型指定范围在 [low, high] 之间的数组.</p><p><strong>[例 4.7]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.random.randint(<span class="number">100</span>,<span class="number">200</span>,[<span class="number">3</span>,<span class="number">3</span>])</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[121 102 170]</span><br><span class="line"> [104 166 144]</span><br><span class="line"> [120 172 129]]</span><br></pre></td></tr></table></figure><h3 id="4-8-numpy-asarray"><a href="#4-8-numpy-asarray" class="headerlink" title="4.8 numpy.asarray"></a>4.8 numpy.asarray</h3><p>numpy.asarray 类似 numpy.array, 但 numpy.asarray 参数只有三个, 比 numpy.array 少两个.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">numpy.asarray(<span class="built_in">object</span>, dtype=<span class="literal">None</span>, order=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># object: 可以是列表, 列表的元组, 元组, 元组的元组, 元组的列表和多维数组</span></span><br><span class="line"><span class="comment"># dtype: 数据类型</span></span><br><span class="line"><span class="comment"># order: 可选, 有&quot;C&quot;和&quot;F&quot;两个选项,分别代表, 行优先和列优先, 在计算机内存中的存储元素的顺序.</span></span><br></pre></td></tr></table></figure><p><strong>[例 4.8]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a = np.asarray(x, dtype=<span class="string">&#x27;f8&#x27;</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1. 2. 3.]</span><br></pre></td></tr></table></figure><h3 id="4-9-numpy-frombuffer"><a href="#4-9-numpy-frombuffer" class="headerlink" title="4.9 numpy.frombuffer"></a>4.9 numpy.frombuffer</h3><p>numpy.frombuffer 接受 buffer 输入参数, 以流的形式读入转化成 ndarray 对象.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">numpy.frombuffer(buffer, dtype=float64, count=-<span class="number">1</span>, offset=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># buffer: 可以是任意对象, 以流的形式读入.</span></span><br><span class="line"><span class="comment"># dtype: 返回数组的数据类型</span></span><br><span class="line"><span class="comment"># count: 读取的数据数量, 默认为-1, 读取所有数据.</span></span><br><span class="line"><span class="comment"># offset: 读取初始位置, 默认为 0.</span></span><br></pre></td></tr></table></figure><p><strong>[例 4.9]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">s = <span class="string">b&#x27;Hello World&#x27;</span></span><br><span class="line">a = np.frombuffer(s, dtype=<span class="string">&#x27;S1&#x27;</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[b&#39;H&#39; b&#39;e&#39; b&#39;l&#39; b&#39;l&#39; b&#39;o&#39; b&#39; &#39; b&#39;W&#39; b&#39;o&#39; b&#39;r&#39; b&#39;l&#39; b&#39;d&#39;]</span><br></pre></td></tr></table></figure><h3 id="4-10-numpy-fromiter"><a href="#4-10-numpy-fromiter" class="headerlink" title="4.10 numpy.fromiter"></a>4.10 numpy.fromiter</h3><p>numpy.fromiter 方法从可迭代对象中建立 ndarray 对象, 返回一维数组.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">numpy.fromiter(iterable, dtype, count=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># iterable: 可迭代对象</span></span><br><span class="line"><span class="comment"># dtype: 返回数组的数据类型</span></span><br><span class="line"><span class="comment"># count: 读取的数据数量, 默认为-1, 读取所有数据</span></span><br></pre></td></tr></table></figure><p><strong>[例 4.10]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">lt = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line">itr = <span class="built_in">iter</span>(lt)</span><br><span class="line"></span><br><span class="line">a = np.fromiter(itr, dtype=<span class="string">&#x27;i4&#x27;</span>, count=-<span class="number">1</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0 1 2 3 4]</span><br></pre></td></tr></table></figure><h3 id="4-11-numpy-arange"><a href="#4-11-numpy-arange" class="headerlink" title="4.11 numpy.arange"></a>4.11 numpy.arange</h3><p>使用 arange 函数创建数值范围并返回 ndarray 对象, 函数格式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">numpy.arange(start, stop, step, dtype)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># start: 起始值, 默认为 0</span></span><br><span class="line"><span class="comment"># stop: 终止值 (不包含)</span></span><br><span class="line"><span class="comment"># step: 步长, 默认为 1</span></span><br><span class="line"><span class="comment"># dtype: 指定数据类型</span></span><br></pre></td></tr></table></figure><p><strong>[例 4.11]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">5</span>, dtype=<span class="string">&#x27;f8&#x27;</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0.  1.  2.  3.  4.]</span><br></pre></td></tr></table></figure><h3 id="4-12-numpy-linspace"><a href="#4-12-numpy-linspace" class="headerlink" title="4.12 numpy.linspace"></a>4.12 numpy.linspace</h3><p>numpy.linspace 函数用于创建一个一维数组, 数组是一个等差数列构成的, 格式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">numpy.linspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, retstep=<span class="literal">False</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># start: 序列的起始值</span></span><br><span class="line"><span class="comment"># stop: 序列的终止值, 如果endpoint为true, 该值包含于数列中</span></span><br><span class="line"><span class="comment"># num: 要生成的等步长的样本数量, 默认为50</span></span><br><span class="line"><span class="comment"># endpoint: 该值为 true 时, 数列中包含stop值, 反之不包含, 默认是True</span></span><br><span class="line"><span class="comment"># retstep: 如果为 True 时, 生成的数组中会显示间距, 反之不显示.</span></span><br><span class="line"><span class="comment"># dtype: 数据类型</span></span><br></pre></td></tr></table></figure><p><strong>[例 4.12]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.linspace(<span class="number">0</span>,<span class="number">100</span>,<span class="number">21</span>,retstep=<span class="literal">True</span>,dtype=<span class="string">&#x27;f8&#x27;</span>)</span><br><span class="line">print(a)</span><br><span class="line"><span class="built_in">type</span>(a)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(array([  0.,   5.,  10.,  15.,  20.,  25.,  30.,  35.,  40.,  45.,  50.,</span><br><span class="line">        55.,  60.,  65.,  70.,  75.,  80.,  85.,  90.,  95., 100.]), 5.0)</span><br><span class="line">&lt;class &#39;tuple&#39;&gt;</span><br></pre></td></tr></table></figure><p>我们也可以使用 reshape 来改变数组维度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.linspace(<span class="number">0</span>,<span class="number">100</span>,<span class="number">21</span>,retstep=<span class="literal">False</span>,dtype=<span class="string">&#x27;f8&#x27;</span>)</span><br><span class="line">b = a.reshape(<span class="number">3</span>,<span class="number">7</span>)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[  0.   5.  10.  15.  20.  25.  30.]</span><br><span class="line"> [ 35.  40.  45.  50.  55.  60.  65.]</span><br><span class="line"> [ 70.  75.  80.  85.  90.  95. 100.]]</span><br></pre></td></tr></table></figure><h3 id="4-13-numpy-logspace"><a href="#4-13-numpy-logspace" class="headerlink" title="4.13 numpy.logspace"></a>4.13 numpy.logspace</h3><p>numpy.logspace 函数用于创建一个数组中元素取对数后均匀分布的数组, 格式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">numpy.logspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, base=<span class="number">10.0</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># start: 序列的起始值为 base^start</span></span><br><span class="line"><span class="comment"># stop: 序列的终止值为 base^stop (若 endpoint=True 的情况)</span></span><br><span class="line"><span class="comment"># num: 要生成的等步长的样本数量, 默认为 50</span></span><br><span class="line"><span class="comment"># endpoint: 是否包含 base^stop</span></span><br><span class="line"><span class="comment"># base: 对数 log 的底数</span></span><br><span class="line"><span class="comment"># dtype: 数据类型</span></span><br></pre></td></tr></table></figure><p>注意, <code>numpy.logspace</code> 代码等效于代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.linspace(start,stop, num=num, base=base, endpoint=<span class="literal">True</span>)</span><br><span class="line">result = np.power(a, base)</span><br></pre></td></tr></table></figure><p><strong>[例 4.13]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.logspace(<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,base=<span class="number">2</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[2.         2.16011948 2.33305808 2.5198421  2.72158    2.93946898</span><br><span class="line"> 3.1748021  3.42897593 3.70349885 4.        ]</span><br></pre></td></tr></table></figure><h2 id="Topic-5-Slice-and-Index"><a href="#Topic-5-Slice-and-Index" class="headerlink" title="Topic 5 Slice and Index"></a>Topic 5 Slice and Index</h2><h3 id="5-1-Slice"><a href="#5-1-Slice" class="headerlink" title="5.1 Slice"></a>5.1 Slice</h3><p>ndarray对象的内容可以通过索引或切片来访问和修改, 与 Python 中 list 的切片操作一样. ndarray 数组可以基于 0 - n 的下标进行索引, 切片对象可以通过内置的 slice 函数, 并设置 start, stop 及 step 参数进行, 从原数组中切割出一个新数组. </p><p><strong>[例 5.1]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line">s = <span class="built_in">slice</span>(<span class="number">2</span>,<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">print(a[s])</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2 4 6]</span><br></pre></td></tr></table></figure><p><strong>[例 5.2]</strong></p><p>我们也可以通过冒号分隔切片参数 <strong>start:stop:step</strong> 来进行切片操作:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line">b = a[<span class="number">2</span>:<span class="number">7</span>:<span class="number">2</span>]</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2 4 6]</span><br></pre></td></tr></table></figure><p><strong>[例 5.3]</strong></p><p>同样我们可以提取单个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line">b = a[<span class="number">2</span>]</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>[例 5.4]</strong></p><p>多维数组也同样适用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;从数组索引 a[1:] 处开始切割&#x27;</span>) <span class="comment"># 还记得之前我们讲的轴的概念吗?</span></span><br><span class="line">print(a[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[1 2 3]</span><br><span class="line"> [3 4 5]</span><br><span class="line"> [4 5 6]]</span><br><span class="line">从数组索引 a[1:] 处开始切割</span><br><span class="line">[[3 4 5]</span><br><span class="line"> [4 5 6]]</span><br></pre></td></tr></table></figure><p><strong>[例 5.5]</strong></p><p>在多维数组的切片中, 使用 <code>,</code> 区分维数.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">12</span>)</span><br><span class="line">a.shape = <span class="number">3</span>,<span class="number">4</span></span><br><span class="line">print(a)</span><br><span class="line">print(a[<span class="number">0</span>:<span class="number">2</span>,<span class="number">1</span>:<span class="number">3</span>]) <span class="comment"># 第1,2 行 和 第 2,3 列</span></span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[ 0  1  2  3]</span><br><span class="line"> [ 4  5  6  7]</span><br><span class="line"> [ 8  9 10 11]]</span><br><span class="line">[[1 2]</span><br><span class="line"> [5 6]]</span><br></pre></td></tr></table></figure><h3 id="5-2-Index"><a href="#5-2-Index" class="headerlink" title="5.2 Index"></a>5.2 Index</h3><p>NumPy 比一般的 Python 序列提供更多的索引方式, 除了之前看到的用整数和切片的索引外, 数组可以由整数数组索引、布尔索引及花式索引.</p><h4 id="5-2-1-Array-Indexing"><a href="#5-2-1-Array-Indexing" class="headerlink" title="5.2.1 Array Indexing"></a>5.2.1 Array Indexing</h4><p><strong>[例 5.6]</strong></p><p>在多维数组中, 非连续索引切片:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">6</span>)</span><br><span class="line">b = np.arange(<span class="number">0</span>,<span class="number">25</span>)</span><br><span class="line">b.shape(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片向量既可以是 ndarrat 也可以是 list</span></span><br><span class="line">r = np.array([<span class="number">0</span>,<span class="number">1</span>,<span class="number">4</span>])   <span class="comment"># r = [0,1,4]</span></span><br><span class="line">c = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]<span class="comment"># c = np.array([1,2,4])</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;a:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;a_slice:\n&#x27;</span>,a[r])</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;b:\n&#x27;</span>,b)</span><br><span class="line">print(<span class="string">&#x27;b_slice:\n&#x27;</span>,b[r,:][:,c])</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a:</span><br><span class="line"> [0 1 2 3 4 5]</span><br><span class="line">a_slice:</span><br><span class="line"> [0 1 4]</span><br><span class="line">b:</span><br><span class="line"> [[ 0  1  2  3  4]</span><br><span class="line"> [ 5  6  7  8  9]</span><br><span class="line"> [10 11 12 13 14]</span><br><span class="line"> [15 16 17 18 19]</span><br><span class="line"> [20 21 22 23 24]]</span><br><span class="line">b_slice:</span><br><span class="line"> [[ 1  2  4]</span><br><span class="line"> [ 6  7  9]</span><br><span class="line"> [21 22 24]]</span><br></pre></td></tr></table></figure><p><strong>[例 5.7]</strong></p><p>获取数组中(0,0), (1,1) 和 (2,0)位置处的元素.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">y = x[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1 4 5]</span><br></pre></td></tr></table></figure><p><strong>[例 5.8]</strong> </p><p>获取了 4X3 数组中的四个角的元素. 行索引是 [0,0] 和 [3,3], 而列索引是 [0,2] 和 [0,2].</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]])</span><br><span class="line">print(<span class="string">&#x27;我们的数组是:\n&#x27;</span>,x)</span><br><span class="line">rows = np.array([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">3</span>]])</span><br><span class="line">cols = np.array([[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>]])</span><br><span class="line">y = x[rows,cols]</span><br><span class="line">print(<span class="string">&#x27;这个数组的四个角元素是:\n&#x27;</span>,y)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是:</span><br><span class="line"> [[ 0  1  2]</span><br><span class="line"> [ 3  4  5]</span><br><span class="line"> [ 6  7  8]</span><br><span class="line"> [ 9 10 11]]</span><br><span class="line"> </span><br><span class="line">这个数组的四个角元素是:</span><br><span class="line"> [[ 0  2]</span><br><span class="line"> [ 9 11]]</span><br></pre></td></tr></table></figure><h4 id="5-2-2-Bool-Indexing"><a href="#5-2-2-Bool-Indexing" class="headerlink" title="5.2.2 Bool Indexing"></a>5.2.2 Bool Indexing</h4><p>我们可以通过一个布尔数组来索引目标数组. 布尔索引通过布尔运算 (如: 比较运算符) 来获取符合指定条件的元素的数组.</p><p><strong>[例 5.9]</strong></p><p>获取大于 5 的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]])</span><br><span class="line">print(<span class="string">&#x27;我们的数组是:\n&#x27;</span>,x)</span><br><span class="line">y = x[x&gt;<span class="number">5</span>]</span><br><span class="line">print(<span class="string">&#x27;大于 5 的元素是:\n&#x27;</span>,y)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是:</span><br><span class="line"> [[ 0  1  2]</span><br><span class="line"> [ 3  4  5]</span><br><span class="line"> [ 6  7  8]</span><br><span class="line"> [ 9 10 11]]</span><br><span class="line">大于 5 的元素是:</span><br><span class="line"> [ 6  7  8  9 10 11]</span><br></pre></td></tr></table></figure><p><strong>[例 5.10]</strong></p><p>使用 <code>~</code> (取补运算符) 来过滤 NaN</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([np.nan,<span class="number">1</span>,<span class="number">2</span>,np.nan,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">b = a[~np.isnan(a)]</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1. 2. 3. 4. 5.]</span><br></pre></td></tr></table></figure><p><strong>[例 5.11]</strong></p><p>从数组中过滤掉非复数元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>+<span class="number">6j</span>,<span class="number">5</span>,<span class="number">3.5</span>+<span class="number">5j</span>])</span><br><span class="line">b = a[np.iscomplex(a)]</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2. +6.j 3.5+5.j]</span><br></pre></td></tr></table></figure><h4 id="5-2-3-Fancy-Indexing"><a href="#5-2-3-Fancy-Indexing" class="headerlink" title="5.2.3 Fancy Indexing"></a>5.2.3 Fancy Indexing</h4><p>花式索引指的是利用整数数组进行索引. 花式索引根据索引数组的值作为目标数组的某个轴的下标来取值. 对于使用一维整型数组作为索引, 如果目标是一维数组, 那么索引的结果就是对应位置的元素; 如果目标是二维数组, 那么就是对应下标的行.</p><p>花式索引跟切片不一样, 它总是将数据复制到新数组中.</p><p><strong>[例 5.12]</strong></p><p>传入顺序索引数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">32</span>).reshape(<span class="number">8</span>,<span class="number">4</span>)</span><br><span class="line">y = x[[<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>]]</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[16 17 18 19]</span><br><span class="line"> [ 8  9 10 11]</span><br><span class="line"> [ 4  5  6  7]</span><br><span class="line"> [28 29 30 31]]</span><br></pre></td></tr></table></figure><p><strong>[例 5.13]</strong></p><p>传入倒序索引数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">32</span>).reshape(<span class="number">8</span>,<span class="number">4</span>)</span><br><span class="line">y = x[[-<span class="number">4</span>,-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">7</span>]]</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[16 17 18 19]</span><br><span class="line"> [24 25 26 27]</span><br><span class="line"> [28 29 30 31]</span><br><span class="line"> [ 4  5  6  7]]</span><br></pre></td></tr></table></figure><p><strong>[例 5.14]</strong></p><p>传入多个索引数组, 使用 <code>np.ix_</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">32</span>).reshape(<span class="number">8</span>,<span class="number">4</span>)</span><br><span class="line">y = x[np.ix_([<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>])]</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[ 4  7  5  6]</span><br><span class="line"> [20 23 21 22]</span><br><span class="line"> [28 31 29 30]</span><br><span class="line"> [ 8 11  9 10]]</span><br></pre></td></tr></table></figure><blockquote><p>  <strong>注:</strong></p><p>  x[np.ix_([1,5,7,2],[0,3,1,2])]这句话会输出一个4*4的矩阵, 其中的元素分别是:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x[1,0] x[1,3] x[1,1] x[1,2]</span><br><span class="line">x[5,0] x[5,3] x[5,1] x[5,2]</span><br><span class="line">x[7,0] x[7,3] x[7,1] x[7,2]</span><br><span class="line">x[2,0] x[2,3] x[2,1] x[2,2]</span><br></pre></td></tr></table></figure><p>  就是说, 如果 np.ix_ 中输入两个列表, 则第一个列表存的是待提取元素的行标, 第二个列表存的是待提取元素的列标, 第一个列表中的每个元素都会遍历第二个列表中的每个值, 构成新矩阵的一行元素.</p></blockquote><h2 id="Topic-6-Broadcast"><a href="#Topic-6-Broadcast" class="headerlink" title="Topic 6 Broadcast"></a>Topic 6 Broadcast</h2><p>广播 (Broadcast) 是 numpy 对不同形状 (shape )的数组进行数值计算的方式, 对数组的算术运算通常在相应的元素上进行. </p><p>如果两个数组 a 和 b 形状相同, 即满足 <strong>a.shape == b.shape</strong>, 那么 a*b 的结果就是 a 与 b 数组对应位相乘. 这要求维数相同, 且各维度的长度相同.</p><p><strong>[例 6.1]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">b = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>])</span><br><span class="line">c = a*b</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 10  40  90 160]</span><br></pre></td></tr></table></figure><p><strong>[例 6.2]</strong></p><p>当运算中的 2 个数组的形状不同时, numpy 将自动触发广播机制. 如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">             [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>],</span><br><span class="line">             [<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>],</span><br><span class="line">             [<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>]])</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">print(a+b)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[ 1  2  3]</span><br><span class="line"> [11 12 13]</span><br><span class="line"> [21 22 23]</span><br><span class="line"> [31 32 33]]</span><br></pre></td></tr></table></figure><blockquote><p>  <strong>注:</strong></p><p>  4x3 的二维数组与长为 3 的一维数组相加, 等效于把数组 b 在二维上重复 4 次再运算:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>],</span><br><span class="line">            [<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>],</span><br><span class="line">            [<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>]])</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">c = np.tile(b,(<span class="number">4</span>,<span class="number">1</span>)) <span class="comment"># np.ones((2,3)) 等效于 np.tile(1., (2,3))</span></span><br><span class="line">print(a+c)</span><br></pre></td></tr></table></figure><p>  输出结果是:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[ 1  2  3]</span><br><span class="line">[11 12 13]</span><br><span class="line">[21 22 23]</span><br><span class="line">[31 32 33]]</span><br></pre></td></tr></table></figure><p>可以广播的几种情况:</p></blockquote><ol><li>两个数组各维度大小从后往前比对均一致</li></ol><p>看个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">A = np.zeros((<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">B = np.zeros((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print((A+B).shape) <span class="comment"># 输出 (2, 5, 3, 4)</span></span><br><span class="line"></span><br><span class="line">A = np.zeros((<span class="number">4</span>))</span><br><span class="line">B = np.zeros((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print((A+B).shape) <span class="comment"># 输出(3,4)</span></span><br></pre></td></tr></table></figure><p>举个反例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">A = np.zeros((<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">B = np.zeros((<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">print((A+B).shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这将会报错:</span></span><br><span class="line"><span class="comment"># ValueError: operands could not be broadcast together with shapes (2,5,3,4) (2,4)</span></span><br></pre></td></tr></table></figure><ol><li>两个数组存在一些维度大小不相等时, 有一个数组的该不相等维度大小为1</li></ol><p>这是对上面那条规则的补充，虽然存在多个维大小不一致，但是只要不相等的那些维有一个数组的该大小是1 就可以.</p><p>看个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.zeros((<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">B = np.zeros((<span class="number">3</span>,<span class="number">1</span>))</span><br><span class="line">print((A+B).shape) <span class="comment"># 输出：(2, 5, 3, 4)</span></span><br><span class="line"></span><br><span class="line">A = np.zeros((<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">B = np.zeros((<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>))</span><br><span class="line">print((A+B).shape) <span class="comment"># 输出：(2, 5, 3, 4)</span></span><br><span class="line"></span><br><span class="line">A = np.zeros((<span class="number">1</span>))</span><br><span class="line">B = np.zeros((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print((A+B).shape) <span class="comment"># 输出(3,4)</span></span><br></pre></td></tr></table></figure><p>同样看个反例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">A = np.zeros((<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">B = np.zeros((<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">4</span>))</span><br><span class="line">print((A+B).shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这将会报错</span></span><br><span class="line"><span class="comment"># ValueError: operands could not be broadcast together with shapes (2,5,3,4) (2,4,1,4)</span></span><br></pre></td></tr></table></figure><h2 id="Topic-7-Array-Iteration"><a href="#Topic-7-Array-Iteration" class="headerlink" title="Topic 7 Array Iteration"></a>Topic 7 Array Iteration</h2><h3 id="7-1-numpy-nditer"><a href="#7-1-numpy-nditer" class="headerlink" title="7.1 numpy.nditer"></a>7.1 numpy.nditer</h3><p>NumPy 迭代器对象 numpy.nditer 提供了一种灵活访问一个或者多个数组元素的方式.</p><p><strong>[例 7.1]</strong></p><p>使用 arange() 函数创建一个 2X3 数组，并使用 nditer 对它进行迭代.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(<span class="string">&#x27;原始数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;迭代数组元素:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a):</span><br><span class="line">    print(x,end=<span class="string">&#x27;, &#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原始数组:</span><br><span class="line"> [[0 1 2]</span><br><span class="line"> [3 4 5]]</span><br><span class="line"> </span><br><span class="line">迭代数组元素:</span><br><span class="line">0, 1, 2, 3, 4, 5,</span><br></pre></td></tr></table></figure><p><strong>注:</strong> 你如果有一定的编程基础, 我们也可以使用 nested for loop 来进行遍历.</p><p>以上实例不是使用标准 C 或者 Fortran 顺序, <strong>选择的顺序是和数组内存布局一致的</strong>, 这样做是为了提升访问的效率, 默认是行序优先 (row-major order，或者说是 C-order). <strong>这反映了默认情况下只需访问每个元素, 而无需考虑其特定顺序.</strong> 我们可以通过迭代上述数组的转置来看到这一点, 并与以 C 顺序访问数组转置的 copy 方式做对比, 如下:</p><p><strong>[例 7.2]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a.T):</span><br><span class="line">    print(x, end=<span class="string">&#x27;, &#x27;</span>)</span><br><span class="line">    </span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a.T.copy(order=<span class="string">&#x27;C&#x27;</span>)):</span><br><span class="line">    print(x, end=<span class="string">&#x27;, &#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0, 1, 2, 3, 4, 5, </span><br><span class="line"></span><br><span class="line">0, 3, 1, 4, 2, 5, </span><br></pre></td></tr></table></figure><h3 id="7-2-Iteration-Direction"><a href="#7-2-Iteration-Direction" class="headerlink" title="7.2 Iteration Direction"></a>7.2 Iteration Direction</h3><p>我们也可以控制遍历顺序:</p><ul><li><p><code>for x in np.nditer(a, order=&#39;F&#39;)</code> Fortran order，即是列序优先.</p></li><li><p><code>for x in np.nditer(a.T, order=&#39;C&#39;)</code> C order，即是行序优先.</p></li></ul><p><strong>[例 7.3]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>)</span><br><span class="line">a.shape = <span class="number">3</span>,<span class="number">4</span></span><br><span class="line">print(<span class="string">&#x27;原始数组是:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;原始数组的转置是:\n&#x27;</span>,a.T)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;以 C 风格遍历:\n&#x27;</span>,a)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a, order=<span class="string">&#x27;C&#x27;</span>):</span><br><span class="line">    print(x,end=<span class="string">&#x27;, &#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;以 F 风格遍历:\n&#x27;</span>,a)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a, order=<span class="string">&#x27;F&#x27;</span>):</span><br><span class="line">    print(x,end=<span class="string">&#x27;, &#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">原始数组是：</span><br><span class="line">[[ 0  5 10 15]</span><br><span class="line"> [20 25 30 35]</span><br><span class="line"> [40 45 50 55]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">原始数组的转置是：</span><br><span class="line">[[ 0 20 40]</span><br><span class="line"> [ 5 25 45]</span><br><span class="line"> [10 30 50]</span><br><span class="line"> [15 35 55]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">以 C 风格遍历:</span><br><span class="line">[[ 0 20 40]</span><br><span class="line"> [ 5 25 45]</span><br><span class="line"> [10 30 50]</span><br><span class="line"> [15 35 55]]</span><br><span class="line">0, 20, 40, 5, 25, 45, 10, 30, 50, 15, 35, 55, </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以 F 风格遍历:</span><br><span class="line">[[ 0 20 40]</span><br><span class="line"> [ 5 25 45]</span><br><span class="line"> [10 30 50]</span><br><span class="line"> [15 35 55]]</span><br><span class="line">0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55,</span><br></pre></td></tr></table></figure><h3 id="7-3-Modify-Array"><a href="#7-3-Modify-Array" class="headerlink" title="7.3 Modify Array"></a>7.3 Modify Array</h3><p><strong>我们也可以在遍历过程中修改数组中元素的值.</strong> </p><p>nditer 对象有另一个可选参数 op_flags. 默认情况下, nditer 将视待迭代遍历的数组为只读对象 (read-only), 为了在遍历数组的同时, 实现对数组元素值得修改, 必须指定 read-write 或者 write-only 的模式.</p><p><strong>[例 7.4]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>)</span><br><span class="line">a.shape = <span class="number">3</span>,<span class="number">4</span></span><br><span class="line">print(<span class="string">&#x27;原始数组是:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a, op_flags=[<span class="string">&#x27;readwrite&#x27;</span>]):</span><br><span class="line">    x[...] = x*<span class="number">2</span></span><br><span class="line">print(<span class="string">&#x27;修改后的数组是:\n&#x27;</span>,a)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">原始数组是：</span><br><span class="line">[[ 0  5 10 15]</span><br><span class="line"> [20 25 30 35]</span><br><span class="line"> [40 45 50 55]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改后的数组是：</span><br><span class="line">[[  0  10  20  30]</span><br><span class="line"> [ 40  50  60  70]</span><br><span class="line"> [ 80  90 100 110]]</span><br></pre></td></tr></table></figure><h3 id="7-4-Return-New-Array-Through-Iteration"><a href="#7-4-Return-New-Array-Through-Iteration" class="headerlink" title="7.4 Return New Array Through Iteration"></a>7.4 Return New Array Through Iteration</h3><p><strong>我们还可以通过修改 <code>nditer</code> 的 flags 参数来使其返回遍历值产生的新数组:</strong></p><p><strong>[例 7.5]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>)</span><br><span class="line">a.shape = <span class="number">3</span>,<span class="number">4</span></span><br><span class="line">print(<span class="string">&#x27;原始数组是:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;返回新的数组:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a, flags=[<span class="string">&#x27;external_loop&#x27;</span>], order=<span class="string">&#x27;F&#x27;</span>):</span><br><span class="line">    print(x, end=<span class="string">&#x27;, &#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 0 20 40], [ 5 25 45], [10 30 50], [15 35 55],</span><br></pre></td></tr></table></figure><h3 id="7-5-Broadcast-Iteration"><a href="#7-5-Broadcast-Iteration" class="headerlink" title="7.5 Broadcast Iteration"></a>7.5 Broadcast Iteration</h3><p><strong>还有一种是广播迭代</strong></p><p>如果两个数组是可广播的, nditer 组合对象能够同时迭代它们. 假设数组 a 的维度为 3X4, 数组 b 的维度为 1X4, 则使用以下迭代器 (数组 b 被广播到 a 的大小).</p><p><strong>[例 7.6]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>) </span><br><span class="line">a = a.reshape(<span class="number">3</span>,<span class="number">4</span>)  </span><br><span class="line"><span class="built_in">print</span>  (<span class="string">&#x27;第一个数组为:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (a)</span><br><span class="line"><span class="built_in">print</span>  (<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;第二个数组为:&#x27;</span>)</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], dtype=<span class="built_in">int</span>)  </span><br><span class="line"><span class="built_in">print</span> (b)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;修改后的数组为:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> np.nditer([a,b]):  </span><br><span class="line">    print(<span class="string">&quot;%d:%d&quot;</span> % (x,y), end=<span class="string">&quot;, &quot;</span>)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">第一个数组为：</span><br><span class="line">[[ 0  5 10 15]</span><br><span class="line"> [20 25 30 35]</span><br><span class="line"> [40 45 50 55]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二个数组为：</span><br><span class="line">[1 2 3 4]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改后的数组为：</span><br><span class="line">0:1, 5:2, 10:3, 15:4, 20:1, 25:2, 30:3, 35:4, 40:1, 45:2, 50:3, 55:4,</span><br></pre></td></tr></table></figure><h2 id="Topic-8-Array-Operation"><a href="#Topic-8-Array-Operation" class="headerlink" title="Topic 8 Array Operation"></a>Topic 8 Array Operation</h2><h3 id="8-1-Change-Array-Shape"><a href="#8-1-Change-Array-Shape" class="headerlink" title="8.1 Change Array Shape"></a>8.1 Change Array Shape</h3><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>numpy.reshape</code> <code>numpy.ndarray.reshape</code></td><td style="text-align:left">不改变数据的条件下修改形状</td></tr><tr><td style="text-align:left"><code>numpy.ndarray.flat</code></td><td style="text-align:left">数组元素迭代器</td></tr><tr><td style="text-align:left"><code>flatten</code></td><td style="text-align:left">返回一份数组拷贝，对拷贝所做的修改不会影响原始数组</td></tr><tr><td style="text-align:left"><code>ravel</code></td><td style="text-align:left">返回展开数组</td></tr></tbody></table></div><h4 id="8-1-1-numpy-reshape"><a href="#8-1-1-numpy-reshape" class="headerlink" title="8.1.1 numpy.reshape"></a>8.1.1 numpy.reshape</h4><p>numpy.reshape 函数可以在不改变数据的条件下修改形状，格式如下:</p><p><code>numpy.reshape(arr, newshape, order=&#39;C&#39;)</code></p><p><strong>[例 8.1]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">8</span>)</span><br><span class="line">print(<span class="string">&#x27;原始数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">b = np.reshape(a, [<span class="number">4</span>,<span class="number">2</span>], order=<span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;修改后的数组:\n&#x27;</span>,b)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">原始数组:</span><br><span class="line"> [0 1 2 3 4 5 6 7]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">修改后的数组:</span><br><span class="line"> [[0 4]</span><br><span class="line"> [1 5]</span><br><span class="line"> [2 6]</span><br><span class="line"> [3 7]]</span><br></pre></td></tr></table></figure><h4 id="8-1-2-numpy-ndarray-flat"><a href="#8-1-2-numpy-ndarray-flat" class="headerlink" title="8.1.2 numpy.ndarray.flat"></a>8.1.2 numpy.ndarray.flat</h4><p><code>numpy.ndarray.flat</code> 是一个数组元素迭代器, 例子如下:</p><p><strong>[例 8.2]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">print(<span class="string">&#x27;原始数组:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> a:</span><br><span class="line">    print(row)</span><br><span class="line">    </span><br><span class="line">print(<span class="string">&#x27;迭代之后的数组:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> a.flat:</span><br><span class="line">    print(element)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">原始数组：</span><br><span class="line">[0 1 2]</span><br><span class="line">[3 4 5]</span><br><span class="line">[6 7 8]</span><br><span class="line">迭代后的数组：</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h4 id="8-1-3-numpy-ndarray-flatten"><a href="#8-1-3-numpy-ndarray-flatten" class="headerlink" title="8.1.3 numpy.ndarray.flatten"></a>8.1.3 numpy.ndarray.flatten</h4><p>numpy.ndarray.flatten 返回一份数组拷贝, 对拷贝所做的修改不会影响原始数组，格式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ndarray.flatten(order=<span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>[例 8.3]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">print(<span class="string">&#x27;原数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;按行展开的数组 (默认):\n&#x27;</span>,a.flatten())</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;按 F 展开的数组:\n&#x27;</span>,a.flatten(order=<span class="string">&#x27;F&#x27;</span>))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line"> [[0 1 2 3]</span><br><span class="line"> [4 5 6 7]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">按行展开的数组 (默认):</span><br><span class="line"> [0 1 2 3 4 5 6 7]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">按 F 展开的数组:</span><br><span class="line"> [0 4 1 5 2 6 3 7]</span><br></pre></td></tr></table></figure><h4 id="8-1-4-numpy-ravel"><a href="#8-1-4-numpy-ravel" class="headerlink" title="8.1.4 numpy.ravel"></a>8.1.4 numpy.ravel</h4><p>numpy.ravel() 展平的数组元素, 顺序通常是”C风格”, 返回的是数组视图, 修改会影响原始数组. 该函数接收两个参数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.ravel(a, order=<span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>[例 8.4]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;原数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;按行展开的数组 (默认):\n&#x27;</span>,np.ravel(a))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;按 F 展开的数组:\n&#x27;</span>,np.ravel(a,order=<span class="string">&#x27;F&#x27;</span>))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line"> [[0 1 2 3]</span><br><span class="line"> [4 5 6 7]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">按行展开的数组 (默认):</span><br><span class="line"> [0 1 2 3 4 5 6 7]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">按 F 展开的数组:</span><br><span class="line"> [0 4 1 5 2 6 3 7]</span><br></pre></td></tr></table></figure><h3 id="8-2-Concatenate-Array"><a href="#8-2-Concatenate-Array" class="headerlink" title="8.2 Concatenate Array"></a>8.2 Concatenate Array</h3><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>concatenate</code></td><td style="text-align:left">连接沿现有轴的数组序列</td></tr><tr><td style="text-align:left"><code>stack</code></td><td style="text-align:left">沿着新的轴加入一系列数组。</td></tr><tr><td style="text-align:left"><code>hstack</code></td><td style="text-align:left">水平堆叠序列中的数组（列方向）</td></tr><tr><td style="text-align:left"><code>vstack</code></td><td style="text-align:left">竖直堆叠序列中的数组（行方向）</td></tr></tbody></table></div><h4 id="8-2-1-numpy-concatenate"><a href="#8-2-1-numpy-concatenate" class="headerlink" title="8.2.1 numpy.concatenate"></a>8.2.1 numpy.concatenate</h4><p><code>numpy.concatenate</code> 函数用于沿指定轴连接相同形状的两个或多个数组, 格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numpy.concatenate((a1,a2,...),axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># a1, a2, ... 相同类型的数组</span></span><br><span class="line"><span class="comment"># axis: 沿着它连接数组的轴, 默认为 0. 注: 回一下 Topic 3 里面对轴的介绍</span></span><br></pre></td></tr></table></figure><p>我们看一个例子:</p><p><strong>[例 8.5]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">b = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;第一个数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;第二个数组:\n&#x27;</span>,b)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;沿轴 0 连接两个数组:\n&#x27;</span>, np.concatenate((a,b),axis=<span class="number">0</span>))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;沿轴 1 连接两个数组:\n&#x27;</span>, np.concatenate((a,b),axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">第一个数组：</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二个数组：</span><br><span class="line">[[5 6]</span><br><span class="line"> [7 8]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">沿轴 0 连接两个数组：</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]</span><br><span class="line"> [5 6]</span><br><span class="line"> [7 8]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">沿轴 1 连接两个数组：</span><br><span class="line">[[1 2 5 6]</span><br><span class="line"> [3 4 7 8]]</span><br></pre></td></tr></table></figure><h4 id="8-2-2-numpy-stack"><a href="#8-2-2-numpy-stack" class="headerlink" title="8.2.2 numpy.stack"></a>8.2.2 numpy.stack</h4><p>用法和 <code>numpy.concatenate</code> 类似, 但这不是连接, 而是堆叠, 格式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numpy.stack(arrays, axis)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># arrays: 相同形状的数组序列</span></span><br><span class="line"><span class="comment"># axis: 返回数组中的轴，输入数组沿着它来堆叠</span></span><br></pre></td></tr></table></figure><p>看一个例子:</p><p><strong>[例 8.6]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">b = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;第一个数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;第二个数组:\n&#x27;</span>,b)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;沿轴 0 堆叠两个数组:\n&#x27;</span>, np.stack((a,b),axis=<span class="number">0</span>))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;沿轴 1 堆叠两个数组:\n&#x27;</span>, np.stack((a,b),axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">第一个数组：</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二个数组：</span><br><span class="line">[[5 6]</span><br><span class="line"> [7 8]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">沿轴 0 堆叠两个数组:</span><br><span class="line"> [[[1 2]</span><br><span class="line">  [3 4]]</span><br><span class="line"></span><br><span class="line"> [[5 6]</span><br><span class="line">  [7 8]]]</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">沿轴 1 堆叠两个数组:</span><br><span class="line"> [[[1 2]</span><br><span class="line">  [5 6]]</span><br><span class="line"></span><br><span class="line"> [[3 4]</span><br><span class="line">  [7 8]]]</span><br></pre></td></tr></table></figure><h4 id="8-2-3-numpy-hstack"><a href="#8-2-3-numpy-hstack" class="headerlink" title="8.2.3 numpy.hstack"></a>8.2.3 numpy.hstack</h4><p><code>numpy.hstack</code> 是 <code>numpy.stack</code> 函数的变体, 它通过水平堆叠来生成数组.</p><p><strong>[例 8.7]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">b = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;第一个数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;第二个数组:\n&#x27;</span>,b)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;水平堆叠:\n&#x27;</span>,np.hstack((a,b))) <span class="comment"># 接受 tuple 或 list</span></span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">第一个数组：</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二个数组：</span><br><span class="line">[[5 6]</span><br><span class="line"> [7 8]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">水平堆叠:</span><br><span class="line"> [[1 2 5 6]</span><br><span class="line"> [3 4 7 8]]</span><br></pre></td></tr></table></figure><h4 id="8-2-4-numpy-vstack"><a href="#8-2-4-numpy-vstack" class="headerlink" title="8.2.4 numpy.vstack"></a>8.2.4 numpy.vstack</h4><p><code>numpy.vstack</code> 是 <code>numpy.stack</code> 函数的变体, 它通过垂直堆叠来生成数组.</p><p><strong>[例 8.8]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">b = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;第一个数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;第二个数组:\n&#x27;</span>,b)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;竖直堆叠:\n&#x27;</span>,np.vstack((a,b))) <span class="comment"># 接受 tuple 或 list</span></span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第一个数组：</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二个数组：</span><br><span class="line">[[5 6]</span><br><span class="line"> [7 8]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">竖直堆叠:</span><br><span class="line"> [[1 2]</span><br><span class="line"> [3 4]</span><br><span class="line"> [5 6]</span><br><span class="line"> [7 8]]</span><br></pre></td></tr></table></figure><h3 id="8-3-Split-Array"><a href="#8-3-Split-Array" class="headerlink" title="8.3 Split Array"></a>8.3 Split Array</h3><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">数组及操作</th></tr></thead><tbody><tr><td style="text-align:left"><code>split</code></td><td style="text-align:left">将一个数组分割为多个子数组</td></tr><tr><td style="text-align:left"><code>hsplit</code></td><td style="text-align:left">将一个数组水平分割为多个子数组（按列）</td></tr><tr><td style="text-align:left"><code>vsplit</code></td><td style="text-align:left">将一个数组垂直分割为多个子数组（按行）</td></tr></tbody></table></div><h4 id="8-3-1-numpy-split"><a href="#8-3-1-numpy-split" class="headerlink" title="8.3.1 numpy.split"></a>8.3.1 numpy.split</h4><p>numpy.split 函数沿特定的轴将数组分割为子数组, 格式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">numpy.split(arr, indicies_or_sections, axis)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># arr: 待分割的数组</span></span><br><span class="line"><span class="comment"># indicies_or_sections: 如果是一个整数, 就用该数平均切分, 如果是一个数组, 为沿轴切分的位置（左开右闭）</span></span><br><span class="line"><span class="comment"># axis: 沿着哪个维度进行切向，默认为0，横向切分. 为1时，纵向切分.</span></span><br></pre></td></tr></table></figure><p><strong>[例 8.9]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">print(<span class="string">&#x27;第一个数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;横向切分:\n&#x27;</span>,np.split(a,<span class="number">3</span>,axis=<span class="number">0</span>))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;纵向切分:\n&#x27;</span>,np.split(a,<span class="number">3</span>,axis=<span class="number">1</span>))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;传入数组不均匀切分:\n&#x27;</span>,np.split(a,[<span class="number">2</span>,],axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">第一个数组:</span><br><span class="line"> [[0 1 2]</span><br><span class="line"> [3 4 5]</span><br><span class="line"> [6 7 8]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">横向切分:</span><br><span class="line"> [array([[0, 1, 2]]), array([[3, 4, 5]]), array([[6, 7, 8]])]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">纵向切分:</span><br><span class="line"> [array([[0],</span><br><span class="line">       [3],</span><br><span class="line">       [6]]), array([[1],</span><br><span class="line">       [4],</span><br><span class="line">       [7]]), array([[2],</span><br><span class="line">       [5],</span><br><span class="line">       [8]])]</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">传入数组不均匀切分:</span><br><span class="line"> [array([[0, 1],</span><br><span class="line">       [3, 4],</span><br><span class="line">       [6, 7]]), array([[2],</span><br><span class="line">       [5],</span><br><span class="line">       [8]])]</span><br></pre></td></tr></table></figure><h4 id="8-3-2-numpy-hsplit"><a href="#8-3-2-numpy-hsplit" class="headerlink" title="8.3.2 numpy.hsplit"></a>8.3.2 numpy.hsplit</h4><p>numpy.hsplit 函数用于水平分割数组, 通过指定要返回的相同形状的数组数量来拆分原数组.</p><p><strong>[例 8.10]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.floor(<span class="number">10</span> * np.random.random((<span class="number">2</span>, <span class="number">6</span>)))</span><br><span class="line">print(<span class="string">&#x27;原数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;拆分后:\n&#x27;</span>,np.hsplit(a,<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line"> [[1. 1. 8. 7. 4. 3.]</span><br><span class="line"> [2. 7. 0. 4. 8. 6.]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">拆分后:</span><br><span class="line"> [array([[1., 1.],</span><br><span class="line">       [2., 7.]]), array([[8., 7.],</span><br><span class="line">       [0., 4.]]), array([[4., 3.],</span><br><span class="line">       [8., 6.]])]</span><br></pre></td></tr></table></figure><h4 id="8-3-3-numpy-vsplit"><a href="#8-3-3-numpy-vsplit" class="headerlink" title="8.3.3 numpy.vsplit"></a>8.3.3 numpy.vsplit</h4><p><code>numpy.vsplit</code> 沿着垂直轴分割, 其分割方式与hsplit用法相同。</p><p><strong>[例 8.11]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">16</span>).reshape(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">print(<span class="string">&#x27;原数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;拆分后:\n&#x27;</span>,np.vsplit(a,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line"> [[ 0  1  2  3]</span><br><span class="line"> [ 4  5  6  7]</span><br><span class="line"> [ 8  9 10 11]</span><br><span class="line"> [12 13 14 15]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">拆分后:</span><br><span class="line"> [array([[0, 1, 2, 3],</span><br><span class="line">       [4, 5, 6, 7]]), array([[ 8,  9, 10, 11],</span><br><span class="line">       [12, 13, 14, 15]])]</span><br></pre></td></tr></table></figure><h3 id="8-4-Add-and-Delete-Elements-of-Array"><a href="#8-4-Add-and-Delete-Elements-of-Array" class="headerlink" title="8.4 Add and Delete Elements of Array"></a>8.4 Add and Delete Elements of Array</h3><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">元素及描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>append</code></td><td style="text-align:left">将值添加到数组末尾</td></tr><tr><td style="text-align:left"><code>insert</code></td><td style="text-align:left">沿指定轴将值插入到指定下标之前</td></tr><tr><td style="text-align:left"><code>delete</code></td><td style="text-align:left">删掉某个轴的子数组，并返回删除后的新数组</td></tr><tr><td style="text-align:left"><code>unique</code></td><td style="text-align:left">用于移去数组中的重复值</td></tr></tbody></table></div><h4 id="8-4-1-numpy-append"><a href="#8-4-1-numpy-append" class="headerlink" title="8.4.1 numpy.append"></a>8.4.1 numpy.append</h4><p>numpy.append 函数在数组的末尾添加值.  追加操作会分配整个数组, 并把原来的数组复制到新数组中. 此外, 输入数组的维度必须匹配否则将生成ValueError. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">numpy.append(arr, values, axis=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># arr: 原数组</span></span><br><span class="line"><span class="comment"># values: 要向arr添加的值, 需要和arr形状相同 (除了要添加的轴)</span></span><br><span class="line"><span class="comment"># axis: 默认为 None. 当axis无定义时，是横向添加, 返回总是为一维数组! 当axis有定义的时候, 分别为0和1的时候. 当axis有定义的时候, 分别为0和1的时候 (列数要相同). 当axis为1时, 数组是加在右边 (行数要相同).</span></span><br></pre></td></tr></table></figure><p><strong>[例 8.12]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">print(<span class="string">&#x27;原数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;向数组添加元素,不定义 axis:\n&#x27;</span>,np.append(a,[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;沿轴 0 添加元素:\n&#x27;</span>,np.append(a,[[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]],axis=<span class="number">0</span>))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;沿轴 1 添加元素:\n&#x27;</span>,np.append(a,[[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]],axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line"> [[1 2 3]</span><br><span class="line"> [4 5 6]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">向数组添加元素,不定义 axis:</span><br><span class="line"> [1 2 3 4 5 6 7 8 9]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">沿轴 0 添加元素:</span><br><span class="line"> [[1 2 3]</span><br><span class="line"> [4 5 6]</span><br><span class="line"> [7 8 9]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">沿轴 1 添加元素:</span><br><span class="line"> [[1 2 3 5 5 5]</span><br><span class="line"> [4 5 6 7 8 9]]</span><br></pre></td></tr></table></figure><h4 id="8-4-2-numpy-insert"><a href="#8-4-2-numpy-insert" class="headerlink" title="8.4.2 numpy.insert"></a>8.4.2 numpy.insert</h4><p><code>numpy.insert</code> 函数在给定索引之前, 沿给定轴在输入数组中插入值.</p><p>插入函数会返回一个新数组. 此外, 如果未提供轴, 则输入数组会被展开, 格式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">numpy.insert(arr, obj, values, axis)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># arr: 待插入数组</span></span><br><span class="line"><span class="comment"># obj: 插入处的索引值</span></span><br><span class="line"><span class="comment"># values: 要插入的值</span></span><br><span class="line"><span class="comment"># axis: 沿轴插入, 如果未提供, 则待插入数组会被展开</span></span><br></pre></td></tr></table></figure><p><strong>[例 8.13]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">print(<span class="string">&#x27;原数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;未传递 Axis 参数, 在插入之前输入数组会被展开:\n&#x27;</span>, np.insert(a,<span class="number">3</span>,[<span class="number">11</span>,<span class="number">12</span>]))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;传递 Axis 参数, 沿轴 0 广播:\n&#x27;</span>,np.insert(a,<span class="number">1</span>,[<span class="number">11</span>],axis=<span class="number">0</span>))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;传递 Axis 参数, 沿轴 1 广播:\n&#x27;</span>,np.insert(a,<span class="number">1</span>,[<span class="number">11</span>],axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line"> [[1 2]</span><br><span class="line"> [3 4]</span><br><span class="line"> [5 6]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">未传递 Axis 参数, 在插入之前输入数组会被展开:</span><br><span class="line"> [ 1  2  3 11 12  4  5  6]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">传递 Axis 参数, 沿轴 0 广播:</span><br><span class="line"> [[ 1  2]</span><br><span class="line"> [11 11]</span><br><span class="line"> [ 3  4]</span><br><span class="line"> [ 5  6]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">传递 Axis 参数, 沿轴 1 广播:</span><br><span class="line"> [[ 1 11  2]</span><br><span class="line"> [ 3 11  4]</span><br><span class="line"> [ 5 11  6]]</span><br></pre></td></tr></table></figure><h4 id="8-4-3-numpy-delete"><a href="#8-4-3-numpy-delete" class="headerlink" title="8.4.3 numpy.delete"></a>8.4.3 numpy.delete</h4><p><code>numpy.delete</code> 函数返回从输入数组中删除指定子数组的新数组. 与 insert() 函数的情况一样, 如果未提供轴参数, 则输入数组将展开, 格式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">numpy.delete(arr, obj, axis)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># arr: 输入数组</span></span><br><span class="line"><span class="comment"># obj: 整数或者整数数组, 待删除的索引</span></span><br><span class="line"><span class="comment"># axis: 按指定轴删除, 如果未提供, 则输入数组会被展开</span></span><br></pre></td></tr></table></figure><p><strong>[例 8.14]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">print(<span class="string">&#x27;原数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;未传递 Axis 参数, 在插入之前输入数组会被展开:\n&#x27;</span>, np.delete(a,<span class="number">5</span>))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;删除第二行:\n&#x27;</span>, np.delete(a,<span class="number">1</span>,axis=<span class="number">0</span>))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;删除第二列:\n&#x27;</span>, np.delete(a,<span class="number">1</span>,axis=<span class="number">1</span>))</span><br><span class="line">print(<span class="string">&#x27;包含从数组中删除的替代值的切片:\n&#x27;</span>, np.delete(a, np.s_[::<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line"> [[ 0  1  2  3]</span><br><span class="line"> [ 4  5  6  7]</span><br><span class="line"> [ 8  9 10 11]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">未传递 Axis 参数, 在插入之前输入数组会被展开:</span><br><span class="line"> [ 0  1  2  3  4  6  7  8  9 10 11]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">删除第二行:</span><br><span class="line"> [[ 0  1  2  3]</span><br><span class="line"> [ 8  9 10 11]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">删除第二列:</span><br><span class="line"> [[ 0  2  3]</span><br><span class="line"> [ 4  6  7]</span><br><span class="line"> [ 8 10 11]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">包含从数组中删除的替代值的切片:</span><br><span class="line"> [ 1  3  5  7  9 11]</span><br></pre></td></tr></table></figure><h4 id="8-4-4-numpy-unique"><a href="#8-4-4-numpy-unique" class="headerlink" title="8.4.4 numpy.unique"></a>8.4.4 numpy.unique</h4><p>numpy.unique 函数用于去除数组中的重复元素, 用法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">numpy.unique(arr, return_index, return_inverse, return_counts)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># arr: 输入数组，如果不是一维数组则会展开</span></span><br><span class="line"><span class="comment"># return_index: 如果为true, 返回新列表元素在旧列表中的位置 (下标), 并以列表形式存储</span></span><br><span class="line"><span class="comment"># return_inverse: 如果为true, 返回旧列表元素在新列表中的位置 (下标), 并以列表形式储</span></span><br><span class="line"><span class="comment"># return_counts: 如果为true, 返回去重数组中的元素在原数组中的出现次数</span></span><br></pre></td></tr></table></figure><p><strong>[例 8.15]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">9</span>])</span><br><span class="line">print(<span class="string">&#x27;原数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;去重之后的数组:\n&#x27;</span>,np.unique(a))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;新列表元素在旧列表中的下标:&#x27;</span>)</span><br><span class="line">u,indicies = np.unique(a, return_index=<span class="literal">True</span>)</span><br><span class="line">print(indicies)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;旧列表元素在新列表中的下标:&#x27;</span>)</span><br><span class="line">u,indicies = np.unique(a, return_inverse=<span class="literal">True</span>)</span><br><span class="line">print(indicies)</span><br><span class="line">print(<span class="string">&#x27;使用下标重构原数组:\n&#x27;</span>,u[indicies])</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;返回去重元素的重复数量:&#x27;</span>)</span><br><span class="line">u,counts = np.unique(a, return_counts=<span class="literal">True</span>)</span><br><span class="line">print(u)</span><br><span class="line">print(counts)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line"> [5 2 6 2 7 5 6 8 2 9]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">去重之后的数组:</span><br><span class="line"> [2 5 6 7 8 9]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">新列表元素在旧列表中的下标:</span><br><span class="line"> [1 0 2 4 7 9]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">旧列表元素在新列表中的下标:</span><br><span class="line"> [1 0 2 0 3 1 2 4 0 5]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">使用下标重构原数组:</span><br><span class="line"> [5 2 6 2 7 5 6 8 2 9]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">print(&#39;返回去重元素的重复数量:&#39;)</span><br><span class="line"> [2 5 6 7 8 9]</span><br><span class="line"> [3 2 2 1 1 1]</span><br></pre></td></tr></table></figure><h2 id="Topic-9-Math-Functions"><a href="#Topic-9-Math-Functions" class="headerlink" title="Topic 9 Math Functions"></a>Topic 9 Math Functions</h2><h3 id="9-1-Trigonometric-Functions"><a href="#9-1-Trigonometric-Functions" class="headerlink" title="9.1 Trigonometric Functions"></a>9.1 Trigonometric Functions</h3><p>NumPy 提供了标准的三角函数：sin()、cos()、tan().</p><p><strong>[例 9.1]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">0</span>,<span class="number">30</span>,<span class="number">45</span>,<span class="number">60</span>,<span class="number">90</span>])</span><br><span class="line">print(<span class="string">&#x27;不同角度的正弦值:\n&#x27;</span>,np.sin(a*np.pi/<span class="number">180</span>))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;不同角度的余弦值:\n&#x27;</span>,np.cos(a*np.pi/<span class="number">180</span>))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;不同角度的正切值:\n&#x27;</span>,np.tan(a*np.pi/<span class="number">180</span>))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">不同角度的正弦值:</span><br><span class="line"> [0.         0.5        0.70710678 0.8660254  1.        ]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">不同角度的余弦值:</span><br><span class="line"> [1.00000000e+00 8.66025404e-01 7.07106781e-01 5.00000000e-01</span><br><span class="line"> 6.12323400e-17]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">不同角度的正切值:</span><br><span class="line"> [0.00000000e+00 5.77350269e-01 1.00000000e+00 1.73205081e+00</span><br><span class="line"> 1.63312394e+16]</span><br></pre></td></tr></table></figure><p>NumPy 提供了标准的三角函数的反函数: arcsin, arccos, arctan. 就不再举例了.</p><h3 id="9-2-numpy-floor"><a href="#9-2-numpy-floor" class="headerlink" title="9.2 numpy.floor"></a>9.2 numpy.floor</h3><p><code>numpy.floor()</code> 返回小于或者等于指定表达式的最大整数, 即向下取整.</p><p><strong>[例 9.2]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([-<span class="number">1.7</span>,<span class="number">1.5</span>,-<span class="number">0.2</span>,<span class="number">0.6</span>,<span class="number">10</span>])</span><br><span class="line">print(<span class="string">&#x27;原数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;修改后的数组:\n&#x27;</span>,np.floor(a))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line"> [-1.7  1.5 -0.2  0.6 10. ]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">修改后的数组:</span><br><span class="line"> [-2.  1. -1.  0. 10.]</span><br></pre></td></tr></table></figure><h3 id="9-3-numpy-ceil"><a href="#9-3-numpy-ceil" class="headerlink" title="9.3 numpy.ceil"></a>9.3 numpy.ceil</h3><p><code>numpy.ceil()</code> 返回大于或者等于指定表达式的最小整数, 即向上取整.</p><p><strong>[例 9.3]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([-<span class="number">1.7</span>,<span class="number">1.5</span>,-<span class="number">0.2</span>,<span class="number">0.6</span>,<span class="number">10</span>])</span><br><span class="line">print(<span class="string">&#x27;原数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;修改后的数组:\n&#x27;</span>,np.ceil(a))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line"> [-1.7  1.5 -0.2  0.6 10. ]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">修改后的数组:</span><br><span class="line"> [-1.  2. -0.  1. 10.]</span><br></pre></td></tr></table></figure><h3 id="9-4-Arithmatic-Functions"><a href="#9-4-Arithmatic-Functions" class="headerlink" title="9.4 Arithmatic Functions"></a>9.4 Arithmatic Functions</h3><p>NumPy 算术函数包含简单的加减乘除: <strong>add()</strong>, <strong>subtract()</strong>, <strong>multiply()</strong> 和 <strong>divide()</strong>. 需要注意的是数组必须具有相同的形状或符合数组广播规则. 在这里, 我就不举例子了.</p><h3 id="9-5-numpy-reciprocal"><a href="#9-5-numpy-reciprocal" class="headerlink" title="9.5 numpy.reciprocal"></a>9.5 numpy.reciprocal</h3><p><code>numpy.reciprocal()</code> 函数返回参数逐元素的倒数. 如 <strong>1/4</strong> 倒数为 <strong>4/1</strong>.</p><p><strong>[例 9.4]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">0.25</span>, <span class="number">1.33</span>, <span class="number">1</span>, <span class="number">100</span>])</span><br><span class="line">print(<span class="string">&#x27;原数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;渠倒数的数组:\n&#x27;</span>,np.reciprocal(a))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line"> [  0.25   1.33   1.   100.  ]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">渠倒数的数组:</span><br><span class="line"> [4.        0.7518797 1.        0.01     ]</span><br></pre></td></tr></table></figure><h3 id="9-6-numpy-power"><a href="#9-6-numpy-power" class="headerlink" title="9.6 numpy.power"></a>9.6 numpy.power</h3><p><code>numpy.power()</code> 函数将第一个输入数组中的元素作为底数, 计算它与第二个输入数组中相应元素的幂.</p><p><strong>[例 9.5]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>])</span><br><span class="line">print(<span class="string">&#x27;原数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;调用 power 函数(固定的幂):\n&#x27;</span>,np.power(a,<span class="number">2</span>))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;调用 power 函数(多个幂):\n&#x27;</span>,np.power(a,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line"> [  10  100 1000]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">调用 power 函数(固定的幂):</span><br><span class="line"> [    100   10000 1000000]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">调用 power 函数(多个幂):</span><br><span class="line"> [        10      10000 1000000000]</span><br></pre></td></tr></table></figure><h3 id="9-7-numpy-mod"><a href="#9-7-numpy-mod" class="headerlink" title="9.7 numpy.mod"></a>9.7 numpy.mod</h3><p><code>numpy.mod()</code> 计算输入数组中相应元素的相除后的余数. 函数 <code>numpy.remainder()</code> 也产生相同的结果.</p><p><strong>[例 9.6]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>])</span><br><span class="line">b = np.array([<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>])</span><br><span class="line">print(<span class="string">&#x27;第一个数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;第二个数组:\n&#x27;</span>,b)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;调用 mod 函数:\n&#x27;</span>,np.mod(a,b))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;调用 remainder 函数:\n&#x27;</span>,np.remainder(a,b))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">第一个数组：</span><br><span class="line">[10 20 30]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二个数组：</span><br><span class="line">[3 5 7]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">调用 mod 函数：</span><br><span class="line">[1 0 2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">调用 remainder 函数：</span><br><span class="line">[1 0 2]</span><br></pre></td></tr></table></figure><h2 id="Topic-10-Stat-Functions"><a href="#Topic-10-Stat-Functions" class="headerlink" title="Topic 10 Stat Functions"></a>Topic 10 Stat Functions</h2><h3 id="10-1-numpy-amin-amp-numpy-amax"><a href="#10-1-numpy-amin-amp-numpy-amax" class="headerlink" title="10.1 numpy.amin &amp; numpy.amax"></a>10.1 numpy.amin &amp; numpy.amax</h3><ul><li><p><code>numpy.amin(arr, axis=None)</code> 用于计算数组中的元素沿指定轴的最小值. </p></li><li><p><code>numpy.amax(arr, axis=None)</code> 用于计算数组中的元素沿指定轴的最大值. </p></li></ul><p><strong>[例 10.1]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>],[<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>]])</span><br><span class="line">print(<span class="string">&#x27;原数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;调用 amin() 函数且轴数为 0:\n&#x27;</span>,np.amin(a,axis=<span class="number">0</span>))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;调用 amin() 函数且轴数为 1:\n&#x27;</span>,np.amin(a,axis=<span class="number">1</span>))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;调用 amax() 函数且轴数为 0:\n&#x27;</span>,np.amax(a,axis=<span class="number">0</span>))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;调用 amax() 函数且轴数为 1:\n&#x27;</span>,np.amax(a,axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line"> [[3 7 5]</span><br><span class="line"> [8 4 3]</span><br><span class="line"> [2 4 9]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">调用 amin() 函数且轴数为 0:</span><br><span class="line"> [2 4 3]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">调用 amin() 函数且轴数为 1:</span><br><span class="line"> [3 3 2]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">调用 amax() 函数且轴数为 0:</span><br><span class="line"> [8 7 9]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">调用 amax() 函数且轴数为 1:</span><br><span class="line"> [7 8 9]</span><br></pre></td></tr></table></figure><h3 id="10-2-numpy-ptp"><a href="#10-2-numpy-ptp" class="headerlink" title="10.2 numpy.ptp"></a>10.2 numpy.ptp</h3><p><code>numpy.ptp(arr, axis=None)</code> 函数计算数组中元素最大值与最小值的差 (最大值 - 最小值).</p><p><strong>[例 10.2]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>],[<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>]])</span><br><span class="line">print(<span class="string">&#x27;原数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;调用 ptp() 函数且不指定轴数:\n&#x27;</span>,np.ptp(a))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;调用 ptp() 函数且轴数为 0:\n&#x27;</span>,np.ptp(a,axis=<span class="number">0</span>))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;调用 ptp() 函数且轴数为 1:\n&#x27;</span>,np.ptp(a,axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line"> [[3 7 5]</span><br><span class="line"> [8 4 3]</span><br><span class="line"> [2 4 9]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">调用 ptp() 函数且不指定轴数:</span><br><span class="line"> 7</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">调用 ptp() 函数且轴数为 0:</span><br><span class="line"> [6 3 6]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">调用 ptp() 函数且轴数为 1:</span><br><span class="line"> [4 5 7]</span><br></pre></td></tr></table></figure><h3 id="10-3-numpy-percentile"><a href="#10-3-numpy-percentile" class="headerlink" title="10.3 numpy.percentile"></a>10.3 numpy.percentile</h3><p>百分位数是统计中使用的度量, 用法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">numpy.percentile(arr, Q, axis=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># arr: 输入数组</span></span><br><span class="line"><span class="comment"># Q: 百分位, 取值范围在 0 ~ 100 之间</span></span><br><span class="line"><span class="comment"># axis: 指定轴位</span></span><br></pre></td></tr></table></figure><p><strong>[例 10.3]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">10</span>,<span class="number">7</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]])</span><br><span class="line">print(<span class="string">&#x27;原数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;调用 percentile() 函数且不指定轴数:\n&#x27;</span>,np.percentile(a,<span class="number">50</span>))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;调用 percentile() 函数且轴数为 0:\n&#x27;</span>,np.percentile(a,<span class="number">50</span>,axis=<span class="number">0</span>))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;调用 percentile() 函数且轴数为 1:\n&#x27;</span>,np.percentile(a,<span class="number">50</span>,axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line"> [[10  7  4]</span><br><span class="line"> [ 3  2  1]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">调用 percentile() 函数且不指定轴数:</span><br><span class="line"> 3.5</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">调用 percentile() 函数且轴数为 0:</span><br><span class="line"> [6.5 4.5 2.5]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">调用 percentile() 函数且轴数为 1:</span><br><span class="line"> [6.5 4.5 2.5]</span><br></pre></td></tr></table></figure><h3 id="10-4-numpy-mean"><a href="#10-4-numpy-mean" class="headerlink" title="10.4 numpy.mean"></a>10.4 numpy.mean</h3><p><code>numpy.mean(arr, axis=None)</code> 函数返回数组中元素的算术平均值 (权重相等). 如果提供了轴, 则沿其计算.</p><h3 id="10-5-numpy-average"><a href="#10-5-numpy-average" class="headerlink" title="10.5 numpy.average"></a>10.5 numpy.average</h3><p><code>numpy.average()</code> 函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值. 用法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">numpy.average(arr, weights=<span class="literal">None</span>, returned=<span class="literal">False</span>, axis=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># arr: 输入数组</span></span><br><span class="line"><span class="comment"># weights: 平均的权重</span></span><br><span class="line"><span class="comment"># returned: 是否返回权重的和</span></span><br><span class="line"><span class="comment"># axis: 指定轴数</span></span><br></pre></td></tr></table></figure><p><strong>[例 10.4]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">print(<span class="string">&#x27;原数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;调用 average() 函数, 不指定权重:\n&#x27;</span>,np.average(a))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;调用 average() 函数, 指定权重, 并返回权重的和:\n&#x27;</span>,np.average(a, weights=[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],returned=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line"> [1 2 3 4]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">调用 average() 函数, 不指定权重:</span><br><span class="line"> 2.5</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">调用 average() 函数, 指定权重, 并返回权重的和:</span><br><span class="line"> (2.0, 10.0)</span><br></pre></td></tr></table></figure><h3 id="10-6-numpy-std-amp-numpy-var"><a href="#10-6-numpy-std-amp-numpy-var" class="headerlink" title="10.6 numpy.std &amp; numpy.var"></a>10.6 numpy.std &amp; numpy.var</h3><p><code>numpy.std(arr, axis=None) &amp; numpy.var(arr, axis=None)</code> 求标准差和方差</p><p><strong>[例 10.5]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">24</span>).reshape(<span class="number">4</span>,<span class="number">6</span>)</span><br><span class="line">print(<span class="string">&#x27;原数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;求取标准差:\n&#x27;</span>,np.std(a,axis=<span class="number">0</span>))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;求取方差:\n&#x27;</span>,np.var(a,axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line"> [[ 0  1  2  3  4  5]</span><br><span class="line"> [ 6  7  8  9 10 11]</span><br><span class="line"> [12 13 14 15 16 17]</span><br><span class="line"> [18 19 20 21 22 23]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">求取标准差:</span><br><span class="line"> [6.70820393 6.70820393 6.70820393 6.70820393 6.70820393 6.70820393]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">求取方差:</span><br><span class="line"> [45. 45. 45. 45. 45. 45.]</span><br></pre></td></tr></table></figure><h2 id="Topic-11-Search-amp-Condition-Statements"><a href="#Topic-11-Search-amp-Condition-Statements" class="headerlink" title="Topic 11 Search &amp; Condition Statements"></a>Topic 11 Search &amp; Condition Statements</h2><h3 id="11-1-numpy-sort"><a href="#11-1-numpy-sort" class="headerlink" title="11.1 numpy.sort"></a>11.1 numpy.sort</h3><p>Numpy 提供了多种排序的方法. 这些排序函数实现不同的排序算法, 每个排序算法的特征在于执行速度, 最坏情况性能, 所需的工作空间和算法的稳定性. 下表显示了三种排序算法的比较.</p><div class="table-container"><table><thead><tr><th style="text-align:left">种类</th><th style="text-align:left">速度</th><th style="text-align:left">最坏情况</th><th style="text-align:left">工作空间</th><th style="text-align:left">稳定性</th></tr></thead><tbody><tr><td style="text-align:left"><code>quicksort</code>（快速排序）</td><td style="text-align:left">1</td><td style="text-align:left"><code>O(n^2)</code></td><td style="text-align:left">0</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left"><code>mergesort</code>（归并排序）</td><td style="text-align:left">2</td><td style="text-align:left"><code>O(n*log(n))</code></td><td style="text-align:left">~n/2</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left"><code>heapsort</code>（堆排序）</td><td style="text-align:left">3</td><td style="text-align:left"><code>O(n*log(n))</code></td><td style="text-align:left">0</td><td style="text-align:left">否</td></tr></tbody></table></div><p>numpy.sort() 函数返回输入数组的排序副本. 函数用法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">numpy.sort(arr, axis=<span class="number">1</span>, kind=<span class="string">&#x27;quicksort&#x27;</span>, order=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># arr: 待排序数组</span></span><br><span class="line"><span class="comment"># axis: 沿着排序数组的轴, 如果没有指定数组会被展开. axis=0 按列排序，axis=1 按行排序 (默认)</span></span><br><span class="line"><span class="comment"># kind: 默认为快速排序 &#x27;quicksort</span></span><br><span class="line"><span class="comment"># order: 如果数组包含字段，则是要排序的字段</span></span><br></pre></td></tr></table></figure><p><strong>[例 11.1]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">3</span>,<span class="number">7</span>],[<span class="number">9</span>,<span class="number">1</span>]])</span><br><span class="line">print(<span class="string">&#x27;原数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;调用 sort() 函数, 且不指定轴:\n&#x27;</span>,np.sort(a,axis=<span class="literal">None</span>))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;调用 sort() 函数, 并按列排序:\n&#x27;</span>,np.sort(a, axis=<span class="number">0</span>))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;指定数据列名, 然后排序.&#x27;</span>)</span><br><span class="line">dt = np.dtype([(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;S10&#x27;</span>),(<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;i2&#x27;</span>)])</span><br><span class="line">a = np.array([(<span class="string">&#x27;raju&#x27;</span>,<span class="number">21</span>),(<span class="string">&#x27;anil&#x27;</span>,<span class="number">25</span>),(<span class="string">&#x27;ravi&#x27;</span>,<span class="number">17</span>),(<span class="string">&#x27;amar&#x27;</span>,<span class="number">27</span>)],dtype=dt)</span><br><span class="line">print(<span class="string">&#x27;我们的数组是:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;按 name 排序:\n&#x27;</span>,np.sort(a,order=<span class="string">&#x27;name&#x27;</span>))</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">原数组:</span><br><span class="line"> [[3 7]</span><br><span class="line"> [9 1]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">调用 sort() 函数, 且不指定轴:</span><br><span class="line"> [1 3 7 9]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">调用 sort() 函数, 并按列排序:</span><br><span class="line"> [[3 1]</span><br><span class="line"> [9 7]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">指定数据列名, 然后排序.</span><br><span class="line">我们的数组是:</span><br><span class="line"> [(b&#39;raju&#39;, 21) (b&#39;anil&#39;, 25) (b&#39;ravi&#39;, 17) (b&#39;amar&#39;, 27)]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">按 name 排序:</span><br><span class="line"> [(b&#39;amar&#39;, 27) (b&#39;anil&#39;, 25) (b&#39;raju&#39;, 21) (b&#39;ravi&#39;, 17)]</span><br></pre></td></tr></table></figure><h3 id="11-2-numpy-argsort"><a href="#11-2-numpy-argsort" class="headerlink" title="11.2 numpy.argsort"></a>11.2 numpy.argsort</h3><p><code>numpy.argsort()</code> 函数返回的是数组值从小到大的索引值.</p><p><strong>[例 11.2]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]) </span><br><span class="line">print(<span class="string">&#x27;我们的数组是:\n&#x27;</span>,x)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;对 x 调用 argsort() 函数:\n&#x27;</span>,np.argsort(x))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;以排序后的顺序重构原数组:\n&#x27;</span>,x[np.argsort(x)])</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是:</span><br><span class="line"> [3 1 2]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">对 x 调用 argsort() 函数:</span><br><span class="line"> [1 2 0]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">以排序后的顺序重构原数组:</span><br><span class="line"> [1 2 3]</span><br></pre></td></tr></table></figure><h3 id="11-3-numpy-lexsort"><a href="#11-3-numpy-lexsort" class="headerlink" title="11.3 numpy.lexsort()"></a>11.3 numpy.lexsort()</h3><p>numpy.lexsort() 用于对多个序列进行排序. 把它想象成对电子表格进行排序, 每一列代表一个序列, 排序时优先照顾靠后的列.</p><p><strong>[例 11.3]</strong></p><p>录入了四位同学的成绩，按照总分排序，总分相同时语文高的优先.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">math    = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">10</span>)</span><br><span class="line">chinese = (<span class="number">30</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">60</span>)</span><br><span class="line">total   = (<span class="number">40</span>, <span class="number">70</span>, <span class="number">90</span>, <span class="number">70</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将优先级高的项放在后面</span></span><br><span class="line">indicies = np.lexsort((math, chinese, total))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> indicies:</span><br><span class="line">    print(total[i],chinese[i],math[i])</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">40 30 10</span><br><span class="line">70 50 20</span><br><span class="line">70 60 10</span><br><span class="line">90 40 50</span><br></pre></td></tr></table></figure><h3 id="11-4-numpy-argmax-amp-numpy-argmin"><a href="#11-4-numpy-argmax-amp-numpy-argmin" class="headerlink" title="11.4 numpy.argmax() &amp; numpy.argmin()"></a>11.4 numpy.argmax() &amp; numpy.argmin()</h3><p><code>numpy.argmax()</code> 和 <code>numpy.argmin()</code> 函数分别沿给定轴返回最大和最小元素的索引.</p><h3 id="11-5-numpy-nonzero"><a href="#11-5-numpy-nonzero" class="headerlink" title="11.5 numpy.nonzero"></a>11.5 numpy.nonzero</h3><p><code>numpy.nonzero()</code> 函数返回输入数组中非零元素的索引.</p><p><strong>[例 11.4]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">30</span>,<span class="number">40</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">20</span>,<span class="number">10</span>],[<span class="number">50</span>,<span class="number">0</span>,<span class="number">60</span>]])</span><br><span class="line">print(<span class="string">&#x27;我们的数组:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;调用 nonzero() 函数:\n&#x27;</span>,np.nonzero(a))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我们的数组:</span><br><span class="line"> [[30 40  0]</span><br><span class="line"> [ 0 20 10]</span><br><span class="line"> [50  0 60]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">调用 nonzero() 函数:</span><br><span class="line"> (array([0, 0, 1, 1, 2, 2]), array([0, 1, 1, 2, 0, 2]))</span><br><span class="line"></span><br><span class="line"># </span><br><span class="line">得到的是一个长度为2的元组。它的第0个元素是数组a中值不为0的元素的第0轴的下标，第1个元素则是第1轴的下标</span><br></pre></td></tr></table></figure><h3 id="11-6-numpy-where"><a href="#11-6-numpy-where" class="headerlink" title="11.6 numpy.where"></a>11.6 numpy.where</h3><p><code>numpy.where()</code> 函数返回输入数组中满足给定条件的元素的索引.</p><p><strong>[例 11.5]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">print(<span class="string">&#x27;我们的数组是:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;大于 3 的元素的索引是:\n&#x27;</span>,np.where(a&gt;<span class="number">3</span>))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;用这些索引来索取元素:\n&#x27;</span>,a[np.where(a&gt;<span class="number">3</span>)])</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是:</span><br><span class="line"> [[0 1 2]</span><br><span class="line"> [3 4 5]</span><br><span class="line"> [6 7 8]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">大于 3 的元素的索引是:</span><br><span class="line"> (array([1, 1, 2, 2, 2]), array([1, 2, 0, 1, 2]))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">用这些索引来索取元素:</span><br><span class="line"> [4 5 6 7 8]</span><br></pre></td></tr></table></figure><h2 id="Topic-12-Copy-and-View"><a href="#Topic-12-Copy-and-View" class="headerlink" title="Topic 12 Copy and View"></a>Topic 12 Copy and View</h2><p><strong>副本</strong>是一个数据的完整的拷贝, 如果我们对副本进行修改, 它不会影响到原始数据, 物理内存不在同一位置. </p><ul><li>Python 序列的切片操作, 调用deepCopy()函数.</li><li>调用 ndarray 的 copy() 函数产生一个副本.</li></ul><p><strong>视图</strong>是数据的一个别称或引用, 通过该别称或引用亦便可访问、操作原有数据，但原有数据不会产生拷贝. 如果我们对视图进行修改, 它会影响到原始数据, 物理内存在同一位置.</p><ul><li>numpy 的切片操作返回原数据的视图.</li><li>调用 ndarray 的 view() 函数产生一个视图.</li></ul><p><strong>[例 11.1]</strong></p><p>简单的赋值不会创建数组对象的副本. 相反, 它使用原始数组的相同id()来访问它. id()返回 Python 对象的通用标识符, 类似于 C 中的指针此外, 一个数组的任何变化都反映在另一个数组上. 例如, 一个数组的形状改变也会改变另一个数组的形状.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">6</span>)</span><br><span class="line">print(<span class="string">&#x27;我们的数组是:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;调用 id() 函数, 查看 a 的 id:\n&#x27;</span>,<span class="built_in">id</span>(a))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;将 a 赋值给 b:&#x27;</span>)</span><br><span class="line">b = a</span><br><span class="line">print(b)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;调用 id() 函数, 查看 b 的 id:\n&#x27;</span>,<span class="built_in">id</span>(b))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;修改 b 的形状:&#x27;</span>)</span><br><span class="line">b.shape = <span class="number">3</span>,<span class="number">2</span></span><br><span class="line">print(b)</span><br><span class="line">print(<span class="string">&#x27;a 的形状也随之被修改:\n&#x27;</span>,a)</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是:</span><br><span class="line"> [0 1 2 3 4 5]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">调用 id() 函数, 查看 a 的 id:</span><br><span class="line"> 140651199630432</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">将 a 赋值给 b:</span><br><span class="line"> [0 1 2 3 4 5]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">调用 id() 函数, 查看 b 的 id:</span><br><span class="line"> 140651199630432</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">修改 b 的形状:</span><br><span class="line"> [[0 1]</span><br><span class="line"> [2 3]</span><br><span class="line"> [4 5]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">a 的形状也随之被修改:</span><br><span class="line"> [[0 1]</span><br><span class="line"> [2 3]</span><br><span class="line"> [4 5]]</span><br></pre></td></tr></table></figure><h3 id="12-1-View-ShallowCopy"><a href="#12-1-View-ShallowCopy" class="headerlink" title="12.1 View (ShallowCopy)"></a>12.1 View (ShallowCopy)</h3><p><code>ndarray.view()</code> 方会创建一个新的数组对象, 该方法创建的新数组的维数更改不会更改原始数据的维数. 但修改数据还是会跟随改变.</p><p><strong>[例 12.2]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">print(<span class="string">&#x27;我们的数组是:\n&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;创建 a 的视图:&#x27;</span>)</span><br><span class="line">b = a.view()</span><br><span class="line">print(b)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;两个数组的 id 不同.&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;a 的 id:\n&#x27;</span>,<span class="built_in">id</span>(a))</span><br><span class="line">print(<span class="string">&#x27;b 的 id:\n&#x27;</span>,<span class="built_in">id</span>(b))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;修改 b 的形状并不会改变 a 的形状.&#x27;</span>)</span><br><span class="line">b.shape = <span class="number">2</span>,<span class="number">3</span></span><br><span class="line">print(<span class="string">&#x27;b 的形状:\n&#x27;</span>,b)</span><br><span class="line">print(<span class="string">&#x27;a 的形状:\n&#x27;</span>,a)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">我们的数组是:</span><br><span class="line"> [[0 1]</span><br><span class="line"> [2 3]</span><br><span class="line"> [4 5]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">创建 a 的视图:</span><br><span class="line"> [[0 1]</span><br><span class="line"> [2 3]</span><br><span class="line"> [4 5]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">两个数组的 id 不同.</span><br><span class="line">a 的 id:</span><br><span class="line"> 140651199630192</span><br><span class="line">b 的 id:</span><br><span class="line"> 140651199630672</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">修改 b 的形状并不会改变 a 的形状.</span><br><span class="line">b 的形状:</span><br><span class="line"> [[0 1 2]</span><br><span class="line"> [3 4 5]]</span><br><span class="line">a 的形状:</span><br><span class="line"> [[0 1]</span><br><span class="line"> [2 3]</span><br><span class="line"> [4 5]]</span><br></pre></td></tr></table></figure><p>使用<strong>切片</strong>创建视图修改数据会影响到原始数组, 见[例 11.1]</p><h3 id="12-2-Copy-DeepCopy"><a href="#12-2-Copy-DeepCopy" class="headerlink" title="12.2 Copy (DeepCopy)"></a>12.2 Copy (DeepCopy)</h3><p><code>ndarray.copy()</code> 函数创建一个副本. 对副本数据进行修改, 不会影响到原始数据, 它们物理内存不在同一位置.</p><h2 id="Topic-13-Matrix"><a href="#Topic-13-Matrix" class="headerlink" title="Topic 13 Matrix"></a>Topic 13 Matrix</h2><p>Numpy 中包含了一个矩阵库 <code>numpy.matlib</code>, 该模块中的函数返回的是一个矩阵, 而不是 <code>ndarray</code> 对象.</p><h3 id="13-1-Transpose"><a href="#13-1-Transpose" class="headerlink" title="13.1 Transpose"></a>13.1 Transpose</h3><p>Numpy 中除了可以使用 <code>numpy.transpose</code> 函数来对换数组的维度, 还可以使用 <strong>T</strong> 属性. </p><h3 id="13-2-numpy-matlib-empty"><a href="#13-2-numpy-matlib-empty" class="headerlink" title="13.2 numpy.matlib.empty"></a>13.2 numpy.matlib.empty</h3><p><code>matlib.empty()</code> 函数返回一个新的矩阵, 语法格式为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">numpy.matlib.empty(shape, dtype, order)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># shape: 矩阵的形状</span></span><br><span class="line"><span class="comment"># dtype: 数据类型</span></span><br><span class="line"><span class="comment"># order: C (行序优先) 或者 F (列序优先)</span></span><br></pre></td></tr></table></figure><h3 id="13-3-numpy-matlib-zeros"><a href="#13-3-numpy-matlib-zeros" class="headerlink" title="13.3 numpy.matlib.zeros"></a>13.3 numpy.matlib.zeros</h3><p><code>matlib.zeros()</code> 函数创建一个以 0 填充的矩阵.</p><h3 id="13-4-numpy-matlib-ones"><a href="#13-4-numpy-matlib-ones" class="headerlink" title="13.4 numpy.matlib.ones"></a>13.4 numpy.matlib.ones</h3><p><code>matlib.ones()</code> 函数创建一个以 1 填充的矩阵.</p><h3 id="13-5-numpy-matlib-eye"><a href="#13-5-numpy-matlib-eye" class="headerlink" title="13.5 numpy.matlib.eye"></a>13.5 numpy.matlib.eye</h3><p><code>matlib.eye()</code> 函数返回一个对角线元素为 1 的矩阵, 语法格式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">numpy.matlib.eye(n, M, k, dtype)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># n: 返回矩阵的行数</span></span><br><span class="line"><span class="comment"># M: 返回矩阵的列数, 默认为 n</span></span><br><span class="line"><span class="comment"># k: 对角线的索引</span></span><br><span class="line"><span class="comment"># dtype: 数据类型</span></span><br></pre></td></tr></table></figure><p><strong>[例 13.1]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> numpy.matlib   </span><br><span class="line"></span><br><span class="line">print(np.matlib.eye(n=<span class="number">3</span>,M=<span class="number">3</span>,k=<span class="number">0</span>,dtype=<span class="string">&#x27;i2&#x27;</span>))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[1 0 0]</span><br><span class="line"> [0 1 0]</span><br><span class="line"> [0 0 1]]</span><br></pre></td></tr></table></figure><blockquote><p>  注:</p><p>  <code>numpy.matlib</code> is an optional sub-package of <code>numpy</code> that must be imported separately. When you import just <code>numpy</code> without the sub-package <code>matlib</code>, then Python will be looking for <code>.matlib</code> as an attribute of the <code>numpy</code> package. This attribute has not been assigned to <code>numpy</code> without importing numpy.matlib</p></blockquote><h3 id="13-6-numpy-matlib-identity"><a href="#13-6-numpy-matlib-identity" class="headerlink" title="13.6 numpy.matlib.identity"></a>13.6 numpy.matlib.identity</h3><p>返回一个给定大小的单位矩阵, 语法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numpy.matlib.identity(n, dtype)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># n: 单位矩阵的大小</span></span><br><span class="line"><span class="comment"># dtype: 数据的类型</span></span><br></pre></td></tr></table></figure><h3 id="13-7-numpy-matlib-rand"><a href="#13-7-numpy-matlib-rand" class="headerlink" title="13.7 numpy.matlib.rand"></a>13.7 numpy.matlib.rand</h3><p><code>numpy.matlib.rand()</code> 函数创建一个给定大小的矩阵, 数据是随机填充的, 介于 0~1.</p><p><strong>[例 13.2]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> numpy.matlib</span><br><span class="line"></span><br><span class="line">print(np.matlib.rand(<span class="number">3</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[0.23519118 0.02624582 0.04782004]</span><br><span class="line"> [0.17469861 0.62994689 0.21809582]</span><br><span class="line"> [0.26929478 0.938636   0.38530064]]</span><br></pre></td></tr></table></figure><h3 id="13-8-numpy-matrix-amp-numpy-asarray-amp-numpy-asmatrix"><a href="#13-8-numpy-matrix-amp-numpy-asarray-amp-numpy-asmatrix" class="headerlink" title="13.8 numpy.matrix &amp; numpy.asarray &amp; numpy.asmatrix"></a>13.8 numpy.matrix &amp; numpy.asarray &amp; numpy.asmatrix</h3><p>矩阵总是二维的, 而 ndarray 是一个 n 维数组. 两个对象都是可互换的.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy.matlib</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">i = np.matrix(<span class="string">&#x27;1,2;3,4&#x27;</span>)   <span class="comment"># matlab 式写法</span></span><br><span class="line">print(<span class="string">&#x27;使用 np.matrix 创建矩阵:\n&#x27;</span>,i)</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;将矩阵转化为 ndarray:\n&#x27;</span>,np.asarray(i))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;将 ndarray 转换为矩阵:\n&#x27;</span>,np.asmatrix(np.asarray(i)))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">使用 np.matrix 创建矩阵:</span><br><span class="line"> [[1 2]</span><br><span class="line"> [3 4]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">将矩阵转化为 ndarray:</span><br><span class="line"> [[1 2]</span><br><span class="line"> [3 4]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">将 ndarray 转换为矩阵:</span><br><span class="line"> [[1 2]</span><br><span class="line"> [3 4]]</span><br></pre></td></tr></table></figure><h2 id="Topic-14-Linear-Algebra"><a href="#Topic-14-Linear-Algebra" class="headerlink" title="Topic 14 Linear Algebra"></a>Topic 14 Linear Algebra</h2><p>Numpy 提供了线性代数函数库 <strong>linalg</strong>, 该库包含了线性代数所需的所有功能，可以看看下面的说明:</p><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>numpy.dot</code></td><td style="text-align:left">对于一维数组是点积, 对于二维数组是矩阵的乘积</td></tr><tr><td style="text-align:left"><code>numpy.vdot</code></td><td style="text-align:left">无论是一维还是二维数组都是点积</td></tr><tr><td style="text-align:left"><code>numpy.inner</code></td><td style="text-align:left">两个数组的内积, 对于二维矩阵等同于 <code>numpy.dot(a,b.T)</code></td></tr><tr><td style="text-align:left"><code>numpy.matmul</code></td><td style="text-align:left">两个数组的矩阵积</td></tr><tr><td style="text-align:left"><code>numpy.linalg.det</code></td><td style="text-align:left">矩阵的行列式</td></tr><tr><td style="text-align:left"><code>numpy.linalg.solve</code></td><td style="text-align:left">求解线性矩阵方程</td></tr><tr><td style="text-align:left"><code>numpy.linalg.inv</code></td><td style="text-align:left">计算矩阵的乘法逆矩阵</td></tr></tbody></table></div><h3 id="14-1-numpy-dot"><a href="#14-1-numpy-dot" class="headerlink" title="14.1 numpy.dot"></a>14.1 numpy.dot</h3><p><strong>对于一维矩阵</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>])</span><br><span class="line">print(<span class="string">&#x27;对于一维矩阵, numpy.dot() 就是对应元素相乘:\n&#x27;</span>,np.dot(a,b))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于一维矩阵, numpy.dot() 就是对应元素相乘:</span><br><span class="line"> 140</span><br></pre></td></tr></table></figure><p><strong>对于二维矩阵:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]) </span><br><span class="line">b = np.array([[<span class="number">11</span>,<span class="number">12</span>],[<span class="number">13</span>,<span class="number">14</span>]]) </span><br><span class="line">print(<span class="string">&#x27;对于高维矩阵, numpy.dot() 就是矩阵乘法:\n&#x27;</span>,np.dot(a,b))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于高维矩阵, numpy.dot() 就是矩阵乘法:</span><br><span class="line"> [[37 40]</span><br><span class="line"> [85 92]]</span><br></pre></td></tr></table></figure><h3 id="14-2-numpy-vdot"><a href="#14-2-numpy-vdot" class="headerlink" title="14.2 numpy.vdot"></a>14.2 numpy.vdot</h3><p><strong>无论是一维还是二维数组都是点积</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]) </span><br><span class="line">b = np.array([[<span class="number">11</span>,<span class="number">12</span>],[<span class="number">13</span>,<span class="number">14</span>]]) </span><br><span class="line">print(<span class="string">&#x27;numpy.vdot() 就是点积:\n&#x27;</span>,np.vdot(a,b))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numpy.vdot() 就是对应元素相乘:</span><br><span class="line"> 130</span><br></pre></td></tr></table></figure><h3 id="14-3-numpy-inner"><a href="#14-3-numpy-inner" class="headerlink" title="14.3 numpy.inner"></a>14.3 numpy.inner</h3><p><code>numpy.inner()</code> 函数返回一维数组的向量内积. 对于更高的维度，它返回最后一个轴上的和的乘积. 等同于 <code>numpy.dot(a, b.T)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]) </span><br><span class="line">b = np.array([[<span class="number">11</span>,<span class="number">12</span>],[<span class="number">13</span>,<span class="number">14</span>]]) </span><br><span class="line">print(<span class="string">&#x27;numpy.inner() 向量的内积:\n&#x27;</span>,np.inner(a,b))</span><br><span class="line">print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;等同于 numpy.dot(a,b.T):\n&#x27;</span>,np.dot(a,b.T))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">numpy.inner() 向量的内积:</span><br><span class="line"> [[35 41]</span><br><span class="line"> [81 95]]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">等同于 numpy.dot(a,b.T):</span><br><span class="line"> [[35 41]</span><br><span class="line"> [81 95]]</span><br></pre></td></tr></table></figure><h3 id="14-4-numpy-matmul"><a href="#14-4-numpy-matmul" class="headerlink" title="14.4 numpy.matmul"></a>14.4 numpy.matmul</h3><p><code>numpy.matmul</code> 函数返回两个数组的矩阵乘积. 虽然它返回二维数组的正常乘积, 但如果任一参数的维数大于2, 则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> numpy.matlib</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]) </span><br><span class="line">a = np.asmatrix(a)</span><br><span class="line">b = np.array([[<span class="number">11</span>,<span class="number">12</span>],[<span class="number">13</span>,<span class="number">14</span>]]) </span><br><span class="line">b = np.asmatrix(b)</span><br><span class="line"></span><br><span class="line">print(np.matmul(a,b))</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[37 40]</span><br><span class="line"> [85 92]]</span><br></pre></td></tr></table></figure><h3 id="14-5-numpy-linalg-det"><a href="#14-5-numpy-linalg-det" class="headerlink" title="14.5 numpy.linalg.det"></a>14.5 numpy.linalg.det</h3><p>求行列式, 这里暂时就不举例了</p><h3 id="14-6-numpy-linalg-solve"><a href="#14-6-numpy-linalg-solve" class="headerlink" title="14.6 numpy.linalg.solve"></a>14.6 numpy.linalg.solve</h3><p>解线性方程组:</p><p>$x+2y=3$</p><p>$4x+5y=6$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> numpy.matlib</span><br><span class="line"></span><br><span class="line">A = np.matrix(<span class="string">&#x27;1,2;4,5&#x27;</span>)</span><br><span class="line">b = np.matrix(<span class="string">&#x27;3,6&#x27;</span>).T</span><br><span class="line">result = np.linalg.solve(A,b)</span><br><span class="line">print(<span class="string">&#x27;方程组的解为:\n&#x27;</span>,result)</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方程组的解为:</span><br><span class="line"> [[-1.]</span><br><span class="line"> [ 2.]]</span><br></pre></td></tr></table></figure><h3 id="14-7-numpy-linalg-inv"><a href="#14-7-numpy-linalg-inv" class="headerlink" title="14.7 numpy.linalg.inv"></a>14.7 numpy.linalg.inv</h3><p>求逆矩阵, 我暂时不举例子, 对概念不了解可取看我的 MIT Linear Algebra 的笔记.</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra Part 2</title>
      <link href="2020/08/15/MIT-Linear-Algebra-Part-2/"/>
      <url>2020/08/15/MIT-Linear-Algebra-Part-2/</url>
      
        <content type="html"><![CDATA[<p>This is a basic subject on matrix theory and linear algebra. Emphasis is given to topics that will be useful in other disciplines, including systems of equations, vector spaces, determinants, eigenvalues, similarity, and positive definite matrices.</p><h2 id="Lec-16-Orthogonal-Matrices-and-Gram-Schmidt"><a href="#Lec-16-Orthogonal-Matrices-and-Gram-Schmidt" class="headerlink" title="Lec 16 Orthogonal Matrices and Gram-Schmidt"></a>Lec 16 Orthogonal Matrices and Gram-Schmidt</h2><h3 id="16-1-Overview"><a href="#16-1-Overview" class="headerlink" title="16.1 Overview"></a>16.1 Overview</h3><p>这一节主要是承接上节末尾的标准正交向量, 主要关于标准正交向量的性质与优点, 以及将一组普通向量转化为标准正交向量的方法: Gram-Schmidt 正交化.</p><h3 id="16-2-Review-on-Orthonormal-Vectors"><a href="#16-2-Review-on-Orthonormal-Vectors" class="headerlink" title="16.2 Review on Orthonormal Vectors"></a>16.2 Review on Orthonormal Vectors</h3><p>假设 <code>q</code> 是标准正交向量组中的任意向量, 则向量之间相互垂直, 且长度为 1, 这也是为什么叫标准 (normal).</p><p><img src="https://i.loli.net/2020/08/12/XSjm6y2eb3nZp5v.png" alt="image-20200812162243543" style="zoom:15%;" /></p><h3 id="16-3-Orthogonal-Matrix-Q"><a href="#16-3-Orthogonal-Matrix-Q" class="headerlink" title="16.3 Orthogonal Matrix (Q)"></a>16.3 Orthogonal Matrix (Q)</h3><p>我们现在引入一个新的概念: 正交矩阵 Q. Q 是由标准正交向量组中的 $q_1,q_2,…,q_n$ 所组成. 而且正交矩阵还有一个很好的性质.</p><p><img src="https://i.loli.net/2020/08/12/lxwAfnOVU2q13ZS.png" alt="image-20200812162623229" style="zoom:15%;" /></p><p>注意这里的 Q 可以不是方阵, 而当 Q 是方阵时, 其有如下两个性质:</p><ul><li>$Q^TQ=I$</li><li>$Q^T=Q^{-1}$</li></ul><p>我们可以看几个例子, 注意我们一定不要忘了单位化 (标准化) 向量. 即将每个基的单位变成 1.</p><p><img src="https://i.loli.net/2020/08/12/M7X5LSvDKih3CYQ.png" alt="image-20200812162933566" style="zoom:15%;" /></p><p>那么正交矩阵有什么作用呢? 其主要的应用就是<strong>投影矩阵.</strong></p><p>我们在前两节的学习中已经知道投影矩阵的一般形式是: $P=A(A^TA)^{-1}A^T$. 那么当 A 是正交矩阵 Q 时, 投影矩阵很明显等于: $P=QQ^T$. 特别当 Q 为方阵时, 投影矩阵为 $I$.</p><p><img src="https://i.loli.net/2020/08/12/cQ5vnhOeopjfrUE.png" alt="image-20200812163547618" style="zoom:12%;" /></p><p>至于我们之前用的拟合方程, 如果 A = Q 时就可以得以简化!</p><blockquote><p>   $A^TA\hat{x}=A^Tb$</p><p>   $Q^TQ\hat{x}=Q^Tb$</p><p>   $I\hat{x}=Q^Tb$</p><p>   $\hat{x}=Q^Tb$</p></blockquote><p>这样简化之后, 很明显 $\hat{x}$ 中的每个分向量都是 Q 中对应列向量与 b 的点乘结果, 即:</p><blockquote><p>  $\hat{x}_{i}=q^{T}_{i}b$</p></blockquote><p>这个式子的意义就是, 我们已知标准正交基, 那么 b 在第 i 个基上的投影就是 $q^{T}_{i}b$. 很明显, 当我们选择标准正交向量作为基时, 投影矩阵相关公式中的 A 都可以被 Q 替换, 这样很多公式都可以被化简.</p><h3 id="16-4-Gram-Schmidt"><a href="#16-4-Gram-Schmidt" class="headerlink" title="16.4 Gram-Schmidt"></a>16.4 Gram-Schmidt</h3><p>我们还是按照老样子, 从线性无关向量组入手, 将其标准正交化.</p><blockquote><p>  有两个线性无关向量 a, b. 我们试图通过某种过程得到标准正交向量 $q_1,q_2$.</p></blockquote><p><img src="https://i.loli.net/2020/08/12/DU63QfPvzl5hL8Y.png" alt="image-20200812165638078" style="zoom:25%;" /></p><blockquote><p>  我们也可以推广到三维</p></blockquote><p><img src="https://i.loli.net/2020/08/12/AiaMVvDRh9oJmHr.png" alt="image-20200812165713457" style="zoom:15%;" /></p><p>我们通过一个简单的例子去熟悉这个方法. $a=\left|\begin{matrix}1\\1\\1\end{matrix}\right|$, $b=\left|\begin{matrix}1\\0\\2\end{matrix}\right|$, 我们需要求正交矩阵 Q.</p><p><img src="https://i.loli.net/2020/08/12/Rl3YHK16gdzZaE2.png" alt="image-20200812165835745" style="zoom:15%;" /></p><p><strong>而且我们不难发现!!! $\left|\begin{matrix}1\ 1\\1\ 0\\1\ 2\end{matrix}\right|$是和 Q 的列空间是一样的! 因为我们在计算 B 的过程中, 所用到的就是 a 和 b, 所以列空间并没有发生改变!</strong></p><p><strong>注意! Gram-Schmidt 正交化十分类似矩阵 A 的 LU 分解. 在正交化的过程中, A 可以分解为 Q 和 R. 其中 R 是上三角矩阵:</strong></p><p> <img src="https://i.loli.net/2020/08/12/3Nk5p4CmheOtMwu.png" alt="image-20200812174035684" style="zoom:15%;" /></p><p>具体证明过程可查阅 &lt;线性代数及其应用(第五版)&gt;P353.</p><h2 id="Lec-17-Properties-of-Determinants"><a href="#Lec-17-Properties-of-Determinants" class="headerlink" title="Lec 17 Properties of Determinants"></a>Lec 17 Properties of Determinants</h2><h3 id="17-1-Overview"><a href="#17-1-Overview" class="headerlink" title="17.1 Overview"></a>17.1 Overview</h3><p> 本节主要是关于行列式的一些性质, 这些性质能够帮助理解后续问题.</p><h3 id="17-2-Properties"><a href="#17-2-Properties" class="headerlink" title="17.2 Properties"></a>17.2 Properties</h3><p>行列式是跟每个方阵都有关的一个数字. 这个数字包括了这个矩阵的很多性质, 例如方阵是否可逆可以根据行列式的值来进行判断, 行列式为 0, 则方阵不可逆. 行列式记法: $\left|A\right|$ 或 $det(A)$</p><blockquote><p>  性质一</p></blockquote><p>对于单位矩阵 $I$, 有 $det(A)=1$.</p><blockquote><p>  性质二</p></blockquote><p>交换两行之后, 行列式的值相反.由<strong>性质一</strong>和<strong>性质二</strong>, 我们可知置换矩阵的行列式值为 1 或-1.</p><blockquote><p>  性质三</p></blockquote><ul><li><p><strong>3.a</strong> 行列式按行提取系数, 即$\left|\begin{matrix}ta&amp;tb\\c&amp;d\end{matrix}\right|=t\left|\begin{matrix}a&amp;b\\c&amp;d\end{matrix}\right|$</p></li><li><p><strong>3.b</strong> 行列式是一个线性函数, 但这个线性单独反映在每一行上. 即 $\left|\begin{matrix}a+a’&amp;b+b’\\c&amp;d\end{matrix}\right|=\left|\begin{matrix}a&amp;b\\c&amp;d\end{matrix}\right|+\left|\begin{matrix}a’&amp;b’\\c&amp;d\end{matrix}\right|$</p></li></ul><p>注意, 这里并不是 $det(A+B)=det(A)+det(B)$, 这里的线性运算并不作用于整个矩阵上, 而是只反映在每一行上.</p><blockquote><p>  性质四</p></blockquote><p>如果两行相等, 那么行列式等于 0. 这条可以用性质 2 证明, 即 $det(A)=-det(A),\ det(A)=0$</p><blockquote><p>  性质五</p></blockquote><p>从矩阵的行 k 减去行 i 的 $l$ 倍, 矩阵的行列式值不变. 你们发现没有? 这个步骤就是我们常做的矩阵的消元.</p><p><img src="https://i.loli.net/2020/08/12/RD1tMZVjkfSdPQu.png" alt="image-20200812230428166" style="zoom:15%;" /></p><blockquote><p>  性质六</p></blockquote><p>如果矩阵有一行全为零, 那么矩阵的行列式为 0. 这条可以用性质三证明.</p><blockquote><p>  性质七</p></blockquote><p>上三角矩阵和对角矩阵的行列式等于其对角线上元素的乘积. 我们可以利用性质五进行消元得到矩阵 U 或 D, 也就是使主元 (pivot) 上下的元素为零.</p><p><img src="https://i.loli.net/2020/08/13/rNwzxRmdvoLCUOp.png" alt="image-20200813170038312" style="zoom:15%;" /></p><blockquote><p>  性质八</p></blockquote><p>若矩阵 A 可逆, 那么|A|不为零. 因为不可逆矩阵在进行消元之后会得到全零行, 其行列式一定为 0.</p><blockquote><p>  性质九</p></blockquote><p>$det(AB)=detA\times detB$</p><p>借此, 我们通过 $AA^{-1}=I$ 可以得到: </p><ul><li><p>$detA^{-1}=\frac{1}{detA}$</p></li><li><p>$detA^{2}=(detA)^{2}$</p></li><li>$det(kA)=k^ndetA$</li></ul><blockquote><p>  性质十</p></blockquote><p>$|A^T|=|A|$, 这个性质也并不难理解, 过程如下:</p><ul><li>将矩阵进行 LU 分解: $|U^TL^T|=|LU|$</li><li>由性质九, 我们可知: $|U^T||L^T|=|U||L|$</li><li>从 Lec 4 我们可知, L 是一个主对角线全是 1 的小三角矩阵, 而 U 是一个上三角矩阵. 像 U, L 这样的上/下三角矩阵, 不论转置与否, 其行列式都为对角线上各元素的乘积. </li></ul><h2 id="Lec-18-Determinant-Formulas-and-Cofactors"><a href="#Lec-18-Determinant-Formulas-and-Cofactors" class="headerlink" title="Lec 18 Determinant Formulas and Cofactors"></a>Lec 18 Determinant Formulas and Cofactors</h2><h3 id="18-1-Overview"><a href="#18-1-Overview" class="headerlink" title="18.1 Overview"></a>18.1 Overview</h3><p>本节主要是关于行列式公式和代数余子式 (Cofactors)</p><h3 id="18-2-Determinant-Formulas"><a href="#18-2-Determinant-Formulas" class="headerlink" title="18.2 Determinant Formulas"></a>18.2 Determinant Formulas</h3><p>上一节我们介绍了行列式的基本性质, 理解和掌握这些性质我们并不需要了解行列式如何求解, 但是我们可以根据这些性质推出来行列式的一般求解过程. 我们从二阶行列式讲起.</p><p>根据<strong>性质三</strong>, 我们可以得到:</p><p>$\left|\begin{matrix}a&amp;b\\c&amp;d\end{matrix}\right|=\left|\begin{matrix}a&amp;0\\c&amp;d\end{matrix}\right|+\left|\begin{matrix}0&amp;b\\c&amp;d\end{matrix}\right|=\left|\begin{matrix}a&amp;0\\c&amp;0\end{matrix}\right|+\left|\begin{matrix}a&amp;0\\0&amp;d\end{matrix}\right|+\left|\begin{matrix}0&amp;b\\c&amp;0\end{matrix}\right|+\left|\begin{matrix}0&amp;b\\0&amp;d\end{matrix}\right|=0+ad+(-bc)+0$</p><p>因此, $\left|\begin{matrix}a&amp;b\\c&amp;d\end{matrix}\right|=ab-cd$</p><p>观察上面的求解过程, 我们不难发现, 行列式其实取决于那些分解后非零的行列式的和, 这些非零行列式有这样一个特点: <strong>各行各列均有元素.</strong></p><p>接下来我们将问题扩展到三阶:</p><p><img src="https://i.loli.net/2020/08/14/89AJqHTcPuOUNGp.png" alt="image-20200814142313671" style="zoom:40%;" /></p><p>观察这个拆分过程, 很明显, 如果是 n 阶矩阵的话, 得到的非零行列式一共有 <code>n!</code> 种. 因为第一行有 n 个选择, 第二行就只有  n-1 个矩阵, 以此类推. 其实整个拆分过程就是每次从一行中选择剩余行不同列的元素相乘. 下面给出行列式计算的公式, 注意符号的正负: $|A|=\sum \pm a_{1\alpha}a_{2\beta}a_{3\gamma}\cdots a_{n\omega}$, 其中$\alpha,\beta,\gamma\cdots \omega$, 是集合 1~n 的某一种排列. n 个列标符号每个均只能用一次.</p><blockquote><p>  我们接下来用一个例子来理解这个式子, 求行列式: $\left|\begin{matrix}0&amp;0&amp;1&amp;1\\0&amp;1&amp;1&amp;0\\1&amp;1&amp;0&amp;0\\1&amp;0&amp;0&amp;1\end{matrix}\right|$</p><p>  我们从第一行开始, 只能从 $a_{13}$和 $a_{14}$开始分解, 我们可以得到行列式:</p><p>  $\left|\begin{matrix}0&amp;0&amp;1&amp;0\\0&amp;1&amp;0&amp;0\\1&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;1\end{matrix}\right|+\left|\begin{matrix}0&amp;0&amp;0&amp;1\\0&amp;0&amp;1&amp;0\\0&amp;1&amp;0&amp;0\\1&amp;0&amp;0&amp;0\end{matrix}\right|$</p><p>  为了将其调整到标准的对角线位置, 前者需要调整一次,故为-1. 后者需要调整两次, 故为+1. 因此该行列式的值为 0.</p></blockquote><h3 id="18-3-Cofactors"><a href="#18-3-Cofactors" class="headerlink" title="18.3 Cofactors"></a>18.3 Cofactors</h3><p>利用代数余子式, 我们可以更方便地求解行列式, 其作用是将 n 阶行列式化成 n-1 阶. </p><p>根据前面所讲的公式, 我们不难发现, 在选取元素进行累乘时, 例如从第一行选取第一个元素之后, 剩余的因子是在剩余的 <code>n-1</code> 行和<code>n-1</code> 列中选取. 这剩余的因子组成了一个 <code>n-1</code> 阶的行列式, 这就是所谓的代数余子式. 如图所示:</p><p><img src="https://i.loli.net/2020/08/14/7FCWTPGeNLXxncA.png" alt="image-20200814151607987" style="zoom:50%;" /></p><p>下面, 我们给出代数余子式的一般公式:</p><p>$a_{ij}$ 位置对应的代数余子式 (记为 $C_{ij}$), 等于去掉原行列式中第 <code>i</code> 行, 第 <code>j</code> 列后剩余元素组成的行列式的值. 且当 <code>i+j</code> 为偶数时取正, 奇数时为负, 可以理解为 $(-1)^{i+j} \times$剩余元素组成的行列式. </p><p><img src="https://i.loli.net/2020/08/14/1cYfjeT3xlrmOKb.png" alt="image-20200814152106916" style="zoom:15%;" /></p><p>$a_{ij}$ <strong>对应的余子式: 去掉代数余子式的正负符号就是对应的余子式.</strong></p><p>根据之前的介绍, 我们知道计算代数余子式就是一个提取公因式的过程, 那么对应地, 使用<strong>代数余子式来展开一个行列式</strong>, 就能得到对应行列式的值:</p><p>$|A|=a_{i1}C_{i1}+a_{i2}C_{i2}+\cdots\cdots+a_{in}C_{in}$, <code>i</code> 为行数, 代表沿第 <code>i</code> 行展开.</p><p>现在我们有三种方法计算行列式:</p><ul><li>将矩阵 A 化成上三角或对角线矩阵 (最简单, 也是 Matlab 使用的策略)</li><li>使用行列式公式完全展开计算 (很复杂)</li><li>使用代数余子式按一行展开进行计算 (稍复杂)</li></ul><blockquote><p>  接下来我们通过一种特殊的矩阵熟悉一下按行展开行列式的计算方法:</p><p>  $A_1=1,\ A_2=\left|\begin{matrix}1&amp;1\\1&amp;1\end{matrix}\right|,\ A_3=\left|\begin{matrix}1&amp;1&amp;0\\1&amp;1&amp;1\\0&amp;1&amp;1\end{matrix}\right|,\ A_4=\left|\begin{matrix}1&amp;1&amp;0&amp;0\\1&amp;1&amp;1&amp;0\\0&amp;1&amp;1&amp;1\\0&amp;0&amp;1&amp;1\end{matrix}\right|$ 我们来寻找一下这几个行列式的规律.</p><p>  解:</p><p>  我们先看一下 1, 2, 3 阶对应情况, 我们很容易得到: $A_1=1,A_2=0,A_3=-1$</p><p>  那么 $A_4$ 展开的行列式有什么规律呢? 我们看一下</p><p>  <img src="https://i.loli.net/2020/08/14/VcAbXKBau7m9f1I.png" alt="image-20200814154556953" style="zoom:45%;" /></p><p>  由于这个矩阵的特殊性, 我们可以得到规律:</p><p>  $A_n=A_{n-1}-A_{n-2}$, 所以这个结构的一组行列式对应的值就是一个数列: 1, 0, -1, -1, 0, 1 这样的循环. 也就是其对应行列式的值以 6 为周期进行变换.</p></blockquote><h2 id="Lec-19-Cramer’s-Rule-Inverse-Matrix-and-Volume"><a href="#Lec-19-Cramer’s-Rule-Inverse-Matrix-and-Volume" class="headerlink" title="Lec 19 Cramer’s Rule, Inverse Matrix and Volume"></a>Lec 19 Cramer’s Rule, Inverse Matrix and Volume</h2><h3 id="19-1-Overview"><a href="#19-1-Overview" class="headerlink" title="19.1 Overview"></a>19.1 Overview</h3><p>这一节主要是关于行列式的应用, 包含三个主题: 克莱姆法则, 逆矩阵和体积.</p><h3 id="19-2-Inverse-Matrix-Formula"><a href="#19-2-Inverse-Matrix-Formula" class="headerlink" title="19.2 Inverse Matrix Formula"></a>19.2 Inverse Matrix Formula</h3><p>我们先给出逆矩阵公式: $A^{-1}=\frac{1}{detA}C^T$. 这里的矩阵 C 代表代数余子式矩阵, 即其中各个元素为矩阵 A 各元素对应的代数余子式. 逆矩阵公式里面用的是矩阵 $C$ 的转置 $C^T$, 我们称之为伴随矩阵.</p><p>我们来看个简单的例子: $\left|\begin{matrix}a&amp;b\\c&amp;d\end{matrix}\right|^{-1}=\frac{1}{ad-bc}\left|\begin{matrix}d&amp;-b\-c&amp;a\end{matrix}\right|$</p><p>我们看看这个公式的结构:</p><p><img src="https://i.loli.net/2020/08/15/V6GelzDgjBwtLa7.png" alt="image-20200815204503301" style="zoom:45%;" /></p><blockquote><p>  <strong>我们再来研究一下公式的正确性</strong></p><p>  因为: $AA^{-1}=I$</p><p>  所以在逆矩阵公式两边同时乘A, 我们可以得到: $I=\frac{1}{detA}AC^T$</p><p>  <strong>因此, 我们需要验证:</strong> $AC^T=(detA)I$</p><p>  我们将其展开观察:</p><p>  $AC^T=\left|\begin{matrix}a_{11}&amp;\cdots&amp;a_{1n}\\\cdots&amp;\cdots&amp;\cdots\\a_{n1}&amp;\cdots&amp;a_{nn}\end{matrix}\right|\left|\begin{matrix}C_{11}&amp;\cdots&amp;C_{n1}\\\cdots&amp;\cdots&amp;\cdots\\C_{1n}&amp;\cdots&amp;C_{nn}\end{matrix}\right|=\left|\begin{matrix}detA&amp;0&amp;0\\0&amp;\cdots&amp;0\\0&amp;0&amp;detA\end{matrix}\right|=(detA)I$</p><p>  这里有一个问题, 我们以第一行为例, 为什么 $[a_{11}\quad a_{12}\quad \cdots\quad a_{1n}]$ 这个行向量在和不属于这行元素的代数余子式构成的列向量相乘时, 得到的结果为零呢? <strong>很简单, 就以 A 的第一行和 $C^T$ 的第二列为例:</strong></p><p>  $\left|\begin{matrix}a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\end{matrix}\right|\left|\begin{matrix}C_{21}\\C_{22}\\\cdots\\C_{2n}\end{matrix}\right|=a_{11}C_{21}+a_{12}C_{22}+\cdots+a_{1n}C_{2n}$</p><p>  我们构造一个新矩阵来看看这是个什么玩意:</p><p>  <img src="https://i.loli.net/2020/08/15/yRl3rGxvH2PcJfe.png" alt="image-20200815210722364" style="zoom:50%;" /></p><p>  这个矩阵前两行相同, 将这个矩阵按照第二行用行列式展开, 即是:</p><p>  <img src="https://i.loli.net/2020/08/15/rWuLgf5ByIOVN2c.png" alt="image-20200815210827385" style="zoom:50%;" /></p><p>  同时, 由于这个矩阵的前两行相同, 故其行列式为 0.</p></blockquote><p>我们再回过头来看一下逆矩阵公式: $A^{-1}=\frac{1}{detA}C^T$</p><p>这个公式能够帮助我们理解原矩阵和逆矩阵之间的关系, 理解原矩阵变化对逆矩阵的影响.</p><h3 id="19-3-Cramer’s-Rule"><a href="#19-3-Cramer’s-Rule" class="headerlink" title="19.3 Cramer’s Rule"></a>19.3 Cramer’s Rule</h3><p>基于上面的逆矩阵公式, 我们可以找到另一种解 <code>Ax=b</code> 的方式:</p><blockquote><p>  $Ax = b$</p><p>  $x=A^{-1}b=\frac{1}{detA}C^Tb$</p></blockquote><p>我们注意 $C^Tb$ 这个形式, 展开就是每一个代数余子式乘以 b 的各个分量. 余子式乘数字, 这让我们想到了行列式, 那么这个行列式是什么样的呢?</p><p>$x_{1}=\frac{1}{detA}(b_1C_{11}+b_2C_{21}+\cdots+b_nC_{n1})$</p><p>我们还是用构造法, 所以:</p><p>$x_{1}=\frac{detB_1}{detA}$, $x_{2}=\frac{detB_2}{detA}$, … , $x_{n}=\frac{detB_n}{detA}$</p><p>而且 $B_1=\left|\begin{matrix}b_1&amp;a_{12}&amp;\cdots&amp;a_{1n}\\b_1&amp;a_{22}&amp;\cdots&amp;a_{2n}\\\cdots&amp;\cdots&amp;\cdots&amp;\cdots\\b_1&amp;a_{n2}&amp;\cdots&amp;a_{nn}\end{matrix}\right|$, $|B_2|,|B_3|…$以此类推.</p><p>Cramer’s Rule 将计算 <code>Ax=b</code> 的过程给公式化了, 但是其实这公式没卵用, 成本太高, 不如用消元法.</p><h3 id="19-4-Volume"><a href="#19-4-Volume" class="headerlink" title="19.4 Volume"></a>19.4 Volume</h3><p>我们可以用 $3\times3$ 矩阵的行列式来求一个六面体的体积.</p><p>例如 $A=\left|\begin{matrix}a_{11}&amp;a_{12}&amp;a_{13}\\a_{21}&amp;a_{22}&amp;a_{23}\\a_{31}&amp;a_{32}&amp;a_{33}\end{matrix}\right|$, 对应的六面体如下:</p><p><img src="https://i.loli.net/2020/08/15/amdjGFYWA8NXVS9.png" alt="image-20200815214406477" style="zoom:20%;" /></p><p>行列式的值有正负, 所以该六面体的体积即为行列式的绝对值. 而正负号的作用是告诉我们这个六面体是左手系还是右手系的. 因为当我们调换这个六面体的两边之后, 我们得到的是不同系下的立体, 其体积不会改变, 只是旋转顺序变了.</p><p>我们研究几个特别的矩阵:</p><ul><li><p>单位矩阵 $I$</p><p>很明显, 单位矩阵对应的是长宽高均为 1 的立方体, 朝向即是各坐标轴的正方向.</p></li><li><p>正交矩阵 $Q$</p><p>你应该还记得正交矩阵有这个特性 $QQ^T=I$, 两面同时取行列式我们可以得到 $detQ=1$. 所以 Q 对应的也是长宽高均为 1 的立方体, 只是在坐标轴里面发生了旋转.</p></li></ul><p>我们在 Lec 17 中讲了行列式的性质, 其中性质一,二,三(a)都很好证明, 我们在这里主要讲一下性质三(b): $\left|\begin{matrix}a+a’&amp;b+b’\\c&amp;d\end{matrix}\right|=\left|\begin{matrix}a&amp;b\\c&amp;d\end{matrix}\right|+\left|\begin{matrix}a’&amp;b’\\c&amp;d\end{matrix}\right|$</p><p>我们以二维为例:</p><p><img src="https://i.loli.net/2020/08/15/9jFiuWwIgyEbl2f.png" alt="image-20200815215406790" style="zoom:40%;" /></p><p>有上面的启发, 求过原点的三角形面积就可以用行列式求解: $S=\frac{1}{2}det(\left|\begin{matrix}a&amp;b\\c&amp;d\end{matrix}\right|)$</p><p>而对于不过原点的三角形, 我们就需要构造新的矩阵, 并求其行列式, 比如:</p><p><img src="https://i.loli.net/2020/08/15/xHgD4KP9RtWjdba.png" alt="image-20200815215840496" style="zoom:15%;" /></p><p>需要新构建的矩阵就是: $A=\left|\begin{matrix}x_1&amp;y_1&amp;1\\x_2&amp;y_2&amp;1\\x_3&amp;y_3&amp;1\end{matrix}\right|$, 此三角形面积即为: $\frac{1}{2}det(A)$, 我们计算这个矩阵的行列式的时候会做一系列的消元, 这一系列消元相当于将三角形移到了原点位置.</p><h2 id="Lec-20-Eigenvalues-and-Eigenvectors"><a href="#Lec-20-Eigenvalues-and-Eigenvectors" class="headerlink" title="Lec 20 Eigenvalues and Eigenvectors"></a>Lec 20 Eigenvalues and Eigenvectors</h2><h3 id="20-1-Overview"><a href="#20-1-Overview" class="headerlink" title="20.1 Overview"></a>20.1 Overview</h3><p>本节主要介绍特征值与特征向量. 主要目的是掌握求特征值的一般步骤.</p><h3 id="20-2-Concept-of-Eigenvalues-and-Eigenvectors"><a href="#20-2-Concept-of-Eigenvalues-and-Eigenvectors" class="headerlink" title="20.2 Concept of Eigenvalues and Eigenvectors"></a>20.2 Concept of Eigenvalues and Eigenvectors</h3><p>我们首先给出特征值和特征向量的定义:</p><p>对于一个矩阵 $A$, 如果有 $Ax=\lambda x$, 那么我们则称 $x$ 为特征向量, $\lambda$ 为特征值. 那么如何理解特征值与特征向量所代表的意义呢？我们来看 $Ax$ 这个式子, 对于不同的向量 $x$, $Ax$ 这个式子像是一个函数, 输入是一个向量 $x$, 输出是另外一个向量 $Ax$. 而在我们输入的众多向量 $x$ 生成的 $Ax$ 中, 会有这样的向量 $Ax$, 它们平行于 $x$，我们即用上面这个式子: $Ax=\lambda x$ 来表示这个关系.</p><p>如果特征值为 0 呢? 此时会有 $Ax=0$. 我们可以发现如果矩阵 $A$ 是不可逆的时候, 就可以找到特征向量不为零的情况.</p><p>我们再来研究一下之前提到过的投影矩阵, 如果投影矩阵是 P 的话, 那么其对应的特征值是多少呢?</p><ul><li>如果对任意平面上的 $x_1$ 来说, 投影矩阵根本不会影响它的大小所以就有: $Ax_1=\lambda x_1$ 恒成立, 此时 $\lambda=1$.</li><li>如果对任意垂直平面的 $x_2$ 来说, 投影矩阵的会使: $Ax_2=0$ 恒成立, 此时 $\lambda=0$.</li></ul><p><img src="https://i.loli.net/2020/08/16/OwNvYztf9iK8ASD.png" alt="image-20200816162319159" style="zoom:50%;"/></p><h3 id="20-3-Solution"><a href="#20-3-Solution" class="headerlink" title="20.3 Solution"></a>20.3 Solution</h3><p>我们现在来介绍特征值和特征向量的一般求解方法, 我们需要对方程进行一些处理:</p><p>$Ax=\lambda x$ → $(A-\lambda I)x=0$ → $A-\lambda I$ 是不可逆矩阵 → $A-\lambda I$ 行列式为 0</p><p>由此我们可以求出特征值, n 阶矩阵有 n 个特征值. 在求解特征向量是, 我们只需要带入一个特征值之后, 求对应线性方程组的 Nullspace.</p><blockquote><p>  <strong>[例 1]</strong></p><p>  我们来看一个例子: 求解 $\left|\begin{matrix}3&amp;1\\1&amp;3\end{matrix}\right|$ 的特征向量和特征值</p><p>  我们只需要构造矩阵 $\left|\begin{matrix}3-\lambda&amp;1\\1&amp;3-\lambda\end{matrix}\right|$ 并求解其行列式等于 0. 我们可以得到方程式: $\lambda^2-6\lambda+8=0$, 解得两个特征值: $\lambda_1=2, \lambda_2=4$. 我们代入特征值可以得到相应的特征向量: $x_1=\left|\begin{matrix}-1\\1\end{matrix}\right|,x_2=\left|\begin{matrix}1\\1\end{matrix}\right|$.</p><p>  <strong>注:</strong> </p><ul><li>我们不难发现 $\lambda_1+\lambda_2=6$, 正好是矩阵对角线上元素的和, 我们称之为<strong>迹 (trace)</strong>. <strong>也就是矩阵的特征值之和和迹相等.</strong></li><li><p>同时我们发现 $\lambda_1\lambda_2=8$, 正好是矩阵的行列式. <strong>也就是矩阵的特征值之积和矩阵的行列式相等.</strong></p><p><strong>[例 2]</strong></p><p>我们在前一个例子的基础上, 如果矩阵 $A=\left|\begin{matrix}3&amp;1\\1&amp;3\end{matrix}\right|-3I$, 那么它的特征值和特征向量将如何变化?</p><p>原矩阵的特征值为: $\lambda_1=2,\lambda_2=4$.</p><p>新矩阵的特征值为: $\lambda_1=-1,\lambda_2=1$</p><p>我们不难发现, 新的特征值变为 $\lambda-3$, 且对应的特征向量不会改变. 即 $(A-3I)x=\lambda x-3x=(\lambda -3)x$</p><p><strong>[例 3]</strong></p><p>矩阵 A 有特征值 $\lambda$, 即 $Ax=\lambda x$. 矩阵 B 有特征值, 即 $Ax=\alpha x$. 那么 $(A+B)x=(\lambda+\alpha)x$ 是否成立?</p><p><strong>答案是不成立的, 这里的 x 是不一样的.</strong></p></li></ul></blockquote><h3 id="20-4-Special-Case"><a href="#20-4-Special-Case" class="headerlink" title="20.4 Special Case"></a>20.4 Special Case</h3><p>接下来, 我么通过两个例子来说明求解特征向量和特征值的过程很重可能遇到的特殊情况.</p><blockquote><p>  <strong>[例 4]</strong></p><p>  旋转矩阵 Q 使得每个向量旋转 $90^\circ$, 记为 $Q=\left|\begin{matrix}cos90^\circ&amp;-sin90^\circ\\sin90^\circ&amp;cos90^\circ\end{matrix}\right|=\left|\begin{matrix}0&amp;-1\\1&amp;0\end{matrix}\right|$ , 求特征值和特征向量.</p><p>  根据上面例 1 的结论, 我们可以知道</p><ul><li>$\lambda_1+\lambda_2=0$</li><li><p>$\lambda_1\lambda_2=1$</p><p>求解我们可以得到, $\lambda_1=i,\lambda_2=-i$</p><p><strong>启示:</strong> 我们发现 $Q$ 是反对称矩阵, 即 $A^T=-A$, 而我们之前求的都是对称矩阵的特征值, 也就是说, 对称矩阵的特征值为实数, 而反对称矩阵的特征值为虚数, 这是两个极端.</p><p><strong>[例 5]</strong></p><p>求矩阵 $A = \left|\begin{matrix}3&amp;1\\0&amp;3\end{matrix}\right|$ 的特征值和特征向量</p><p>这是个上三角矩阵, 求解 A-λI 行列式时会发现: $\lambda_1=\lambda_2=3$, 这时的 特征向量只会有一个, 也就是说, 三角矩阵的结构的特殊性导致了其行列式为对角线上元素, 而如果对角线上两个元素相等, 那么就会造成特征向量短缺情况.</p></li></ul></blockquote><h2 id="Lec-21-Diagonalization-and-Powers-of-A"><a href="#Lec-21-Diagonalization-and-Powers-of-A" class="headerlink" title="Lec 21 Diagonalization and Powers of A"></a>Lec 21 Diagonalization and Powers of A</h2><h3 id="20-1-Overview-1"><a href="#20-1-Overview-1" class="headerlink" title="20.1 Overview"></a>20.1 Overview</h3><p>本节课主要是关于矩阵的对角化, 并利用了矩阵的对角化简化了矩阵的幂运算. 最后也会提一嘴差分方程的应用.</p><h3 id="20-2-Diagonalization"><a href="#20-2-Diagonalization" class="headerlink" title="20.2 Diagonalization"></a>20.2 Diagonalization</h3><p>所谓矩阵的对角化, 其实就是矩阵的一种分解方式. 我们之前已经学习过两种分解方式:</p><ul><li>LU 分解</li><li>QR 分解</li></ul><p>但根据我们上一节学习的特征值和特征向量, 我们能引入一种新的分解方式, 即矩阵的对角化. 若矩阵 A 有 n 个线性无关的特征向量, 那么可以将它们组成一个可逆方阵, 进而将矩阵进行分析:</p><blockquote><p>  假设 A 的 n 个线性无关的特征向量组成矩阵 S, 有:</p><p>  $S=[x_1,\quad x_2,\quad \cdots \quad,x_n]$</p><p>  构造 $AS=A[x_1,\quad x_2,\quad \cdots \quad,x_n]$</p><p>  由特征值得定义我们可以知道: $AS=A[x_1,\quad x_2,\quad \cdots \quad,x_n]=[\lambda_1x_1,\quad \lambda_2x_2,\quad \cdots \quad,\lambda_nx_n]$</p><p>  写成矩阵乘法形式: $AS=[\lambda_1x_1,\quad \lambda_2x_2,\quad \cdots \quad,\lambda_nx_n]=[x_1,\quad x_2,\quad \cdots \quad,x_n]\left|\begin{matrix}\lambda_1&amp;0&amp;0&amp;0\\0&amp;\lambda_2&amp;0&amp;0\\0&amp;0&amp;\cdots&amp;0\\0&amp;0&amp;0&amp;\lambda_n\end{matrix}\right|$</p><p>  我们将由特征值组成的对角矩阵称为 $\Lambda$, 即 $AS=S\Lambda$</p><p>  由于矩阵 S 是由线性无关的特征向量组成的, 所以矩阵 S 是可逆的, 因此我们可以得到:</p><ul><li>$\Lambda=S^{-1}AS$</li><li>$A=S\Lambda S^{-1}$</li></ul></blockquote><p><strong>如上, 我们得到了一种新的矩阵分解方式, 利用矩阵 $A$ 的 $n$ 个线性无关的特征向量构造矩阵 $S$, 再利用矩阵 $A$ 的 $n$ 个特征值 $\lambda$ 构造对角矩阵 $\Lambda$, 将 $A$ 分解为: $A=S\Lambda S^{-1}$</strong></p><p>所以这中矩阵分解方式有什么用呢? 其实主要是用于理解矩阵的幂运算. 比如:</p><p>$A=S\Lambda S^{-1}$</p><p>$A^2=S\Lambda^2 S^{-1}$</p><p>$A^k=S\Lambda^k S^{-1}$</p><p>我们使用特征向量和特征值也可以很明显看出这个性质:</p><p>$Ax=\lambda x$</p><p>$A^2x=\lambda Ax=\lambda^2x$</p><p>$A^kx=\lambda^kx$</p><p>这说明, 矩阵的 k 次幂 $A^k$ 的特征值是 $\lambda^k$, 而特征向量 $x$ 不受次幂的影响, 即 $A^k=S\Lambda^k S^{-1}$.</p><blockquote><p>  我们来思考一个问题, 若矩阵 $A$ 存在 $n$ 个线性无关的特征向量, 那么什么条件下能使矩阵的幂 $A^k$ 趋近于零?</p><p>  <strong>解:</strong></p><p>  由 $A^k=S\Lambda^k S^{-1}$ 可知, 当所有特征值都满足: $|\lambda_i|&lt;1$ 时, 当 $k$ 趋近于无穷大时, 矩阵 $A^k$ 趋近于零.</p></blockquote><p>另外, 注意矩阵是否能够成功对角化取决于该矩阵是否有 n 个线性无关的特征向量, 而特征向量与特征值之间有着紧密的联系:</p><ul><li>如果矩阵 $A$ 没有重复的特征值, 矩阵就一定有 $n$ 个线性无关的特征向量 (这也就意味着, 不同特征值对应特征向量线性无关)</li><li>但是如果有重复的特征值, 结论不是完全否定的, 也就是说这时也可能存在 $n$ 个线性无关的特征向量. 例如: 10x10 的单位矩阵, 其特征值只有 1, 但是事实 上我们可以取得 10 个线性无关的特征向量.</li></ul><blockquote><p>  <strong>[例 1]</strong></p><p>  看一个例子, 判定矩阵 $A=\left|\begin{matrix}2&amp;1\\0&amp;2\end{matrix}\right|$ 是否可以对角化?</p><p>  <strong>解:</strong></p><p>  上述矩阵的特征值只有一个即: $\lambda_1=\lambda_2=2$, 再看矩阵 $A-2I$ 的零空间, 只有一个特征向量 $\left|\begin{matrix}1\\0\end{matrix}\right|$, 零空间只是一维的, 所以矩阵 $A$ 不可以对角化.</p></blockquote><h3 id="20-3-Differential-Equations"><a href="#20-3-Differential-Equations" class="headerlink" title="20.3 Differential Equations"></a>20.3 Differential Equations</h3><p>有了对角化知识的储备, 我们可以开始着手解决矩阵的次幂问题了. 我们还是看几个例子:</p><blockquote><p>  <strong>[例 2]</strong></p><p>  有这样一种递推关系: 给定向量 $u_0$, 有 $u_{k+1}=Au_k$</p><p>  <strong>解:</strong></p><p>  根据这个递推关系, 我们不难得到: $u_k=A^ku_0$</p><p>  但是这种解并不具体, 根据上面学习到的知识, 由于 $u_0$ 是 $n$ 维的, 而 $A$ 又有 $n$ 个线性无关的特征向量, 所以 $u_0$ 可以写为一个由矩阵 $A$ 的 $n$ 个特征向量组成的线性组合, 类似于基:</p><p>  ​                                                    $u_0=c_1x_1+c_2x_2+\cdots+c_nx_n$</p><p>  再将 A 化为特征值形式:</p><p>  ​                                                    $u_1= Au_0=c_1\lambda_1 x_1+c_2\lambda_2 x_2+\cdots+c_n\lambda_n x_n$</p><p>  ​                                                    $u_2= A^2u_0=c_1\lambda_1^2 x_1+c_2\lambda_2^2 x_2+\cdots+c_n\lambda_n^2 x_n$</p><p>  ​                                                    $\cdots\cdots$</p><p>  ​                                                    $u_k= A^ku_0=c_1\lambda_1^k x_1+c_2\lambda_2^k x_2+\cdots+c_n\lambda_n^k x_n$</p><p>  写成矩阵形式:</p><p>  ​                                                    $u_k=S\Lambda^kC$</p><p>  其中 $\Lambda$ 是特征值构成的对角矩阵, $S$ 是由特征向量构成的矩阵, $C$ 是由系数 $c_1,c_2,\cdots,c_n$ 构成.</p><p>  <strong>[例 3]</strong></p><p>  斐波那契数列 0, 1, 1, 2, 3, 5, 8, 13, … 试求第 100 项的值, 以及其增长速度.</p><p>  <strong>解:</strong></p><p>  同样, 由斐波那契数列的特征, 我们可以得到以下方程:</p><p>  ​                                                    $F_{k+2}=F_{k+1}+F_k$</p><p>  我们希望构造一阶差分, 但是仅仅这一个方程是无法构造矩阵形式的, 我们添加一个方程:</p><p>  ​                                                    $F_{k+1}=F_{k+1}$</p><p>  通过联立的方程组, 构造一个矩阵形式:</p><p>  设 $u_k=\left|\begin{matrix}F_{k+1}\\F_{k}\end{matrix}\right|$, 则该方程组可以矩阵化为 $u_{k+1}=\left|\begin{matrix}1&amp;1\\1&amp;0\end{matrix}\right|u_k=\left|\begin{matrix}F_{k+1}+F_{k}\\F_{k+1}\end{matrix}\right|$</p><p>  这样我们成功将一个二阶方程化为一个一阶方程组, 也就是我们在例 1中提到的 $u_{k+1}=Au_k$ 的形式.</p><p>  对于矩阵 $A=\left|\begin{matrix}1&amp;1\\1&amp;0\end{matrix}\right|$, 我们知道其特征值为: </p><p>  ​                                                    $\lambda_1=\frac{1}{2}(1+\sqrt{5})=1.618,\lambda_2=\frac{1}{2}(1-\sqrt{5})=-0.618$</p><p>  根据上面的介绍, $u_k=A^ku_0=c_1\lambda_1^k x_1+c_2\lambda_2^k x_2+\cdots+c_n\lambda_n^k x_n$. 而对于斐波那契这个数列而言, n = 2, 有:</p><p>  ​                                                    $u_k=c_1\lambda_1^k x_1+c_2\lambda_2^k x_2$</p><p>  而 $\lambda_2=-0.618$, 其绝对值比 1 小, 所以 $u_k$ 后一项趋于 0, 所以影响数列变化只剩下了 $\lambda_1$. 这样根据上面公式, 可以初步估算第 100 项近似为: </p><p>  ​                                                    $F_{100}\approx c_1\lambda_1^{100}=c_1(\frac{1+\sqrt{5}}{2})^{100}$</p><p>  接下来我们求 C 的对应值, 这需要从 $u_0$ 的展开式入手, 所以我们需要先得到矩阵 A 的两个特征向量:</p><p>  ​                                                    $x_1=\left|\begin{matrix}\lambda_1\\1\end{matrix}\right|,x_2=\left|\begin{matrix}\lambda_2\\1\end{matrix}\right|$</p><p>  本例中的初始向量 $u_0$ 为: $u_0=\left|\begin{matrix}1\\0\end{matrix}\right|$</p><p>  将之代入 $u_0$ 的式子: $u_0=c_1x_1+c_2x_2+\cdots+c_nx_n$, 即可求得 $c_1$ and $c_2$.</p><p>  我们来回顾一下解题的思路:</p><ul><li>首先将方程组构造成动态增长的一阶方程组, 此时它的初始向量为 $u_0$.</li><li>此后关键在于确定 $A$ 的特征值, 因为特征值决定了增长的趋势, 发散至无穷还是收敛至 0 全由特征值决定.</li><li>接着需要找到对应的 $u_k$ 的展开式, 确定数列变化过程以及对应值.</li><li>求 $A$ 的特征向量, 代入 $u_0$ 来确定 c 的值, 而且各个特征向量必须是独立的.</li></ul></blockquote><h2 id="Lec-22-Differentiatial-Equations-and-exp-At"><a href="#Lec-22-Differentiatial-Equations-and-exp-At" class="headerlink" title="Lec 22 Differentiatial Equations and exp(At)"></a>Lec 22 Differentiatial Equations and exp(At)</h2><h2 id="Lec-23-Markov-Matrices-Fourier-Series"><a href="#Lec-23-Markov-Matrices-Fourier-Series" class="headerlink" title="Lec 23 Markov Matrices, Fourier Series"></a>Lec 23 Markov Matrices, Fourier Series</h2><h2 id="Lec-24-Symmetric-Matrices-and-Positive-Definiteness"><a href="#Lec-24-Symmetric-Matrices-and-Positive-Definiteness" class="headerlink" title="Lec 24 Symmetric Matrices and Positive Definiteness"></a>Lec 24 Symmetric Matrices and Positive Definiteness</h2><h2 id="Lec-25-Complex-Matrices-and-Fast-Fourier-Transform"><a href="#Lec-25-Complex-Matrices-and-Fast-Fourier-Transform" class="headerlink" title="Lec 25 Complex Matrices and Fast Fourier Transform"></a>Lec 25 Complex Matrices and Fast Fourier Transform</h2><h2 id="Lec-26-Positive-Definite-Matrices-and-Minima"><a href="#Lec-26-Positive-Definite-Matrices-and-Minima" class="headerlink" title="Lec 26 Positive Definite Matrices and Minima"></a>Lec 26 Positive Definite Matrices and Minima</h2><h2 id="Lec-27-Similar-Matrices-and-Jordan-Form"><a href="#Lec-27-Similar-Matrices-and-Jordan-Form" class="headerlink" title="Lec 27 Similar Matrices and Jordan Form"></a>Lec 27 Similar Matrices and Jordan Form</h2><h2 id="Lec-28-Singular-Value-Decomposition"><a href="#Lec-28-Singular-Value-Decomposition" class="headerlink" title="Lec 28 Singular Value Decomposition"></a>Lec 28 Singular Value Decomposition</h2><h2 id="Lec-29-Linear-Transformations-and-Their-Matrices"><a href="#Lec-29-Linear-Transformations-and-Their-Matrices" class="headerlink" title="Lec 29 Linear Transformations and Their Matrices"></a>Lec 29 Linear Transformations and Their Matrices</h2><h2 id="Lec-30-Change-of-Basis-and-Image-Compression"><a href="#Lec-30-Change-of-Basis-and-Image-Compression" class="headerlink" title="Lec 30 Change of Basis and Image Compression"></a>Lec 30 Change of Basis and Image Compression</h2><h2 id="Lec-31-Left-and-Right-Inverses-and-Pseudoinverse"><a href="#Lec-31-Left-and-Right-Inverses-and-Pseudoinverse" class="headerlink" title="Lec 31 Left and Right Inverses and Pseudoinverse"></a>Lec 31 Left and Right Inverses and Pseudoinverse</h2>]]></content>
      
      
      <categories>
          
          <category> Mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra Part 1</title>
      <link href="2020/08/15/MIT-Linear-Algebra-Part-1/"/>
      <url>2020/08/15/MIT-Linear-Algebra-Part-1/</url>
      
        <content type="html"><![CDATA[<p>This is a basic subject on matrix theory and linear algebra. Emphasis is given to topics that will be useful in other disciplines, including systems of equations, vector spaces, determinants, eigenvalues, similarity, and positive definite matrices.</p><h2 id="Lec-1-The-Gemetry-of-Linear-Algebra"><a href="#Lec-1-The-Gemetry-of-Linear-Algebra" class="headerlink" title="Lec 1 The Gemetry of Linear Algebra"></a>Lec 1 The Gemetry of Linear Algebra</h2><h3 id="1-1-Overview"><a href="#1-1-Overview" class="headerlink" title="1.1 Overview"></a>1.1 Overview</h3><p>本节课程主要是从两个不同角度去了解什么是线性方程组.</p><p><img src="https://i.loli.net/2020/08/08/V2Y1ItKxmLiCGSn.png" alt="image-20200808072306142" style="zoom: 10%;" /></p><p><strong>系数矩阵(A): 方程组系数构成的矩阵</strong></p><p><strong>未知向量(x): 方程未知数构成的矩阵</strong></p><p><strong>向量(b): 等式右侧结果所构成的向量</strong></p><h3 id="1-2-Row-Figure"><a href="#1-2-Row-Figure" class="headerlink" title="1.2 Row Figure"></a>1.2 Row Figure</h3><p>Row Figure 是指在 <code>Ax=b</code> 的矩阵表示中, 一次取一行构成方程, 并在坐标轴中做出相应的图形.</p><p><img src="https://i.loli.net/2020/08/08/MlOXpC64aNeq8zA.png" alt="image-20200808072846217" style="zoom:15%;" /></p><p>但不难发现, 我们很难做高维坐标轴图像, 所以我更倾向于使用 Column Figure 来理解线性方程组.</p><h3 id="1-3-Column-Figure"><a href="#1-3-Column-Figure" class="headerlink" title="1.3 Column Figure"></a>1.3 Column Figure</h3><p>从 Column Figure 的角度来看, <code>b</code> 是 linear combinations of columns of <code>A</code>, 也就是 <code>Ax</code>:</p><p><img src="https://i.loli.net/2020/08/08/ZwH1v36iNrQKuyW.png" alt="image-20200808073724819" style="zoom:7%;" /></p><p>图像表示</p><p><img src="https://i.loli.net/2020/08/08/QmNyLHzTciI8Psu.png" alt="image-20200808074347051" style="zoom:20%;" /></p><h3 id="1-4-Question"><a href="#1-4-Question" class="headerlink" title="1.4 Question"></a>1.4 Question</h3><p>Can I solve <code>Ax=b</code> for every b?</p><p>这个问题也等于是在问: <strong>Do the linear combination of columns of A fill N-D space?</strong></p><p>这里我们暂时不解答这个问题, 在后续课程会详细讲解:)</p><h2 id="Lec-2-Elimination-with-Matrices"><a href="#Lec-2-Elimination-with-Matrices" class="headerlink" title="Lec 2 Elimination with Matrices"></a>Lec 2 Elimination with Matrices</h2><h3 id="2-1-Overview"><a href="#2-1-Overview" class="headerlink" title="2.1 Overview"></a><strong>2.1 Overview</strong></h3><p>本节课程主要是介绍<strong>消元法</strong>, 即使”系统化”求解线性方程组所需的方法, Matlab 的方程组求解也是用这种方法.</p><p>所谓矩阵的消元法, 与我们初等数学中学习的解二元一次方程组的消元法其实师出同门, 都是通过将不同行的方程进行消元运算来简化方程, 最后能得到简化的方程组, <strong>只不过这里我们把系数单独抽出来进行运算, 寻找一种矩阵情况下的普遍规律而已.</strong></p><h3 id="2-2-Intro-Example"><a href="#2-2-Intro-Example" class="headerlink" title="2.2 Intro Example"></a>2.2 Intro Example</h3><p>我们从一个例子入手, 求解线性方程组:</p><p><img src="https://i.loli.net/2020/08/08/aTuO5nrd4fsPUKb.png" alt="image-20200808080203366" style="zoom:50%;" /></p><p>解题思路是”将一行乘倍数加到另一行”, 使主元所在列上的主元以下的元素全为 0.</p><p><img src="https://i.loli.net/2020/08/08/qER6vzY8IcN9543.png" alt="image-20200808080917241" style="zoom:25%;" /></p><p>之后将所得的新 <code>A</code> 和 <code>b</code> <strong>回带(Back Substitution)</strong> 求解.</p><p><img src="https://i.loli.net/2020/08/08/Xfprjo7EuVWxNtT.png" alt="image-20200808081437713" style="zoom:10%;" /></p><p>当然有有些时候, 我们会遇到主元位置上是 0 的情况, 这个时候我们只需要交换行即可.</p><h3 id="2-3-Advanced-Example"><a href="#2-3-Advanced-Example" class="headerlink" title="2.3 Advanced Example"></a>2.3 Advanced Example</h3><p>上面的例子是从 Intuition 的角度来理解了消元的操作, 但是我们需要一种更系统的方法, 能够被 Computer 理解的方法. 所以我们在这里要引入<strong>消元矩阵</strong>的概念. </p><p>在讲消元矩阵之前, 我们还需要了解 <code>Linear Combination of Rows</code>:</p><p><img src="https://i.loli.net/2020/08/08/FdPxfUCSoArYl8T.png" alt="image-20200808082702374" style="zoom:10%;" /></p><p><strong>Matrix x Column Vector = Column Vector</strong></p><p><strong>Row Vector x Matrix = Row Vector</strong></p><p>Ok, 在了解这个知识点之后, 如果我们需要消元下面这个矩阵, 我们需要哪些步骤?</p><p><img src="https://i.loli.net/2020/08/08/aTuO5nrd4fsPUKb.png" alt="image-20200808080203366" style="zoom:50%;" /></p><p><strong>Step 1:</strong> Substract 3 x Row1 from Row2</p><p><img src="https://i.loli.net/2020/08/08/D2EfNaFsx3WeOPS.png" alt="image-20200808083548341" style="zoom:15%;" /></p><p><strong>Step 2:</strong> Substract 2 x Row2 from Row3</p><p><img src="https://i.loli.net/2020/08/08/cqWaBGTDv4AMUit.png" alt="image-20200808083843515" style="zoom:13%;" /></p><p><strong>Comb of Step 1 and Step 2:</strong></p><p><img src="https://i.loli.net/2020/08/08/pWhjl25ZQsbRGHf.png" alt="image-20200808084032447" style="zoom:10%;" /></p><h3 id="2-4-Extension"><a href="#2-4-Extension" class="headerlink" title="2.4 Extension"></a>2.4 Extension</h3><p>既然已经讲到了消元矩阵, 我想在这里提一下<strong>置换矩阵(Permutation Matrix)</strong>.</p><p><strong>Exchange Row1 and Row2:</strong></p><p><img src="https://i.loli.net/2020/08/08/2scrH5MSUYQo3GJ.png" alt="image-20200808084527151" style="zoom:8%;" /></p><p><strong>Exchange Col1 and Col2:</strong></p><p><img src="https://i.loli.net/2020/08/08/vEDgK38PTRno1M9.png" alt="image-20200808084840670" style="zoom:8%;" /></p><h2 id="Lec-3-Multiplication-and-Inverse-Matrices"><a href="#Lec-3-Multiplication-and-Inverse-Matrices" class="headerlink" title="Lec 3 Multiplication and Inverse Matrices"></a>Lec 3 Multiplication and Inverse Matrices</h2><h3 id="3-1-Overview"><a href="#3-1-Overview" class="headerlink" title="3.1 Overview"></a>3.1 Overview</h3><p>上节课我们学习了矩阵和向量之间的乘法, 这节课则是学习矩阵之间的乘法, 并讨论逆矩阵的相关知识点.</p><h3 id="3-2-Multiplication"><a href="#3-2-Multiplication" class="headerlink" title="3.2 Multiplication"></a>3.2 Multiplication</h3><p>矩阵的乘法有四种理解方式:</p><p><strong>1) Standard Rule (Row x Column)</strong></p><p><img src="https://i.loli.net/2020/08/08/WuBxhj3zZAieVaJ.png" alt="image-20200808091144775" style="zoom:15%;" /></p><p><strong>2) Column Way</strong></p><p><img src="https://i.loli.net/2020/08/08/iNTWCz59bhnrVl1.png" alt="image-20200808091515971" style="zoom:18%;" /></p><p><strong>3) Row Way</strong></p><p><img src="https://i.loli.net/2020/08/08/gU5ZoeG1TJRyu2j.png" alt="image-20200808091749387" style="zoom:18%;" /></p><p><strong>4) Column x Row</strong></p><p><img src="https://i.loli.net/2020/08/08/ZbKto6znOTM9UFa.png" alt="image-20200808092104530" style="zoom:18%;" /></p><p>在显示生活中矩阵的 scale 往往都很大, 所以为了减小计算成本, 我们可以将矩阵划分成 Blocks, 然后再相乘, 即 <code>Block Multiplication</code>.</p><p><img src="https://i.loli.net/2020/08/08/iJktpbrxYsTV93B.png" alt="image-20200808092244258" style="zoom:18%;" /></p><h3 id="3-3-Inverse-Matrices"><a href="#3-3-Inverse-Matrices" class="headerlink" title="3.3 Inverse Matrices"></a><strong>3.3 Inverse Matrices</strong></h3><p>逆矩阵的定义:</p><p>对于一个<strong>方阵A</strong>, 如果 A 可逆, 那么则存在一个 $A^{-1}$, 使: $AA^{-1}=I=A^{-1}A$. </p><blockquote><p>  A left inverse is also a right inverse, which is only true for square matrices.</p></blockquote><p>如果一个矩阵存在逆矩阵, 我们则称该矩阵 <code>non-singular</code>, 即非奇异的.</p><p>我们先来看一个奇异矩阵, 也就是没有逆的矩阵:</p><p><img src="https://i.loli.net/2020/08/08/RWKYm4kD9SXfEUc.png" alt="image-20200808122223205" style="zoom:8%;" /></p><p>Why 这个矩阵是奇异的呢? 这里我介绍三个原因:</p><ul><li><p>我们还没有学行列式, 但是可以先记住 det(A) = 1x6 - 2x3 = 0</p></li><li><p>Linear combinations of columns of A can’t get $\left|\begin{matrix}1\\0\end{matrix}\right|$</p></li><li><p>I can find a <strong>non-zero</strong> vectro <code>x</code> with <code>Ax=0</code></p></li></ul><p><img src="https://i.loli.net/2020/08/08/erDT64qKvnMyCZS.png" alt="image-20200808122731932" style="zoom:8%;" /></p><p>Ok, 所以我们怎么计算逆矩阵呢? 直观来说, 我们可以使用 Column Way 的方式构建方程式, 因为$AA^{-1}=I=A^{-1}A$. </p><p><img src="https://i.loli.net/2020/08/08/kCXJRF1mvdx6gV3.png" alt="image-20200808123222024" style="zoom:15%;" /></p><p>但是对于高阶矩阵来说, 这种计算方式的成本太高了. 所以我们这里引入另外一种计算方式:<strong>高斯-若尔当方法 (Gauss-Jordan idea)</strong></p><p><img src="https://i.loli.net/2020/08/08/26XanMeTOxEI7vB.png" alt="image-20200808123723069" style="zoom:15%;" /></p><p>至于 Gauss-Jordan 成立的原因也非常直观: <strong>$E[A\ I] = [I\ ?]$</strong> ==&gt; $EA = I$, so $EI = A^{-1}$</p><p>最后, 再介绍两个逆矩阵的性质:</p><ul><li><p><strong>Inverse of the product</strong></p><p>$(AB)^{-1}=B^{-1}A^{-1}$</p></li><li><p><strong>Inverse of the transpose</strong></p><p>$(AA^{-1})^{T}=(A^{-1})^{T}A^{T}=(A^{T})^{-1}A^{T}$</p></li></ul><h2 id="Lec-4-Factorization-into-A-LU"><a href="#Lec-4-Factorization-into-A-LU" class="headerlink" title="Lec 4 Factorization into A=LU"></a>Lec 4 Factorization into A=LU</h2><h3 id="4-1-Overview"><a href="#4-1-Overview" class="headerlink" title="4.1 Overview"></a>4.1 Overview</h3><p>本节课主要是结合了之前的消元矩阵和逆矩阵知识, 将矩阵 A 分解为下三角矩阵 L 和上三角矩阵 U.</p><h3 id="4-2-A-LU"><a href="#4-2-A-LU" class="headerlink" title="4.2 A=LU"></a>4.2 A=LU</h3><p>我们先通过消元矩阵将矩阵 <code>A</code> 转换为上三角矩阵 <code>U</code> 的形式:</p><p><img src="https://i.loli.net/2020/08/08/rXlMbtQ6zB7pJhk.png" alt="image-20200808130047836" style="zoom:10%;" /></p><p>根据之前所学的逆矩阵知识我们可知, 消元矩阵 $E_{21}$是可逆的(<strong>且不需要行的置换</strong>), 所以就有:</p><p><img src="https://i.loli.net/2020/08/08/xcTsiV3NX5nB2k9.png" alt="image-20200808130221621" style="zoom:20%;" /></p><p>那么我们为什么一定要消元矩阵做一次逆矩阵运算呢? 其实这主要是更加直观的反应消元所涉及的步骤:</p><p><img src="https://i.loli.net/2020/08/08/jWZU3oQLRfY7hxg.png" alt="image-20200808130622700" style="zoom:25%;" /></p><h2 id="Lec-5-Transpose-Permutation-and-Vector-Space"><a href="#Lec-5-Transpose-Permutation-and-Vector-Space" class="headerlink" title="Lec 5 Transpose, Permutation and Vector Space"></a>Lec 5 Transpose, Permutation and Vector Space</h2><h3 id="5-1-Overview"><a href="#5-1-Overview" class="headerlink" title="5.1 Overview"></a>5.1 Overview</h3><p>本节主要是关于我们之前已经有所涉及的置换矩阵, 矩阵的转置和对称矩阵并介绍一点向量空间.</p><h3 id="5-2-Permutation"><a href="#5-2-Permutation" class="headerlink" title="5.2 Permutation"></a>5.2 Permutation</h3><p>Permutation matrix is the identity matrix with reordered rows.</p><p>我们来看一个 3x3 的矩阵有多少个置换矩阵:</p><p><img src="https://i.loli.net/2020/08/08/p8MjkRL15gvXw6S.png" alt="image-20200808134204865" style="zoom:15%;" /></p><p>一共有 6 = 3! 个置换矩阵, 而且 if multiply any 2 of them together, the result is still in the group, and if inverse, the result is also still in the group.</p><p><img src="https://i.loli.net/2020/08/08/m53vwSoQBDsdir6.png" alt="image-20200808134355068" style="zoom:6%;" /></p><p>So, how about 4 x 4 Matrix? ==&gt; <strong>4! = 24 permutation matrices</strong></p><p>那么在进行矩阵分解的时候, 我们如果需要行的置换则可以表示为: </p><p>$PA=LU \ \ ==&gt; \ A=P^{-1}LU$</p><h3 id="5-3-Transpose"><a href="#5-3-Transpose" class="headerlink" title="5.3 Transpose"></a>5.3 Transpose</h3><p>转置比较简单 (需要一点几何想象能力)</p><p>$(A_{ij})^{T}=A_{ji}$</p><p>我们在这里主要是讲如何利用矩阵的转置来创建一个对称矩阵, 对称矩阵的含义是: $A^{T}=A$. 最简单的创建对称矩阵的办法就是: 原矩阵和其转置矩阵相乘.</p><p>$(RR^{T})^{T}=RR^{T}$</p><p><img src="https://i.loli.net/2020/08/08/ICcDBOS2JnfFogA.png" alt="image-20200808135336399" style="zoom:15%;" /></p><h3 id="5-4-Vector-Space"><a href="#5-4-Vector-Space" class="headerlink" title="5.4 Vector Space"></a>5.4 Vector Space</h3><p>This is only breif introduction of vector space. So what is vector space?</p><p><strong>Vector space</strong> is just a bunch of vectors!</p><p>For example:</p><p>​    $R^{2}$= All 2-D real vectors</p><p>​    $R^{3}$= All real vectors with 3 components</p><h3 id="5-5-Subspace"><a href="#5-5-Subspace" class="headerlink" title="5.5 Subspace"></a>5.5 Subspace</h3><p>So what is the subspace of a vector space?</p><p>subspace 的定义是, 该 subspace 里的任何向量在进行 <strong>Addition</strong> 和 <strong>Multiplication (by a scalar)</strong> 之后仍然在该 subspace 中. 数学表示为: <strong>cv + dw</strong>.</p><p>举两个例子:</p><ul><li><p>Subspaces of $R^{2}$</p><p>1) All of $R^{2}$, 也就是其本身</p><p>2) Any line through $\left|\begin{matrix}0\\0\end{matrix}\right|$</p><p>3) Zero vector only</p></li><li><p>Subspaces of $R^{3}$</p><p>1) All of $R^{3}$</p><p>2) Any line through the origin</p><p>3) Any plane through the origin</p><p>4) Zero vector only</p></li></ul><p>Ok, 在了解了 Subspace 的相关概念之后, 我们需要思考 How to create subspaces out of Matrix. 这里有两种方式:</p><ul><li><p><strong>From Columns</strong></p><p>Column space = C(A) = All the linear combinations of columns of  A</p></li><li><p><strong>From Rows</strong></p><p>Row space = All the linear combinations of rows of a matrix = C($A^{T}$) = Column space of $A^{T}$</p></li></ul><h2 id="Lec-6-Column-Space-and-Nullspacce"><a href="#Lec-6-Column-Space-and-Nullspacce" class="headerlink" title="Lec 6 Column Space and Nullspacce"></a>Lec 6 Column Space and Nullspacce</h2><h3 id="6-1-Overview"><a href="#6-1-Overview" class="headerlink" title="6.1 Overview"></a>6.1 Overview</h3><p>本节从之前学习的子空间开始, 介绍了子空间的部分性质. 并重点介绍了列空间与方程 Ax = b 之间的联系. 并由此引出了零空间, 根据 Ax = b 这个方程给出了两种构建子空间的方法.</p><h3 id="6-2-Union-and-Intersection-of-Subspaces"><a href="#6-2-Union-and-Intersection-of-Subspaces" class="headerlink" title="6.2 Union and Intersection of Subspaces"></a>6.2 Union and Intersection of Subspaces</h3><p>我们假设 <code>P</code> 和 <code>L</code> 是$R^{3}$的两个 subspaces, 那么 $P\cup L$ = All vectors in P or L or both.</p><p>那么问题来了:</p><p>1) Is $P\cup L$ a subspace? ==&gt; <strong>No!</strong></p><p>2) Is $P \cap L$ a subspace? ==&gt; <strong>Yes!</strong></p><p>This conclusion will be used in lec 10.</p><h3 id="6-3-Column-Space-of-A"><a href="#6-3-Column-Space-of-A" class="headerlink" title="6.3 Column Space of A"></a>6.3 Column Space of A</h3><p>我们用一个例子来回顾一下上一节所讲述的列空间知识.</p><p>现有矩阵 A = $\left|\begin{matrix}1&amp;1&amp;2\\2&amp;1&amp;3\\3&amp;1&amp;4\\4&amp;1&amp;5\end{matrix}\right|$, 矩阵的列向量$\left|\begin{matrix}1\\2\\3\\4\end{matrix}\right|$,$\left|\begin{matrix}1\\1\\1\\1\end{matrix}\right|$,$\left|\begin{matrix}2\\3\\4\\5\end{matrix}\right|$均是$R^{4}$中的四维向量, 所以 A 的列空间是 $R^{4}$的子空间. 除了包含以上三个列向量, 该矩阵的列空间还包括这个三个列向量的各种线性组合.</p><p>那么这个列空间有多大呢? 这就需要 <code>Ax = b</code> 方程来解释了. </p><p>还是取上面那个 A, 且 Ax = $\left|\begin{matrix}1&amp;1&amp;2\\2&amp;1&amp;3\\3&amp;1&amp;4\\4&amp;1&amp;5\end{matrix}\right|$$\left|\begin{matrix}x_1\\x_2\\x_3\end{matrix}\right|$=$\left|\begin{matrix}b_1\\b_2\\b_3\\b_4\end{matrix}\right|$=b. </p><p><strong>Question 1:</strong> Does Ax = b has a solution for every b? </p><p>The answer is no! 我们换一种问法, 问同样的问题, Do the linear combinations of columns of Matrix A fill up 4-D space? 很明显答案是 No, 因为三个四维向量的线性组合是无法铺满整个四维空间的, 就如同两个三维向量无法张开一个三维空间一样.</p><p><strong>Question 2:</strong> Which b allow us to solve Ax = b?</p><p>Ax 就表示着 A 列向量的所有线性组合, 也就是 A 的列空间. 上面提到空 C(A)就是$R^{4}$的一个子空间, 所谓对于一个四维向量 b, 只要 b 在”A 的列空间”这个 $R^{4}$的子空间中, 那么就可以找到一种矩阵 A 的列向量的线性组合来构成 b. 也就是使得 <code>Ax = b</code> 有解.</p><p><strong>Question 3:</strong> If we remove one column from Matrix A, will the C(A) be affected?</p><p>观测三个列向量, 我们不难发现第三列是前两节的和, 也就是说第三列对线性组合没有贡献. 所以我们仅仅依靠前两列的线性组合就可以构成 A 的列空间. 我们称$\left|\begin{matrix}1\\2\\3\\4\end{matrix}\right|$,$\left|\begin{matrix}1\\1\\1\\1\end{matrix}\right|$这样的列为主列.</p><h3 id="6-4-Nullspace"><a href="#6-4-Nullspace" class="headerlink" title="6.4 Nullspace"></a>6.4 Nullspace</h3><p>所谓的零空间, 就是 <code>Ax = 0</code> 的所有解所构成的一个空间.</p><p>还是以上面的矩阵 A 为例, 其零空间就是下面这个方程的解所构成的空间:</p><p>Ax = $\left|\begin{matrix}1&amp;1&amp;2\\2&amp;1&amp;3\\3&amp;1&amp;4\\4&amp;1&amp;5\end{matrix}\right|$$\left|\begin{matrix}x_1\\x_2\\x_3\end{matrix}\right|$=$\left|\begin{matrix}0\\0\\0\\0\end{matrix}\right|$, 也就是 x = $\left|\begin{matrix}x_1\\x_2\\x_3\end{matrix}\right|$, 可以看到 x 有 3 个 components, 所以其零空间是 $R^{3}$ 的子空间. 所以对于 m*n 的矩阵而言, 列空间是$R^{m}$的子空间, 零空间是$R^{n}$的子空间.</p><p><img src="https://i.loli.net/2020/08/08/bQL95cO43IPypum.png" alt="image-20200808152414709" style="zoom:20%;" /></p><h2 id="Lec-7-Solving-Ax-0-Pivot-Variables-and-Special-Solutions"><a href="#Lec-7-Solving-Ax-0-Pivot-Variables-and-Special-Solutions" class="headerlink" title="Lec 7 Solving Ax = 0: Pivot Variables and Special Solutions"></a>Lec 7 Solving Ax = 0: Pivot Variables and Special Solutions</h2><h3 id="7-1-Overview"><a href="#7-1-Overview" class="headerlink" title="7.1 Overview"></a>7.1 Overview</h3><p>上一个 lecture 中, 我们讨论了零空间的相关问题, 这一节我们主要是从定义过渡到 <code>Nullspace</code> 的计算, 即如何求解这些空间的一般形式. 给出一种可以解出 <code>Ax = 0</code> 中的 x 构成的零空间的算法.</p><h3 id="7-2-Algorithm"><a href="#7-2-Algorithm" class="headerlink" title="7.2 Algorithm"></a>7.2 Algorithm</h3><p><strong>Step 1:</strong> Do elimination</p><p><strong>Step 2:</strong> Find pivot and free columns</p><p><strong>Step 3:</strong> Assign value to free variables (1 or 0)</p><p><strong>Step 4:</strong> Back substitution</p><p><img src="https://i.loli.net/2020/08/08/GZBiv87OADC4nbV.png" alt="image-20200808153614099" style="zoom:40%;" /></p><h3 id="7-3-RREF"><a href="#7-3-RREF" class="headerlink" title="7.3 RREF"></a>7.3 RREF</h3><p><strong>简化行阶梯形式 (Reduced Row Echelon Form)</strong></p><p><img src="https://i.loli.net/2020/08/08/98XJgxjfRCbn3PO.png" alt="image-20200808153842841" style="zoom:10%;" /></p><h2 id="Lec-8-Solving-Ax-b"><a href="#Lec-8-Solving-Ax-b" class="headerlink" title="Lec 8 Solving Ax = b"></a>Lec 8 Solving Ax = b</h2><h3 id="8-1-Overview"><a href="#8-1-Overview" class="headerlink" title="8.1 Overview"></a>8.1 Overview</h3><p>这一节我们主要研究 <code>Ax = b</code> 的一般求解方法以及有解条件. 并总结出 rank (秩) 对不同形式方程的解的影响.</p><h3 id="8-2-Ax-b"><a href="#8-2-Ax-b" class="headerlink" title="8.2 Ax = b"></a>8.2 Ax = b</h3><p>我们先通过一个例子来研究 <code>Ax = b</code> 的可接条件:</p><p><img src="https://i.loli.net/2020/08/08/oGFiI5ks3WXt6On.png" alt="image-20200808155914163" style="zoom:18%;" /></p><p>很明显, 要保证该方程组有解, 必须满足 $b_3-b_2-b_1=0$. 再看这个条件, 它反映了一种线性组合特点, 即 b 向量的第三个分量是前两个分量之和. 反过来看 A 矩阵本身的特点, 发现 A 矩阵第三行也是前两行的和. 我们之前说过, <code>Ax = b</code> 有解的条件是 b 在 A 的列空间中. 这个例子再一次印证了这个条件.</p><p>所以我们可以归纳出, <code>Ax = b</code> 的条件:</p><ul><li>b is in the column space of A</li><li>If a combination of rows of A give a zero row, then the same combination of entries of b must give 0</li></ul><h3 id="8-3-Algorithm"><a href="#8-3-Algorithm" class="headerlink" title="8.3 Algorithm"></a>8.3 Algorithm</h3><p>现在给出求解 Ax = b 的一般算法:</p><p><strong>Step 1:</strong> Find one particular solution ($x_p$), we can do this by setting all free variables to 0, then solve Ax = b for pivot variables</p><p><strong>Step 2:</strong> Find the nullspace ($x_n$)</p><p><strong>Step 3:</strong> x = $x_p + x_n$</p><p>我们来验证一下:</p><p>$A(x_p+x_n)=Ax_p+Ax_n=b+0=b$</p><h3 id="8-4-Rank-and-Solution"><a href="#8-4-Rank-and-Solution" class="headerlink" title="8.4 Rank and Solution"></a>8.4 Rank and Solution</h3><p>这个非常重要!!!</p><p>前提: $A_{m\times n}$, rank = r, and r &lt;= m, r &lt;= n</p><p><strong>1) Full Column Rank</strong></p><p>因为列满秩, 即 r = n 且 m &gt;= n, 所以该矩阵没有 free variables. 这意味着:</p><ul><li>该矩阵的零空间 <strong>N(A) = zero vector</strong></li><li>Solution to Ax = b 如果存在那么只有一个解, 即 Ax = b 有 <strong>0 or 1</strong> 个解</li></ul><p><strong>2) Full Row Rank</strong></p><p>因为行满秩, 即 r = m 且 n &gt;= m, 那么在进行消元之后, 矩阵一定没有 zero row, 这意味对 b 没有要求, 所以 <strong>Ax = b has solution for every b</strong>, 即 Ax = n 有 1 or $\infty$ 个解.</p><p><strong>3) r = m = n</strong></p><p>由前面两个情况可知, r = m = n 意味着, Ax = b 有且只有一个解, 且一定可逆.</p><p><strong>4) r &lt; m, r &lt; n</strong></p><p>此时, Row Reduced Form 是 $R = \left|\begin{matrix}I&amp;F\\0&amp;0\end{matrix}\right|$, 很明显此时要么无解, 要么有无穷多解.</p><h2 id="Lec-9-Independence-Basis-and-Dimension"><a href="#Lec-9-Independence-Basis-and-Dimension" class="headerlink" title="Lec 9 Independence, Basis and Dimension"></a>Lec 9 Independence, Basis and Dimension</h2><h3 id="9-1-Overview"><a href="#9-1-Overview" class="headerlink" title="9.1 Overview"></a>9.1 Overview</h3><p>之前通过消元法处理矩阵的时候, 我们有时会发现矩阵中的某一列是其他几列的线性组合的情况. 这一节就主要关于介绍线性相关或不相关性, 并引入向量空间的两个重要概念: 基 (Basis) 和 维数 (Dimension).</p><h3 id="9-2-Independence"><a href="#9-2-Independence" class="headerlink" title="9.2 Independence"></a>9.2 Independence</h3><p>Vectors $x_1,x_2,…,x_n$ are linear independent if:</p><ul><li>No linear combination gives zero vector (except zero comb)</li><li>Rank = n, which means there’s no free varible. ==&gt; N(A) = zero vector</li></ul><p>其余情况都是线性相关.</p><p>噢对了, <strong>扁平型</strong>的矩阵即对于$A_{m \times n}$而言, m &lt; n. 那么Columns of A 一定是线性相关的. 为什么? 因为 There are non-zero solutions to Ax = 0 since there will be free variables.</p><h3 id="9-3-Span"><a href="#9-3-Span" class="headerlink" title="9.3 Span"></a>9.3 Span</h3><p>Vectors $x_1,x_2,…,x_n$ span a space means: the space consists of all linear combinations of those vectors.</p><h3 id="9-4-Basis"><a href="#9-4-Basis" class="headerlink" title="9.4 Basis"></a>9.4 Basis</h3><p>Basis for a space is a sequence of vectors $x_1,x_2,…,x_n$ with two properties:</p><ul><li>They are linear independent</li><li>They span the space</li></ul><p>我们来看一个例子:</p><p>​    Space is $R^{3}$.</p><p>​    So one basis is $\left|\begin{matrix}1\\0\\0\end{matrix}\right|$,$\left|\begin{matrix}0\\1\\0\end{matrix}\right|$,$\left|\begin{matrix}0\\0\\1\end{matrix}\right|$; Another basis is $\left|\begin{matrix}1\\1\\2\end{matrix}\right|$,$\left|\begin{matrix}2\\2\\5\end{matrix}\right|$,$\left|\begin{matrix}3\\1\\4\end{matrix}\right|$.</p><p><strong>一个重要结论:</strong></p><p>For $R^{n}$, n vectors give basis if the nxn matrix with those columns being invertible. 我们可以这样理解: 从线性变换的角度来看, 逆矩阵可理解为原矩阵的反向变换, 比如一个向量被顺时针旋转 90 度, 那么逆矩阵就可以将其逆时针还原 90 度. 然而对于没有满秩的矩阵进行线性变换会导致降维, 试想一下3 维空间被拍平成 2 维矩阵能被还原吗?</p><h3 id="9-5-Dimension"><a href="#9-5-Dimension" class="headerlink" title="9.5 Dimension"></a>9.5 Dimension</h3><p>Given a space, every basis for the space has the same number of vectors. The number is the <strong>dimension</strong> of the space.</p><h2 id="Lec-10-The-Four-Fundamental-Subspaces"><a href="#Lec-10-The-Four-Fundamental-Subspaces" class="headerlink" title="Lec 10 The Four Fundamental Subspaces"></a>Lec 10 The Four Fundamental Subspaces</h2><h3 id="10-1-Overview"><a href="#10-1-Overview" class="headerlink" title="10.1 Overview"></a>10.1 Overview</h3><p>这一节我们介绍四个基本子空间, 这是线性代数的核心部分, 非常重要!!!</p><p>Suppose A is a m by n matrix, the four fundamental subspaces are:</p><ul><li>Column Space <strong>C(A)</strong> $⇒$ subspace in $R^{m}$</li><li>Nullspace <strong>N(A)</strong> $\Rightarrow$ subspace in $R^{n}$</li><li>Row Space <strong>C($A^T$)</strong> $⇒$ subspace in $R^n$</li><li>Nullsapce of $A^T$ <strong>N($A^T$)</strong> $⇒$ subspace in $R^{m}$</li></ul><p><img src="https://i.loli.net/2020/08/08/pHxiA1RS6gqmuBN.png" alt="image-20200808181618634"></p><h3 id="10-2-Column-Space"><a href="#10-2-Column-Space" class="headerlink" title="10.2 Column Space"></a>10.2 Column Space</h3><p>列空间是矩阵 A 的列向量线性组合所构成的空间. 对于$A_{m \times n}$而言, 每个列有 m 个分向量, 因此列空间是$R^{m}$的子空间.</p><p>设矩阵的秩为 r, 则 A 有 r 个主列, 这 r 个主列就是列空间 C(A) 的一组基, 一组基里面有 r 个向量, 所以列空间维数为 r.</p><ul><li>rank(A) = r</li><li>basis = pivot columns</li><li>dim(C(A)) = r</li></ul><h3 id="10-3-Nullspace"><a href="#10-3-Nullspace" class="headerlink" title="10.3 Nullspace"></a>10.3 Nullspace</h3><p>零空间即 <code>Ax = 0</code> 的解所构成的空间. 由于 x 本质是对矩阵 A 进行线性组合, A 一共有 n 个列向量, 所以 Nullspace 是$R^{n}$的子空间.</p><p>当矩阵 A 的秩为 r 时, 矩阵 A 有 n-r 个free columns, 即 x 中有 n-r 个 free variables. 这意味着 <code>Ax = 0</code> 有 n-r 个特殊解.所以:</p><ul><li>rank(A) = r</li><li>basis = special solutions for Ax = 0</li><li>dimension(N(A)) = n - r</li></ul><h3 id="10-4-Row-Space"><a href="#10-4-Row-Space" class="headerlink" title="10.4 Row Space"></a>10.4 Row Space</h3><p>类似列空间, 行空间就是矩阵 A 各行的线性组合所组成的子空间, 也可以理解为 A 的转置矩阵的列空间, 即 C($A^T$). A 的每个行向量都有 n 个分量, 所以行空间是$R^n$的子空间.</p><p>A 的行空间可以转化为 $A^T$ 的列空间. 但我们这里还是直接对 A 的行向量进行线性变换来研究行空间的 basis 和 dimension.</p><p><img src="https://i.loli.net/2020/08/08/siHydwEuKj3vDcx.png" alt="image-20200808181808928" style="zoom:15%;" /></p><p>从这个例子我们知道:</p><ul><li>rank(A) = r</li><li>basis = first r rows of R</li><li>dim(C($A^T$) = r</li></ul><h3 id="10-5-Left-Nullspace"><a href="#10-5-Left-Nullspace" class="headerlink" title="10.5 Left Nullspace"></a>10.5 Left Nullspace</h3><p>左零空间即矩阵 A 的转置矩阵的零空间: N($A^T$)</p><p>So 为什么它被称为左零空间?</p><p><img src="https://i.loli.net/2020/08/08/8nXPd34V2uQ5s9e.png" alt="image-20200808182406994" style="zoom:10%;" /></p><p>那么 basis 和 dimension 呢? 我们看下面这个图:</p><p><img src="https://i.loli.net/2020/08/08/BFuMecEPJRXmybD.png" alt="image-20200808183123112" style="zoom:20%;" /></p><p>我们不难发现, 在 A 变化到 R 之后, 有一行全是 0, 即说明经过A 的行经过某种线性组合之后, 得到了zero vector, 而造成这种变化的向量即是 Left Nullspace, 也就是 上图中 E 矩阵的第三行. 那么如何得到 E 矩阵呢? 我们就要用到之前介绍过的 Gauss-Jordan Idea, 这里我就不再赘述了.</p><h3 id="10-6-Extension-of-Thoughts"><a href="#10-6-Extension-of-Thoughts" class="headerlink" title="10.6 Extension of Thoughts"></a>10.6 Extension of Thoughts</h3><blockquote><p>  From Vectors to Matrices</p></blockquote><p>Let’s suppose all 3x3 matrices form a new “vector” space M.</p><p>Some subspaces of M:</p><ul><li>Upper Triangular Matrix</li><li>Symmetric Matrix</li><li>Diagonal Matrix</li></ul><p>So what’s the dimension of these subspace?</p><p><img src="https://i.loli.net/2020/08/08/zPhNSdoKk3UvBYZ.png" alt="image-20200808185010765" style="zoom:10%;" /></p><h2 id="Lec-11-Matrix-Space-Rank-1-Small-World-Graph"><a href="#Lec-11-Matrix-Space-Rank-1-Small-World-Graph" class="headerlink" title="Lec  11 Matrix Space: Rank 1, Small World Graph"></a>Lec  11 Matrix Space: Rank 1, Small World Graph</h2><h3 id="11-1-Overview"><a href="#11-1-Overview" class="headerlink" title="11.1 Overview"></a>11.1 Overview</h3><p>本节我们将承接上文所讲的矩阵空间, 研究矩阵空间的维数和基数等问题. 本节也会介绍秩为 1 的矩阵特点. 并引入图论.</p><h3 id="11-2-Matrix-Space"><a href="#11-2-Matrix-Space" class="headerlink" title="11.2 Matrix Space"></a>11.2 Matrix Space</h3><p>我们将所有 3x3 的矩阵都看作”向量空间”中的元素. 很明显, 由所有 3x3 矩阵构成的集合中, 矩阵之间的 Addition 和 Multiplication 都是封闭的, 所以所有 3x3 矩阵构成的集合 M 可以被称为空间.</p><p>上文也介绍过, M有三个基本子空间:</p><ul><li>Upper Triangular Matrix</li><li>Symmetric Matrix</li><li>Diagonal Matrix</li></ul><p>很明显矩阵空间 M 的维度为 9, basis 如下所示:</p><p><img src="https://i.loli.net/2020/08/09/RlYZfi71ITs86WV.png" alt="image-20200809095011923" style="zoom:10%;" /></p><p>那么问题来了: 上面的基本子空间的维数是什么呢?</p><ul><li><p><strong>Upper Triangular Matrix:</strong> 6</p><p><img src="https://i.loli.net/2020/08/09/tpyhugG1J38X7Qi.png" alt="image-20200809095306456"></p></li><li><p><strong>Symmetric Matrix:</strong> 6</p><p><img src="https://i.loli.net/2020/08/09/KqDQ1z5bBw7d8Te.png" alt="image-20200809095337705"></p></li><li><p><strong>Diagonal Matrix:</strong> 3</p><p><img src="https://i.loli.net/2020/08/09/WlYsAcwD3JXqv9i.png" alt="image-20200809095426052"></p></li></ul><p>我们之前讨论过两个 subspace 的交集也是 subspace, 正如这里的 Diagonal Matrix 就是 U 和 S 的交集. 那么并集呢? 我们说过并集并不是 subspace. 但是有一个概念不是并集但总容易搞混那就是 <strong>Sum of Two Subspaces</strong>. 很明显 S + U = M!!! 所以:</p><ul><li><p>$dim(S+U)=9$ </p></li><li><p>$dim(S)+dim(U)=dim(S+U)+dim(S\cap U)$</p></li></ul><h3 id="11-3-Rank-1-Matrix"><a href="#11-3-Rank-1-Matrix" class="headerlink" title="11.3 Rank 1 Matrix"></a>11.3 Rank 1 Matrix</h3><p>研究秩 1 矩阵的原因</p><ul><li>它易于分解.</li></ul><p><img src="https://i.loli.net/2020/08/09/6wKlWmCbVLx4fJh.png" alt="image-20200809100313788" style="zoom:25%;" /></p><ul><li><p>用于搭建其他矩阵</p><p>比如秩为 4 的矩阵可以通过四个秩一矩阵就能搭建出来. 具体过程类似于矩阵乘法中的”列乘行”形式, 通过一列一行搭出一个矩阵.</p></li></ul><p><strong>我们来思考一个问题:</strong> </p><p>所有秩为 4 的矩阵构成的集合 M, 能被称之为空间吗? 答案是 No! 比较简单的原因是其不包括零向量, 此外还因为: $R(A+B)\leq R(A)+R(B)$.</p><p><strong>我们再思考另外一个问题来加深对子空间的理解:</strong> </p><p>在四维空间中的每个向量都有四个分量 v = $\left|\begin{matrix}v_1\\v_2\\v_3\\v_4\end{matrix}\right|$, 设 S 为一个集合, 其中的向量都满足: $v_1+v_2+v_3+v_4=0$. 那么请思考 S 是不是一个子空间? 若是, 其维度是多少?</p><p>很明显 S 是一个子空间, $v_1+v_2+v_3+v_4=0$ 这个条件对 Addition 和 Multiplication 都封闭. 而且 S 中肯定有零向量. 我们也可以用另一种方式来理解: 不难发现 S 是线性方程组 <code>Ax = 0</code> 的零空间, where <code>A = [1, 1, 1, 1]</code>. 所以dim = 3 = n - r, 其基为 Ax = 0 的三个特解 (free variables). 至于左零空间 N($A^T$): A的左零空间即是线性组合各行得到零向量的方式. 很显然, 这个 A 得左零空间只有零向量.</p><h3 id="11-4-Small-World-Graph"><a href="#11-4-Small-World-Graph" class="headerlink" title="11.4 Small World Graph"></a>11.4 Small World Graph</h3><p><img src="https://i.loli.net/2020/08/09/PYEB8dWSrQCFolM.png" alt="image-20200809102742261" style="zoom:15%;" /></p><h2 id="Lec-12-Graphs-Networks-and-Incidence-Matrices"><a href="#Lec-12-Graphs-Networks-and-Incidence-Matrices" class="headerlink" title="Lec 12 Graphs, Networks and Incidence Matrices"></a>Lec 12 Graphs, Networks and Incidence Matrices</h2><h3 id="12-1-Overview"><a href="#12-1-Overview" class="headerlink" title="12.1 Overview"></a>12.1 Overview</h3><p>本节主要介绍图和矩阵之间的关联, 并利用矩阵说明图的特点. 这一节与之前几节的区别主要在于, 前面例子中的矩阵中的元素大都是为了说明性质编造出来的, 而本节中矩阵中的元素都是来源于实际问题, 更能体现出我们之前介绍的性质在实际问题中有什么作用.</p><h3 id="12-2-Graphs-and-Incidence-Matrices"><a href="#12-2-Graphs-and-Incidence-Matrices" class="headerlink" title="12.2 Graphs and Incidence Matrices"></a>12.2 Graphs and Incidence Matrices</h3><p>我们先给出一个 Graph 和其关联矩阵 (Incidence Matrix):</p><p><img src="https://i.loli.net/2020/08/09/sLlSM9dvz7p6DB2.png" alt="image-20200809104215371" style="zoom:25%;" /></p><p>先简单介绍一下上面的 5x4 的关联矩阵:</p><ul><li>每一列代表一个node</li><li>每一行代表一条edge 的走势, 该 edge 以哪一个node 为起点, 对于的矩阵中该元素为 -1, 而以哪个 node 为终点, 对应矩阵中该元素为 1.</li></ul><p>Ok, 在有些基本了解之后, 我们来研究一下图和矩阵所代表的实际意义. 我们假设 x 为每个 Node 上的电势, 研究 <code>Ax = b</code> 形式下, 我们能得到什么定律!</p><p><img src="https://i.loli.net/2020/08/09/sH6jiy3t5CpOAx1.png" alt="image-20200809114441365"></p><p>1) 首先我们研究 b 是零向量, 也就是Ax 构成的 Nullspace 的情况, 这时我们要求 <code>Ax = 0</code>. 基于我们之前所学的知识, 我们不难得到, 当 b = 0 时, 图上各点的电势必须相等. 我们知道, 电势差和电流的形成有直接关系, b = 0 说明我们求解的情况是各个边上都没有电流, 而我们最后解得, 各点电势相等时, 各边电流为 0, 这符合我们初中学的物理学常识.</p><p>2) 那么如果 b 不等于 0 呢? 我们可以通过 $X_p+X_n$ 的情况求出不同 b 的情况下方程所对应的解, 代表着不同电势差下, 各点电势的大小.</p><p>各边的电流为 $y_1,y_2,y_3,y_4,y_4$, 接下来我们来看一下左零空间 $A^Ty=0$有什么特点. 注意上面我们得到的结果:</p><ul><li>$-y_1-y_3-y_4=0$</li><li>$y_1-y_2=0$</li><li>$y_2+y_3-y_5=0$</li><li>$y_4+y_5=0$</li></ul><p>这个结果阐述了一个定律 ===&gt; Kirchoff’s Current Law (基尔霍夫定律), 即每个 Node 流入流出电流相同. 然后引入一个电阻系数矩阵, 我们就可以得到教授最后引入外加电源的影响的公式:</p><p><img src="https://i.loli.net/2020/08/09/XczIEsNPwL9k7xr.png" alt="image-20200809120134440" style="zoom:6%;" /></p><h3 id="12-3-Tree"><a href="#12-3-Tree" class="headerlink" title="12.3 Tree"></a>12.3 Tree</h3><p>Tree 就是 Graph with no loops.</p><h2 id="Lec-13-Orthogonal-Vectors-and-Subspaces"><a href="#Lec-13-Orthogonal-Vectors-and-Subspaces" class="headerlink" title="Lec 13 Orthogonal Vectors and Subspaces"></a>Lec 13 Orthogonal Vectors and Subspaces</h2><h3 id="13-1-Overview"><a href="#13-1-Overview" class="headerlink" title="13.1 Overview"></a>13.1 Overview</h3><p>这一节我们还是研究四个基本子空间, 但是我们本节主要从正交的角度来探讨这些空间具有的性质和正交向量的特点等.</p><h3 id="13-2-Orthogonal-Vectors"><a href="#13-2-Orthogonal-Vectors" class="headerlink" title="13.2 Orthogonal Vectors"></a>13.2 Orthogonal Vectors</h3><p>我们首先了解一下正交的概念, 在线性代数中, 正交即垂直:</p><p><img src="https://i.loli.net/2020/08/09/73GJVI59jSAMPuz.png" alt="image-20200809121228627" style="zoom:20%;" /></p><h3 id="13-3-Orthogonal-Subspaces"><a href="#13-3-Orthogonal-Subspaces" class="headerlink" title="13.3 Orthogonal Subspaces"></a>13.3 Orthogonal Subspaces</h3><p><img src="https://i.loli.net/2020/08/09/IQPe5VLgwWx79ik.png" alt="image-20200809120920895" style="zoom:25%;" /></p><p>ok 在介绍完向量正交之后, 我们来了解一下空间正交. <code>Orthogonal Spaces</code> 则是指: <strong>Every vector in S is orthogonal to every vector in T.</strong> 这里有一个问题要注意一下, 这个例子特别容易搞混淆, <strong>黑板与地面的两个平面的子空间并不正交</strong>, 因为这两个平面有交线, 而这个交线无法满足空间正交的定义. 这也提醒了我们: 两个平面在某一非零向量处相相交, 那么这两个平面一定不正交. </p><p>说了这么多们来看一下子空间正交的简单例子:</p><p>以 $R^2$ 的子空间为例, 两个相交的子空间为两条 L 在原点处互相垂直.</p><p><strong>Row Space is orthogonal to Nullspace</strong>, <strong>Why?</strong></p><p>我们看一下 <code>Ax = 0</code>, 这里的解是 Nullspace, 而 x 与 A 的每一行点乘均为 0. 我们再引入一个概念: <strong>Nullspace 和 Row Space 的关系类似于将一个空间一分为二的两个子空间.</strong> 从上图可以发现行空间和列空间的维数之和正好为 n. 我们来看个例子:</p><p><img src="https://i.loli.net/2020/08/09/7iz2wemBlqGh6oj.png" alt="image-20200809123132921"></p><p>在这个例子中, A 的行空间是 1 维的, 而对应零空间是(3-1=2)二维的, 可以理解为垂直于向量(1,2,5) 的一个平面. </p><p><strong>注: 这里做一个更正, 矩阵相乘的结果是 $\left|\begin{matrix}0\\0\end{matrix}\right|$</strong></p><h3 id="13-4-Solve-Ax-b-When-There-is-No-Solution"><a href="#13-4-Solve-Ax-b-When-There-is-No-Solution" class="headerlink" title="13.4 Solve Ax = b When There is No Solution"></a>13.4 Solve Ax = b When There is No Solution</h3><p>在上一节电流电势的应用分析中, 我们了解到矩阵的数据多来源于实际测量, 那么就势必会有测量不准确的情况. 例如有时候我们求解 <code>Ax = b</code> 方程时, 如果 A 的行数太多, 那么其中就很有可能混进去一些不准确的数据. 这时我们以往的手段求解方程并不会求出准确的解, 这就引出了我们这部分内容.</p><p>既然无法求出解, 那么我们就用一些手段求出方程的<strong>最优解 (Best Solution)</strong>, 类似于一种拟合. 大致如下:</p><p><img src="https://i.loli.net/2020/08/09/vZcroI7DPx6peky.png" alt="image-20200809131037994" style="zoom:12%;" /></p><p>这部分我们利用了 $A^TA$ 矩阵的特殊性质:</p><p><img src="https://i.loli.net/2020/08/09/QUsNJ4cdBRm5bzC.png" alt="image-20200809131137750" style="zoom:8%;" /></p><p>这样我们就能构造出一个新矩阵: $A^TA$, 并利用该矩阵求出最优解. 但我们需要注意新矩阵 $A^TA$ 并不总是可逆的, 所以在在求解时需要注意 A 的特点. 很明显当矩阵 A 列向量线性相关的时候, $A^TA$ 就不可逆了.</p><p><img src="https://i.loli.net/2020/08/09/dKyCsrpamnY8B59.png" alt="image-20200809131410599"></p><p>那么 $A^TA$ 的可逆的判断依据是什么呢?</p><p><img src="https://i.loli.net/2020/08/09/xdeRVU1CmLjXc8n.png" alt="image-20200809131510872" style="zoom:15%;" /></p><p>具体的证明会在下一节详解. 这里我们得出一个结论, 在求最优解的时候要首先判断 A 的列向量之间是否线性无关, 再进行求解.</p><h2 id="Lec-14-Projections-on-Subspaces"><a href="#Lec-14-Projections-on-Subspaces" class="headerlink" title="Lec 14 Projections on Subspaces"></a>Lec 14 Projections on Subspaces</h2><h3 id="14-1-Overview"><a href="#14-1-Overview" class="headerlink" title="14.1 Overview"></a>14.1 Overview</h3><p>这一节主要是关于投影 (Projection), 从向量的投影入手, 并延伸到高维投影. 至于为什么用投影!!! 我们在上节内容有讲存在矩阵的行过多无法求解的情况, 这个时候我们需要求最优解. 我们就需要将 <code>b</code> 投影到矩阵 <code>A</code> 的Column Space 上来求一个最优解.</p><h3 id="14-2-Vector-Projection"><a href="#14-2-Vector-Projection" class="headerlink" title="14.2 Vector Projection"></a>14.2 Vector Projection</h3><p>如图所示, 向量 p 是向量 b 在 a 上的投影, 我们注意到向量 p 是向量 a 的倍数, 即 <code>p = xa</code>. 而投影得到的向量 p 和原向量 b 之间的误差是 <code>e = b - p</code>. 同时投影得到的向量 p 也可以直接通过一个投影矩阵 <strong>(Projection Matrix)</strong>, 从 b 变换为 p, 即 <code>p = Pb</code>.</p><p><img src="https://i.loli.net/2020/08/10/XAjogfneCxcbpG6.png" alt="image-20200810122505319" style="zoom:20%;" /></p><p>从上图可知, 误差向量 e 是垂直于向量 a 的, 因此 $a^T(b-xa)=0$, 经过一定代数变化之后, 我们不难得到 $x=\frac{a^Tb}{a^Ta}$. 那么 $p=xa=\frac{a^Tb}{a^Ta}a=Pb$, 因此投影矩阵为 $P=\frac{aa^T}{a^Ta}$. 如图所示:</p><p><img src="https://i.loli.net/2020/08/10/EVi34hZb1D2w8eA.png" alt="image-20200810123019329" style="zoom:20%;" /></p><p>我们再来看看投影矩阵 P 的几个性质:</p><ul><li>基于 <strong>Lec 11</strong> 中的知识点, 我们知道在上图的情况下, 投影矩阵的秩为 1, 而且其列空间为 Line through vector a</li><li>$P^T=P$, since $aa^t$ 是对称矩阵</li><li>$P^2=P$, since 二次投影的结果就是一次投影的结果.</li></ul><h3 id="14-3-General-Projection"><a href="#14-3-General-Projection" class="headerlink" title="14.3 General Projection"></a>14.3 General Projection</h3><p>我们还是从一个例子入手, 下图中$a_1,a_2$是构成平面的一组基, 向量 p 是向量 b 在平面上的投影.  如图所示</p><p><img src="https://i.loli.net/2020/08/10/x1RXVnrhwDE8JlW.png" alt="image-20200810124820990" style="zoom:25%;" /></p><p>现在 $Ax = b$ 的问题已经转换为求解 $A\hat{x}=p$ 的问题.</p><p><img src="https://i.loli.net/2020/08/10/oShptvk7e5ZJX8j.png" alt="image-20200810125544175"></p><p>我们得到了 $A^T(b-A\hat{x})=0$, 而且也验证了误差向量 <code>e</code> 是在矩阵 A 的左零空间里, 而且垂直于矩阵 A 的列空间, 也就是我们的平面. 我们做进一步推导:</p><p><img src="https://i.loli.net/2020/08/10/kAMvJ8UyFRcuDhs.png" alt="image-20200810130008561" style="zoom:20%;" /></p><p>值得一提的是最后我们得到的投影矩阵是 $P=A(A^TA)^{-1}A^T$, 注意这里不可消!!! 因为矩阵 A 并不是一个方阵, 其没有逆矩阵. 加入矩阵 A 是方阵, 那么投影矩阵就是单位矩阵, 等于自身投影到自身. 而且这里的投影矩阵也有着相同的两个性质:</p><ul><li>$P^T=(A(A^TA)^{-1}A^T)^T=A(A^TA)^{-1}A^T=P$</li><li>$P^2=P$</li></ul><h3 id="14-4-Introduction-to-Least-Squares"><a href="#14-4-Introduction-to-Least-Squares" class="headerlink" title="14.4 Introduction to Least Squares"></a>14.4 Introduction to Least Squares</h3><p><img src="https://i.loli.net/2020/08/10/qIk76gxjPulnS12.png" alt="image-20200810130925681" style="zoom:20%;" /></p><h2 id="Lec-15-Projection-Matrices-and-Least-Squares"><a href="#Lec-15-Projection-Matrices-and-Least-Squares" class="headerlink" title="Lec 15 Projection Matrices and Least Squares"></a>Lec 15 Projection Matrices and Least Squares</h2><h3 id="15-1-Overview"><a href="#15-1-Overview" class="headerlink" title="15.1 Overview"></a>15.1 Overview</h3><p>这一节主要是讲最小二乘法, 并对上一节中的投影进行更叫深入的研究. 在上一节的最后一部分我们可以知道, 其实最小二乘法就是一种投影, 保证了误差最小 (最优解). 另外, 投影也与列空间和矩阵的左零空间有关.</p><h3 id="15-2-Review-on-Projection-Matrices"><a href="#15-2-Review-on-Projection-Matrices" class="headerlink" title="15.2 Review on Projection Matrices"></a>15.2 Review on Projection Matrices</h3><p><strong>对了, 我们在上一节和这一节的假设都是 $A^TA$ 是可逆的.</strong> </p><p><strong>我们已经知道投影矩阵 $P=A(A^TA)^{-1}A^T$. 投影矩阵 P 是将 vector b 投影到矩阵 A 的列空间上!!!</strong></p><ul><li><p><strong>If b in column space of A, Pb = b</strong></p><p>如果向量 b 在矩阵 A 的列空间里面, 那么一定存在一个 x 使得 <code>Ax = b</code>, 将之带入 <code>Pb</code> 我们可以得到, $Pb=A(A^TA)^{-1}A^TAx=Ax=b$</p></li><li><p><strong>If b is perpendicular to column space of A, Pb = 0 ==&gt; 一个点. 这里的 b 将会在矩阵 A 的左零空间, 即 $A^Tb=0$</strong></p><p><img src="https://i.loli.net/2020/08/10/HjQ14NlncXRaS5r.png" alt="image-20200810143944664" style="zoom:20%;" /></p></li></ul><p>这里的 <strong>(I-P)</strong> 也可以看做一个投影矩阵, 作用是将 b 向量投影到左零空间中.</p><h3 id="15-3-Least-Squares"><a href="#15-3-Least-Squares" class="headerlink" title="15.3 Least Squares"></a>15.3 Least Squares</h3><p>书接上文!</p><p><img src="https://i.loli.net/2020/08/10/qIk76gxjPulnS12.png" alt="image-20200810130925681" style="zoom:20%;" /></p><p>很明显, 这个方程无解, 因为这三点不共线. 这是典型的矩阵行比列多, 也就是说方程多于未知数. 既然无法共线那么我们就来找 $Ax$ 和 $b$ 之间的误差, 并将其最小化:</p><p><img src="https://i.loli.net/2020/08/10/ueLGjzhaRsnfgQV.png" alt="image-20200810201843421" style="zoom:20%;" /></p><p>我们可以将这些误差也就是偏移量反应到图上去, 以点 (1, 1) 为例:</p><p><img src="https://i.loli.net/2020/08/10/tGLdrUkp2x1J5aR.png" alt="image-20200810202111405" style="zoom:50%;" /></p><p>其中 <code>b</code> 表示该点的真实位置, <code>e</code> 代表着偏移量也就是误差, <code>p</code> 代表着拟合后的位置, 反映到列空间和左零空间的涂上就是:</p><p><img src="https://i.loli.net/2020/08/10/m5LXNFOMQ6JVyqe.jpg" alt="img" style="zoom:50%;" /></p><p>本质就是将 b 投影到矩阵 A 的列空间中. 现在我们来研究如何拟合, 将矩阵 <code>A</code> 和向量 <code>b</code> 代入 $A^TA\hat{x}=A^Tb$, 我们解一下方程.</p><p><img src="https://i.loli.net/2020/08/10/BiMcNIXh7GL3bOS.png" alt="image-20200810205552877" style="zoom:25%;" /></p><blockquote><p>  <strong>但值得注意的一点是: 我们在这里并没有考虑 outliers!!!</strong></p></blockquote><p>对了, 我们在这一节和上一节都用了一个前提假设, 就是 $A^TA$ 是可逆的. 但是什么情况下是可逆的呢? 在上一节我们提出了, <strong>如果矩阵 A 各列线性无关, 则矩阵 $A^TA$ 可逆</strong>. 我们接下来证明一下这个结论.</p><blockquote><p>   Let’s suppose $A^TAx=0$, 那么如果矩阵 $A^TA$ 要可逆, 那么其对应的 Nullspace 就必须仅含零向量. 那么我们就来证明一下这个 $x$ 只能是零向量.</p><p>   我们在等式两边同时乘以一个 $x^T$, 得到 $x^TA^TAx=0$, 也就是 $(Ax)^T(Ax)=0$, 这意味着 $Ax=0$. 而我们知道当矩阵 A 各列线性无关的时候, 要使 $Ax=0$, 只能是 $x$ 为零向量.</p><p>   因此我们证明了: <strong>如果矩阵 A 各列线性无关, 则矩阵 $A^TA$ 可逆</strong>.</p></blockquote><h3 id="15-4-Orthonormal-vector"><a href="#15-4-Orthonormal-vector" class="headerlink" title="15.4 Orthonormal vector"></a>15.4 Orthonormal vector</h3><p>这部分是为了下文做出基本介绍.</p><p>之前我们见过$\left|\begin{matrix}1\\0\\0\end{matrix}\right|$,$\left|\begin{matrix}0\\1\\0\end{matrix}\right|$,$\left|\begin{matrix}0\\0\\1\end{matrix}\right|$这组基, 它们是互相正交的, 但是它们还有更特殊的性质, 即它们都是单位向量, 长度为 1. 所以我们引入一个新名词: <strong>标准正交向量 (Orthonormal vectors)</strong>. 同样的标准正交向量还有: $\left|\begin{matrix}cos\theta\\sin\theta\end{matrix}\right|$,$\left|\begin{matrix}-sin\theta\\cos\theta\end{matrix}\right|$</p><p><strong>Columns are definitely independent if they are perpendicular vectors.</strong></p>]]></content>
      
      
      <categories>
          
          <category> Mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
